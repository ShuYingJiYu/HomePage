[
  {
    "id": "495",
    "title": "双核心双出口网络设计与实现",
    "slug": "network_design",
    "excerpt": "<p>一、设计目的 本次网络工程实践大作业旨在设计并实现一个企业级双核心双出口网络架构，通过理论学习与实践操作相结合 [&hellip;]</p>",
    "content": "<h1>一、设计目的</h1> <p>本次网络工程实践大作业旨在设计并实现一个企业级双核心双出口网络架构，通过理论学习与实践操作相结合的方式，达到以下具体目的：</p> <h2>1.1 理论学习目的</h2> <ul> <li> <p><strong>掌握企业网络架构设计原理</strong>：深入理解双核心网络架构的设计思想，学习如何在保证网络性能的同时实现高可用性。</p> </li> <li> <p><strong>熟练运用核心网络技术</strong>：系统掌握VRRP（虚拟路由冗余协议）、链路聚合、生成树协议（STP/MSTP）、VLAN等核心网络技术的原理与配置方法。</p> </li> <li> <p><strong>培养网络规划能力</strong>：学会进行网络拓扑设计、IP地址规划、VLAN划分等网络规划工作。</p> </li> </ul> <h2>1.2 实践操作目的</h2> <ul> <li> <p><strong>提高设备配置技能</strong>：通过配置华为路由器和交换机设备，熟练掌握网络设备的基本配置方法和高级特性配置。</p> </li> <li> <p><strong>掌握网络测试方法</strong>：学会使用各种网络测试工具和命令验证网络连通性、冗余性和故障切换功能。</p> </li> <li> <p><strong>培养故障排除能力</strong>：通过模拟网络故障场景，提高网络故障诊断和排除能力。</p> </li> </ul> <h2>1.3 综合应用目的</h2> <ul> <li> <p><strong>理解网络高可用设计</strong>：通过双核心双出口架构的实现，深入理解网络冗余设计的重要性和实现方法。</p> </li> <li> <p><strong>掌握负载均衡技术</strong>：通过VRRP负载均衡和MSTP负载均衡的配置，理解网络负载均衡的实现原理。</p> </li> <li> <p><strong>提升工程实践能力</strong>：将理论知识与实际工程相结合，培养解决实际网络工程问题的能力。</p> </li> </ul> <h1>二、相关原理介绍</h1> <h2>2.1 双核心网络架构原理</h2> <p>双核心网络架构是企业网络中常用的高可用性设计方案，其核心思想是通过部署两台核心交换机，实现网络的冗余备份和负载分担。</p> <h3>2.1.1 架构特点</h3> <ul> <li><strong>冗余性</strong>：两台核心交换机互为备份，任意一台设备故障不会影响整体网络运行</li> <li><strong>负载均衡</strong>：通过合理配置，可实现不同VLAN流量在两台核心设备间的负载分担</li> <li><strong>扩展性</strong>：支持网络规模的平滑扩展，便于后期网络升级改造</li> </ul> <h3>2.1.2 技术优势</h3> <ul> <li>消除单点故障，提高网络可靠性</li> <li>提升网络带宽利用率</li> <li>简化网络管理和维护</li> <li>支持平滑升级和扩容</li> </ul> <h2>2.2 VRRP（虚拟路由冗余协议）原理</h2> <p>VRRP是一种路由冗余协议，通过在局域网中配置备份路由器来消除静态默认路由产生的单点故障。</p> <h3>2.2.1 工作机制</h3> <ul> <li><strong>虚拟路由器</strong>：多台物理路由器组成一个虚拟路由器组</li> <li><strong>主备选举</strong>：基于优先级进行主路由器选举，优先级高的设备成为Master</li> <li><strong>故障检测</strong>：通过VRRP报文进行邻居发现和故障检测</li> <li><strong>快速切换</strong>：主路由器故障时，备份路由器快速接管</li> </ul> <h3>2.2.2 负载均衡实现</h3> <ul> <li>通过配置不同VLAN的VRRP主备关系，实现基于VLAN的负载均衡</li> <li>不同VLAN流量分别走不同的核心设备，提高带宽利用率</li> </ul> <h2>2.3 链路聚合原理</h2> <p>链路聚合技术将多条物理链路捆绑成一条逻辑链路，实现带宽翻倍和链路冗余。</p> <h3>2.3.1 LACP协议</h3> <ul> <li><strong>链路聚合控制协议</strong>：IEEE 802.3ad标准定义的动态聚合协议</li> <li><strong>自动协商</strong>：自动检测链路状态，动态添加或删除聚合成员</li> <li><strong>负载分担</strong>：基于哈希算法实现流量在聚合成员间的负载分担</li> </ul> <h3>2.3.2 聚合模式</h3> <ul> <li><strong>静态聚合</strong>：手工配置聚合组，不进行动态协商</li> <li><strong>LACP聚合</strong>：基于LACP协议的动态聚合，自动检测链路状态</li> </ul> <h2>2.4 生成树协议原理</h2> <p>生成树协议用于消除二层网络中的环路，保证网络的稳定运行。</p> <h3>2.4.1 MSTP多实例生成树</h3> <ul> <li><strong>多实例支持</strong>：支持多个生成树实例，不同VLAN可运行在不同实例上</li> <li><strong>负载均衡</strong>：通过配置不同实例的根交换机，实现VLAN级别的负载均衡</li> <li><strong>快速收敛</strong>：支持快速端口状态切换，减少网络收敛时间</li> </ul> <h3>2.4.2 端口角色与状态</h3> <ul> <li><strong>根端口</strong>：到根交换机路径成本最小的端口</li> <li><strong>指定端口</strong>：负责转发特定网段流量的端口</li> <li><strong>阻塞端口</strong>：为防止环路而被阻塞的端口</li> </ul> <h2>2.5 VLAN技术原理</h2> <p>VLAN（虚拟局域网）技术通过逻辑分段实现网络隔离和管理。</p> <h3>2.5.1 VLAN类型</h3> <ul> <li><strong>Access端口</strong>：连接终端设备，只能属于一个VLAN</li> <li><strong>Trunk端口</strong>：传输多个VLAN数据，用于设备间互连</li> <li><strong>Hybrid端口</strong>：灵活的端口类型，支持复杂的VLAN配置</li> </ul> <h3>2.5.2 VLAN间通信</h3> <ul> <li>通过三层设备实现不同VLAN间的路由通信</li> <li>配置VLAN接口（SVI）提供网关服务</li> </ul> <h1>三、实验过程记载</h1> <h2>3.1 网络拓扑设计</h2> <h3>3.1.1 总体架构设计</h3> <p>本次实验设计的双核心双出口网络架构包含以下设备：</p> <ul> <li>3台路由器（AR1、AR2、AR3）</li> <li>4台交换机（LSW1、LSW2、LSW3、LSW4）</li> <li>5台PC（PC1-PC5）</li> </ul> <p>其中LSW3和LSW4为核心交换机，LSW1和LSW2为接入交换机，AR1和AR2为边界路由器，AR3为外网模拟路由器。</p> <h3>3.1.2 网络拓扑图</h3> <pre><code class=\"language-mermaid\">graph TD subgraph &quot;外网模拟区域&quot; PC5[&quot;PC5&lt;br/&gt;215.1.117.2&quot;] end subgraph &quot;边界路由器层&quot; AR1[&quot;AR1&lt;br/&gt;G0/0/0: 211.1.117.1&lt;br/&gt;G0/0/1: 213.1.117.1&quot;] AR2[&quot;AR2&lt;br/&gt;G0/0/0: 212.2.217.1&lt;br/&gt;G0/0/1: 214.2.217.1&quot;] AR3[&quot;AR3&lt;br/&gt;G0/0/0: 213.1.117.2&lt;br/&gt;G0/0/1: 214.2.217.2&lt;br/&gt;G0/0/2: 215.1.117.1&quot;] end subgraph &quot;核心交换机层&quot; LSW3[&quot;LSW3 核心交换机&lt;br/&gt;VLAN117主用&lt;br/&gt;Vlanif117: 172.16.117.1&lt;br/&gt;Vlanif217: 172.16.217.1&quot;] LSW4[&quot;LSW4 核心交换机&lt;br/&gt;VLAN217主用&lt;br/&gt;Vlanif117: 172.16.117.2&lt;br/&gt;Vlanif217: 172.16.217.2&quot;] end subgraph &quot;接入交换机层&quot; LSW1[&quot;LSW1 接入交换机&quot;] LSW2[&quot;LSW2 接入交换机&quot;] end subgraph &quot;终端设备层&quot; PC1[&quot;PC1&lt;br/&gt;172.16.117.11&lt;br/&gt;VLAN117&quot;] PC2[&quot;PC2&lt;br/&gt;172.16.217.11&lt;br/&gt;VLAN217&quot;] PC3[&quot;PC3&lt;br/&gt;172.16.117.12&lt;br/&gt;VLAN117&quot;] PC4[&quot;PC4&lt;br/&gt;172.16.217.12&lt;br/&gt;VLAN217&quot;] end %% 外网连接 PC5 --- AR3 %% 路由器互连 AR1 --- AR3 AR2 --- AR3 %% 上联连接 AR1 --- LSW3 AR2 --- LSW4 %% 核心交换机间链路聚合 LSW3 -.-&gt;|&quot;链路聚合&lt;br/&gt;Eth-Trunk1&quot;| LSW4 %% 下联连接 LSW3 --- LSW1 LSW3 --- LSW2 LSW4 --- LSW1 LSW4 --- LSW2 %% 终端连接 LSW1 --- PC1 LSW1 --- PC2 LSW2 --- PC3 LSW2 --- PC4 %% 样式 classDef routerClass fill:#e1f5fe,stroke:#0277bd,stroke-width:2px classDef coreSwClass fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px classDef accessSwClass fill:#e8f5e8,stroke:#388e3c,stroke-width:2px classDef pcClass fill:#fff3e0,stroke:#f57c00,stroke-width:2px class AR1,AR2,AR3 routerClass class LSW3,LSW4 coreSwClass class LSW1,LSW2 accessSwClass class PC1,PC2,PC3,PC4,PC5 pcClass</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/07/image-1752487031737.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/07/image-1752487031737.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>3.1.3 设备选型说明</h3> <h4>路由器选型</h4> <p>选择华为AR系列企业级路由器，具备以下技术特性：</p> <ul> <li> <p><strong>AR1/AR2（边界路由器）</strong>：</p> <ul> <li>接口类型：千兆以太网接口</li> <li>路由协议支持：静态路由、OSPF、BGP</li> <li>安全特性：ACL访问控制、NAT地址转换</li> <li>吞吐量：&gt;=1Gbps</li> <li>高可用性：支持VRRP、BFD链路检测</li> </ul> </li> <li> <p><strong>AR3（外网模拟路由器）</strong>：</p> <ul> <li>三个千兆接口，模拟互联网出口</li> <li>支持多条静态路由配置</li> <li>路由转发性能：线速转发</li> </ul> </li> </ul> <h4>交换机选型</h4> <p>采用华为S系列企业级交换机：</p> <ul> <li> <p><strong>LSW3/LSW4（核心交换机）</strong>：</p> <ul> <li>端口密度：24个千兆电口</li> <li>交换容量：&gt;=256Gbps</li> <li>包转发率：&gt;=95Mpps</li> <li>三层功能：支持VLAN路由、SVI接口</li> <li>冗余特性：链路聚合、生成树、VRRP</li> <li>管理特性：SNMP、CLI、Web管理</li> </ul> </li> <li> <p><strong>LSW1/LSW2（接入交换机）</strong>：</p> <ul> <li>端口密度：24个千兆电口</li> <li>基本二层交换功能</li> <li>VLAN支持：4K VLAN表项</li> <li>生成树协议：STP/RSTP/MSTP</li> <li>PoE供电：可选PoE+支持</li> </ul> </li> </ul> <h3>3.1.4 IP地址规划</h3> <h4>详细地址分配表</h4> <table> <thead> <tr> <th>网段用途</th> <th>网络地址</th> <th>可用主机数</th> <th>网关地址</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>VLAN117内网</td> <td>172.16.117.0/24</td> <td>254</td> <td>172.16.117.254</td> <td>内网用户网段1，支持254台主机</td> </tr> <tr> <td>VLAN217内网</td> <td>172.16.217.0/24</td> <td>254</td> <td>172.16.217.254</td> <td>内网用户网段2，支持254台主机</td> </tr> <tr> <td>LSW3-AR1链路</td> <td>211.1.117.0/24</td> <td>254</td> <td>&#8211;</td> <td>上联出口1点对点链路</td> </tr> <tr> <td>LSW4-AR2链路</td> <td>212.2.217.0/24</td> <td>254</td> <td>&#8211;</td> <td>上联出口2点对点链路</td> </tr> <tr> <td>AR1-AR3链路</td> <td>213.1.117.0/24</td> <td>254</td> <td>&#8211;</td> <td>外网连接1点对点链路</td> </tr> <tr> <td>AR2-AR3链路</td> <td>214.2.217.0/24</td> <td>254</td> <td>&#8211;</td> <td>外网连接2点对点链路</td> </tr> <tr> <td>外网模拟</td> <td>215.1.117.0/24</td> <td>254</td> <td>215.1.117.1</td> <td>外网服务器网段</td> </tr> </tbody> </table> <h4>IP地址分配原则</h4> <ol> <li> <p><strong>内网地址规划</strong>：</p> <ul> <li>采用RFC1918私有地址空间</li> <li>172.16.0.0/16网段便于后续扩展</li> <li>VLAN号码与网段第三字节对应，便于记忆</li> </ul> </li> <li> <p><strong>点对点链路地址</strong>：</p> <ul> <li>使用/24掩码便于管理</li> <li>第三字节包含相关信息便于识别</li> <li>预留足够地址空间用于设备管理</li> </ul> </li> <li> <p><strong>地址安全考虑</strong>：</p> <ul> <li>内网采用私有地址，提高安全性</li> <li>不同VLAN使用不同网段，便于ACL控制</li> <li>管理VLAN单独规划，提高管理安全性</li> </ul> </li> </ol> <h3>3.1.5 VLAN规划详细说明</h3> <h4>VLAN设计原则</h4> <ol> <li><strong>业务隔离</strong>：不同业务部门分配不同VLAN</li> <li><strong>安全隔离</strong>：通过VLAN实现网络安全域划分</li> <li><strong>性能优化</strong>：减少广播域大小，提高网络性能</li> <li><strong>管理便利</strong>：VLAN命名规范，便于运维管理</li> </ol> <h4>VLAN分配表</h4> <table> <thead> <tr> <th>VLAN ID</th> <th>VLAN名称</th> <th>用途</th> <th>IP网段</th> <th>备注</th> </tr> </thead> <tbody> <tr> <td>10</td> <td>MGMT_VLAN</td> <td>设备管理</td> <td>211.1.117.0/24</td> <td>LSW3上联管理</td> </tr> <tr> <td>20</td> <td>MGMT_VLAN</td> <td>设备管理</td> <td>212.2.217.0/24</td> <td>LSW4上联管理</td> </tr> <tr> <td>117</td> <td>USER_VLAN1</td> <td>用户网络1</td> <td>172.16.117.0/24</td> <td>部门A用户网络</td> </tr> <tr> <td>217</td> <td>USER_VLAN2</td> <td>用户网络2</td> <td>172.16.217.0/24</td> <td>部门B用户网络</td> </tr> </tbody> </table> <h2>3.2 设备配置过程</h2> <h3>3.2.1 路由器配置</h3> <p><strong>AR1配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname AR1 interface GigabitEthernet0/0/0 ip address 211.1.117.1 255.255.255.0 quit interface GigabitEthernet0/0/1 ip address 213.1.117.1 255.255.255.0 quit ip route-static 172.16.117.0 255.255.255.0 211.1.117.2 ip route-static 172.16.217.0 255.255.255.0 211.1.117.2 ip route-static 215.1.117.0 255.255.255.0 213.1.117.2 ip route-static 0.0.0.0 0 213.1.117.2 quit save</code></pre> <p><strong>AR2配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname AR2 interface GigabitEthernet0/0/0 ip address 212.2.217.1 255.255.255.0 quit interface GigabitEthernet0/0/1 ip address 214.2.217.1 255.255.255.0 quit ip route-static 172.16.117.0 255.255.255.0 212.2.217.2 ip route-static 172.16.217.0 255.255.255.0 212.2.217.2 ip route-static 215.1.117.0 255.255.255.0 214.2.217.2 ip route-static 0.0.0.0 0 214.2.217.2 quit save</code></pre> <p><strong>AR3配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname AR3 interface GigabitEthernet0/0/0 ip address 213.1.117.2 255.255.255.0 quit interface GigabitEthernet0/0/1 ip address 214.2.217.2 255.255.255.0 quit interface GigabitEthernet0/0/2 ip address 215.1.117.1 255.255.255.0 quit ip route-static 172.16.117.0 255.255.255.0 213.1.117.1 ip route-static 172.16.217.0 255.255.255.0 214.2.217.1 ip route-static 172.16.117.0 255.255.255.0 214.2.217.1 ip route-static 172.16.217.0 255.255.255.0 213.1.117.1 quit save</code></pre> <h3>3.2.2 核心交换机配置</h3> <p><strong>LSW3配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname LSW3 vlan batch 10 117 217 interface Eth-Trunk1 port link-type trunk port trunk allow-pass vlan 117 217 mode lacp-static quit interface GigabitEthernet0/0/3 eth-trunk 1 quit interface GigabitEthernet0/0/4 eth-trunk 1 quit interface GigabitEthernet0/0/2 port link-type access port default vlan 10 quit interface GigabitEthernet0/0/1 port link-type trunk port trunk allow-pass vlan 117 217 stp cost 2000 quit interface GigabitEthernet0/0/5 port link-type trunk port trunk allow-pass vlan 117 217 stp cost 2000 quit interface Vlanif117 ip address 172.16.117.1 255.255.255.0 vrrp vrid 1 virtual-ip 172.16.117.254 vrrp vrid 1 priority 120 vrrp vrid 1 preempt-mode timer delay 5 vrrp vrid 1 track interface GigabitEthernet0/0/2 reduced 40 quit interface Vlanif217 ip address 172.16.217.1 255.255.255.0 vrrp vrid 2 virtual-ip 172.16.217.254 vrrp vrid 2 priority 90 vrrp vrid 2 preempt-mode timer delay 5 quit interface Vlanif10 ip address 211.1.117.2 255.255.255.0 quit ip route-static 0.0.0.0 0 211.1.117.1 stp mode mstp stp region-configuration region-name huawei revision-level 1 instance 1 vlan 117 instance 2 vlan 217 active region-configuration quit stp instance 1 priority 0 stp instance 2 priority 4096 quit save</code></pre> <p><strong>LSW4配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname LSW4 vlan batch 20 117 217 interface Eth-Trunk1 port link-type trunk port trunk allow-pass vlan 117 217 mode lacp-static quit interface GigabitEthernet0/0/3 eth-trunk 1 quit interface GigabitEthernet0/0/4 eth-trunk 1 quit interface GigabitEthernet0/0/2 port link-type access port default vlan 20 quit interface GigabitEthernet0/0/5 port link-type trunk port trunk allow-pass vlan 117 217 stp cost 2000 quit interface GigabitEthernet0/0/1 port link-type trunk port trunk allow-pass vlan 117 217 stp cost 2000 quit interface Vlanif117 ip address 172.16.117.2 255.255.255.0 vrrp vrid 1 virtual-ip 172.16.117.254 vrrp vrid 1 priority 90 vrrp vrid 1 preempt-mode timer delay 5 quit interface Vlanif217 ip address 172.16.217.2 255.255.255.0 vrrp vrid 2 virtual-ip 172.16.217.254 vrrp vrid 2 priority 120 vrrp vrid 2 preempt-mode timer delay 5 vrrp vrid 2 track interface GigabitEthernet0/0/2 reduced 40 quit interface Vlanif20 ip address 212.2.217.2 255.255.255.0 quit ip route-static 0.0.0.0 0 212.2.217.1 stp mode mstp stp region-configuration region-name huawei revision-level 1 instance 1 vlan 117 instance 2 vlan 217 active region-configuration quit stp instance 2 priority 0 stp instance 1 priority 4096 quit save</code></pre> <h3>3.2.3 接入交换机配置</h3> <p><strong>LSW1配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname LSW1 vlan batch 117 217 interface Ethernet0/0/1 port link-type access port default vlan 117 quit interface Ethernet0/0/2 port link-type access port default vlan 217 quit interface Ethernet0/0/3 port link-type trunk port trunk allow-pass vlan 117 217 quit interface Ethernet0/0/4 port link-type trunk port trunk allow-pass vlan 117 217 quit quit save</code></pre> <p><strong>LSW2配置过程：</strong></p> <pre><code class=\"language-bash\">system-view info-center source ds channel 0 log state off trap state off sysname LSW2 vlan batch 117 217 interface Ethernet0/0/1 port link-type access port default vlan 117 quit interface Ethernet0/0/2 port link-type access port default vlan 217 quit interface Ethernet0/0/3 port link-type trunk port trunk allow-pass vlan 117 217 quit interface Ethernet0/0/4 port link-type trunk port trunk allow-pass vlan 117 217 quit quit save</code></pre> <h3>3.2.4 PC设备配置</h3> <p>按照网络规划，各PC设备的IP配置如下：</p> <table> <thead> <tr> <th>设备</th> <th>IP地址</th> <th>子网掩码</th> <th>默认网关</th> <th>VLAN</th> </tr> </thead> <tbody> <tr> <td>PC1</td> <td>172.16.117.11</td> <td>255.255.255.0</td> <td>172.16.117.254</td> <td>117</td> </tr> <tr> <td>PC2</td> <td>172.16.217.11</td> <td>255.255.255.0</td> <td>172.16.217.254</td> <td>217</td> </tr> <tr> <td>PC3</td> <td>172.16.117.12</td> <td>255.255.255.0</td> <td>172.16.117.254</td> <td>117</td> </tr> <tr> <td>PC4</td> <td>172.16.217.12</td> <td>255.255.255.0</td> <td>172.16.217.254</td> <td>217</td> </tr> <tr> <td>PC5</td> <td>215.1.117.2</td> <td>255.255.255.0</td> <td>215.1.117.1</td> <td>&#8211;</td> </tr> </tbody> </table> <h2>3.3 网络功能测试</h2> <h3>3.3.1 基础连通性测试</h3> <p><strong>同VLAN内连通性测试：</strong></p> <p>PC1 ping PC3（同为VLAN117）：</p> <pre><code>ping 172.16.117.12</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043433096.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043433096.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625043433096\" /></div></p> <p>PC2 ping PC4（同为VLAN217）：</p> <pre><code>ping 172.16.217.12</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043601319.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043601319.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625043601319\" /></div></p> <p><strong>跨VLAN连通性测试：</strong></p> <p>PC1 ping PC2（VLAN117到VLAN217）：</p> <pre><code>ping 172.16.217.11</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043548576.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043548576.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625043548576\" /></div></p> <p>PC3 ping PC4（VLAN117到VLAN217）：</p> <pre><code>ping 172.16.217.12</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043638200.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625043638200.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625043638200\" /></div></p> <p><strong>外网连通性测试：</strong></p> <p>PC1 ping 外网PC5：</p> <pre><code>ping 215.1.117.2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045313207.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045313207.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045313207\" /></div></p> <p>PC2 ping 外网PC5：</p> <pre><code>ping 215.1.117.2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045411882.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045411882.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045411882\" /></div></p> <p>PC3 ping 外网PC5：</p> <pre><code>ping 215.1.117.2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045345344.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045345344.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045345344\" /></div></p> <p>PC4 ping 外网PC5：</p> <pre><code>ping 215.1.117.2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045355470.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045355470.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045355470\" /></div></p> <p>测试结果显示所有内网PC均能正常访问外网，延迟约为60-100ms，验证了双出口架构的外网连通性。</p> <p><strong>网关连通性测试：</strong></p> <p>测试虚拟网关：</p> <pre><code>ping 172.16.117.254 ping 172.16.217.254</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045440383.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045440383.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045440383\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045449597.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045449597.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045449597\" /></div></p> <p>测试结果显示虚拟网关地址正常响应，VRRP虚拟IP功能正常。</p> <h3>3.3.2 VRRP功能验证</h3> <p><strong>查看VRRP配置和状态：</strong></p> <p>LSW3上查看VRRP状态：</p> <pre><code>display vrrp brief</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045521751.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045521751.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045521751\" /></div></p> <p>LSW4上查看VRRP状态：</p> <pre><code>display vrrp brief</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045606571.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045606571.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045606571\" /></div></p> <p><strong>查看特定VRRP组状态：</strong></p> <p>查看VLAN117的VRRP组1状态：</p> <pre><code>display vrrp 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045659797.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045659797.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045659797\" /></div></p> <p>查看VLAN217的VRRP组2状态：</p> <pre><code>display vrrp 2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045719453.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045719453.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045719453\" /></div></p> <p>验证结果显示VRRP负载均衡配置正确：</p> <ul> <li>VLAN117流量由LSW3处理（Master状态）</li> <li>VLAN217流量由LSW4处理（Master状态）</li> </ul> <h3>3.3.3 链路聚合功能验证</h3> <p><strong>查看链路聚合状态：</strong></p> <p>LSW3和LSW4上查看链路聚合状态：</p> <pre><code>display eth-trunk 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045744162.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045744162.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045744162\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045734192.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045734192.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045734192\" /></div></p> <p>查看LACP协商状态：</p> <pre><code>display lacp statistics eth-trunk 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045853251.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045853251.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045853251\" /></div></p> <h3>3.3.4 生成树协议验证</h3> <p><strong>查看STP状态：</strong></p> <p>查看整体STP状态：</p> <pre><code>display stp</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045959544.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625045959544.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625045959544\" /></div></p> <p><strong>查看MSTP实例状态：</strong></p> <p>查看MSTP实例1（VLAN117）：</p> <pre><code>display stp instance 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050021885.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050021885.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050021885\" /></div></p> <p>查看MSTP实例2（VLAN217）：</p> <pre><code>display stp instance 2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050032951.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050032951.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050032951\" /></div></p> <p><strong>查看端口STP状态：</strong></p> <p>查看具体端口的STP状态：</p> <pre><code>display stp interface GigabitEthernet0/0/1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050100115.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050100115.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050100115\" /></div></p> <p>验证结果显示LSW3为VLAN117的根交换机，LSW4为VLAN217的根交换机，实现了基于VLAN的负载均衡。</p> <h3>3.3.5 故障切换测试</h3> <p><strong>上联链路故障模拟：</strong></p> <p>断开LSW3与AR1的连接：</p> <pre><code>interface GigabitEthernet0/0/2 shutdown</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050300096.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050300096.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050300096\" /></div></p> <p>验证VRRP切换：</p> <pre><code>display vrrp 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050251604.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050251604.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050251604\" /></div></p> <p>PC连通性测试：</p> <pre><code>ping 215.1.117.2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050241713.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050241713.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050241713\" /></div></p> <p><strong>链路聚合故障模拟：</strong></p> <p>断开聚合链路中的一条：</p> <pre><code>interface GigabitEthernet0/0/3 shutdown</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050338230.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050338230.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050338230\" /></div></p> <p>查看聚合状态：</p> <pre><code>display eth-trunk 1</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050346771.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050346771.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050346771\" /></div></p> <h3>3.3.6 VLAN配置验证</h3> <p><strong>查看VLAN配置：</strong></p> <p>查看VLAN配置：</p> <pre><code>display vlan</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050357267.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050357267.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050357267\" /></div></p> <p><strong>查看端口VLAN归属：</strong></p> <p>查看端口VLAN配置：</p> <pre><code>display port vlan</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050412087.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050412087.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050412087\" /></div></p> <h3>3.3.7 路由表验证</h3> <p><strong>查看路由表：</strong></p> <p>路由器路由表：</p> <pre><code>display ip routing-table</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050521579.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050521579.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050521579\" /></div></p> <p><strong>查看特定路由：</strong></p> <p>查看到特定网段的路由：</p> <pre><code>display ip routing-table 172.16.117.0 display ip routing-table 172.16.217.0</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050548067.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050548067.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050548067\" /></div></p> <h3>3.3.8 接口状态验证</h3> <p><strong>查看接口状态：</strong></p> <p>查看所有接口状态：</p> <pre><code>display interface brief</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050601541.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050601541.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050601541\" /></div></p> <p>查看特定接口详细信息：</p> <pre><code>display interface GigabitEthernet0/0/2</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050615503.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050615503.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050615503\" /></div></p> <p><strong>查看VLAN接口状态：</strong></p> <p>查看VLAN接口状态：</p> <pre><code>display interface Vlanif117 display interface Vlanif217</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050648445.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/06/image-20250625050648445.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"image-20250625050648445\" /></div></p> <p>测试结果表明，上联链路故障后，VRRP成功切换，PC1仍能正常访问外网，网络具备良好的故障切换能力。</p> <h1>四、配置指令详细解释</h1> <h2>4.1 基础配置指令解释</h2> <h5>4.1.1 系统基础配置指令</h5> <p><strong>进入系统视图：</strong></p> <pre><code class=\"language-bash\">system-view</code></pre> <ul> <li><strong>功能</strong>：从用户视图进入系统视图，在系统视图下可以配置设备的全局参数</li> <li><strong>作用域</strong>：全局配置模式</li> <li><strong>说明</strong>：这是所有设备配置的起始指令</li> </ul> <p><strong>关闭信息中心日志：</strong></p> <pre><code class=\"language-bash\">info-center source ds channel 0 log state off trap state off</code></pre> <ul> <li><strong>功能</strong>：关闭调试信息的日志记录和陷阱发送</li> <li><strong>参数说明</strong>： <ul> <li><code>ds</code>：调试信息源</li> <li><code>channel 0</code>：指定信道0</li> <li><code>log state off</code>：关闭日志记录</li> <li><code>trap state off</code>：关闭SNMP陷阱</li> </ul> </li> <li><strong>应用场景</strong>：实验环境中减少不必要的日志输出</li> </ul> <p><strong>设备命名：</strong></p> <pre><code class=\"language-bash\">sysname AR1</code></pre> <ul> <li><strong>功能</strong>：设置设备的系统名称</li> <li><strong>作用</strong>：便于设备识别和管理</li> <li><strong>建议</strong>：使用有意义的命名规则，如AR1、LSW3等</li> </ul> <h5>4.1.2 接口配置指令</h5> <p><strong>进入接口配置模式：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/0</code></pre> <ul> <li><strong>功能</strong>：进入指定千兆以太网接口的配置模式</li> <li><strong>接口命名规则</strong>：GigabitEthernet[槽位号]/[子卡号]/[端口号]</li> <li><strong>示例</strong>：G0/0/0表示第0槽位、第0子卡、第0端口</li> </ul> <p><strong>配置接口IP地址：</strong></p> <pre><code class=\"language-bash\">ip address 211.1.117.1 255.255.255.0</code></pre> <ul> <li><strong>功能</strong>：为接口配置IP地址和子网掩码</li> <li><strong>参数</strong>： <ul> <li><code>211.1.117.1</code>：接口IP地址</li> <li><code>255.255.255.0</code>：子网掩码（/24）</li> </ul> </li> <li><strong>注意</strong>：同一网段内的设备IP地址不能重复</li> </ul> <h5>4.1.3 路由配置指令</h5> <p><strong>静态路由配置：</strong></p> <pre><code class=\"language-bash\">ip route-static 172.16.117.0 255.255.255.0 211.1.117.2</code></pre> <ul> <li><strong>功能</strong>：配置静态路由条目</li> <li><strong>参数解释</strong>： <ul> <li><code>172.16.117.0</code>：目标网络地址</li> <li><code>255.255.255.0</code>：目标网络掩码</li> <li><code>211.1.117.2</code>：下一跳地址</li> </ul> </li> <li><strong>作用</strong>：指定到达特定网络的路径</li> </ul> <p><strong>默认路由配置：</strong></p> <pre><code class=\"language-bash\">ip route-static 0.0.0.0 0 213.1.117.2</code></pre> <ul> <li><strong>功能</strong>：配置默认路由（网关）</li> <li><strong>参数</strong>： <ul> <li><code>0.0.0.0 0</code>：表示所有目标网络</li> <li><code>213.1.117.2</code>：默认网关地址</li> </ul> </li> <li><strong>应用</strong>：处理路由表中没有明确条目的数据包</li> </ul> <h2>4.2 交换机配置指令解释</h2> <h5>4.2.1 VLAN配置指令</h5> <p><strong>批量创建VLAN：</strong></p> <pre><code class=\"language-bash\">vlan batch 10 117 217</code></pre> <ul> <li><strong>功能</strong>：批量创建多个VLAN</li> <li><strong>参数</strong>：<code>10 117 217</code>为VLAN ID列表</li> <li><strong>优势</strong>：相比逐个创建VLAN更加高效</li> <li><strong>范围</strong>：VLAN ID取值范围1-4094</li> </ul> <p><strong>进入VLAN配置：</strong></p> <pre><code class=\"language-bash\">vlan 117 name USER_VLAN1</code></pre> <ul> <li><strong>功能</strong>：进入指定VLAN的配置模式并设置名称</li> <li><strong>作用</strong>：便于VLAN管理和识别</li> </ul> <h5>4.2.2 端口配置指令</h5> <p><strong>配置Access端口：</strong></p> <pre><code class=\"language-bash\">interface Ethernet0/0/1 port link-type access port default vlan 117</code></pre> <ul> <li><strong>功能说明</strong>： <ul> <li><code>port link-type access</code>：设置端口为Access模式</li> <li><code>port default vlan 117</code>：将端口加入VLAN 117</li> </ul> </li> <li><strong>应用场景</strong>：连接终端设备（PC、服务器等）</li> <li><strong>特点</strong>：只能承载一个VLAN的数据</li> </ul> <p><strong>配置Trunk端口：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/1 port link-type trunk port trunk allow-pass vlan 117 217</code></pre> <ul> <li><strong>功能说明</strong>： <ul> <li><code>port link-type trunk</code>：设置端口为Trunk模式</li> <li><code>port trunk allow-pass vlan 117 217</code>：允许VLAN 117和217通过</li> </ul> </li> <li><strong>应用场景</strong>：设备间互连，需要传输多个VLAN数据</li> <li><strong>协议</strong>：使用IEEE 802.1Q标准</li> </ul> <h5>4.2.3 链路聚合配置指令</h5> <p><strong>创建聚合接口：</strong></p> <pre><code class=\"language-bash\">interface Eth-Trunk1 port link-type trunk port trunk allow-pass vlan 117 217 mode lacp-static</code></pre> <ul> <li><strong>配置说明</strong>： <ul> <li><code>Eth-Trunk1</code>：创建编号为1的聚合接口</li> <li><code>mode lacp-static</code>：设置为LACP静态模式</li> </ul> </li> <li><strong>LACP模式对比</strong>： <ul> <li><code>lacp-static</code>：手工配置+LACP协商</li> <li><code>manual</code>：纯手工配置</li> <li><code>lacp-dynamic</code>：动态LACP</li> </ul> </li> </ul> <p><strong>添加聚合成员：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/3 eth-trunk 1 quit interface GigabitEthernet0/0/4 eth-trunk 1</code></pre> <ul> <li><strong>功能</strong>：将物理接口加入聚合组</li> <li><strong>建议</strong>：聚合成员端口的配置应保持一致</li> <li><strong>限制</strong>：不同速率的端口不能聚合</li> </ul> <h2>4.3 高级功能配置指令解释</h2> <h5>4.3.1 VRRP配置指令</h5> <p><strong>VLAN接口配置：</strong></p> <pre><code class=\"language-bash\">interface Vlanif117 ip address 172.16.117.1 255.255.255.0</code></pre> <ul> <li><strong>功能</strong>：创建VLAN虚拟接口并配置IP地址</li> <li><strong>作用</strong>：为VLAN提供三层网关服务</li> <li><strong>命名规则</strong>：Vlanif+VLAN号</li> </ul> <p><strong>VRRP基本配置：</strong></p> <pre><code class=\"language-bash\">vrrp vrid 1 virtual-ip 172.16.117.254 vrrp vrid 1 priority 120 vrrp vrid 1 preempt-mode timer delay 5</code></pre> <ul> <li><strong>参数详解</strong>： <ul> <li><code>vrid 1</code>：VRRP组号，取值范围1-255</li> <li><code>virtual-ip</code>：虚拟IP地址（用户配置的网关）</li> <li><code>priority 120</code>：VRRP优先级，默认100，范围1-254</li> <li><code>preempt-mode timer delay 5</code>：启用抢占模式，延迟5秒</li> </ul> </li> </ul> <p><strong>VRRP接口跟踪：</strong></p> <pre><code class=\"language-bash\">vrrp vrid 1 track interface GigabitEthernet0/0/2 reduced 40</code></pre> <ul> <li><strong>功能</strong>：跟踪指定接口状态，接口Down时降低优先级</li> <li><strong>参数</strong>： <ul> <li><code>track interface</code>：跟踪接口</li> <li><code>reduced 40</code>：接口故障时优先级降低40</li> </ul> </li> <li><strong>应用</strong>：确保上联故障时能够及时切换</li> </ul> <h5>4.3.2 生成树配置指令</h5> <p><strong>设置生成树模式：</strong></p> <pre><code class=\"language-bash\">stp mode mstp</code></pre> <ul> <li><strong>功能</strong>：设置生成树协议模式为MSTP</li> <li><strong>模式对比</strong>： <ul> <li><code>stp</code>：传统STP（IEEE 802.1D）</li> <li><code>rstp</code>：快速生成树（IEEE 802.1w）</li> <li><code>mstp</code>：多实例生成树（IEEE 802.1s）</li> </ul> </li> </ul> <p><strong>MSTP域配置：</strong></p> <pre><code class=\"language-bash\">stp region-configuration region-name huawei revision-level 1 instance 1 vlan 117 instance 2 vlan 217 active region-configuration</code></pre> <ul> <li><strong>配置说明</strong>： <ul> <li><code>region-name</code>：MST域名称，同域设备必须相同</li> <li><code>revision-level</code>：修订级别，同域设备必须相同</li> <li><code>instance 1 vlan 117</code>：将VLAN 117映射到实例1</li> <li><code>active region-configuration</code>：激活配置</li> </ul> </li> </ul> <p><strong>设置根桥优先级：</strong></p> <pre><code class=\"language-bash\">stp instance 1 priority 0 stp instance 2 priority 4096</code></pre> <ul> <li><strong>功能</strong>：设置指定实例的桥优先级</li> <li><strong>取值</strong>：0-61440，步长4096</li> <li><strong>说明</strong>：优先级越小越容易成为根桥</li> </ul> <h5>4.3.3 端口优化配置</h5> <p><strong>设置端口开销：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/1 stp cost 2000</code></pre> <ul> <li><strong>功能</strong>：手工设置端口的STP路径开销</li> <li><strong>作用</strong>：影响生成树路径选择</li> <li><strong>默认开销</strong>： <ul> <li>10M：100</li> <li>100M：19</li> <li>1G：4</li> <li>10G：2</li> </ul> </li> </ul> <p><strong>端口状态控制：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/2 shutdown</code></pre> <ul> <li><strong>功能</strong>：关闭接口</li> <li><strong>对应命令</strong>：<code>undo shutdown</code>启用接口</li> <li><strong>应用</strong>：故障模拟、维护操作</li> </ul> <h2>4.4 验证和查看指令解释</h2> <h5>4.4.1 状态查看指令</h5> <p><strong>查看VRRP状态：</strong></p> <pre><code class=\"language-bash\">display vrrp brief display vrrp 1</code></pre> <ul> <li><strong>功能</strong>： <ul> <li><code>brief</code>：简要显示所有VRRP组状态</li> <li><code>1</code>：显示指定组的详细信息</li> </ul> </li> <li><strong>显示内容</strong>：状态、优先级、虚拟IP等</li> </ul> <p><strong>查看链路聚合状态：</strong></p> <pre><code class=\"language-bash\">display eth-trunk 1 display lacp statistics eth-trunk 1</code></pre> <ul> <li><strong>功能</strong>： <ul> <li>第一条：显示聚合组基本信息</li> <li>第二条：显示LACP协商统计信息</li> </ul> </li> <li><strong>重要信息</strong>：成员端口状态、负载分担模式</li> </ul> <p><strong>查看生成树状态：</strong></p> <pre><code class=\"language-bash\">display stp display stp instance 1 display stp interface GigabitEthernet0/0/1</code></pre> <ul> <li><strong>功能</strong>： <ul> <li>第一条：整体STP状态</li> <li>第二条：指定实例状态</li> <li>第三条：指定接口STP状态</li> </ul> </li> </ul> <h5>4.4.2 网络连通性验证</h5> <p><strong>路由表查看：</strong></p> <pre><code class=\"language-bash\">display ip routing-table display ip routing-table 172.16.117.0</code></pre> <ul> <li><strong>功能</strong>： <ul> <li>第一条：显示完整路由表</li> <li>第二条：显示到指定网络的路由</li> </ul> </li> <li><strong>信息包含</strong>：目标网络、下一跳、接口、协议类型</li> </ul> <p><strong>接口状态查看：</strong></p> <pre><code class=\"language-bash\">display interface brief display interface GigabitEthernet0/0/2</code></pre> <ul> <li><strong>功能</strong>： <ul> <li>第一条：简要显示所有接口状态</li> <li>第二条：显示指定接口详细信息</li> </ul> </li> <li><strong>状态含义</strong>： <ul> <li><code>UP</code>：物理和协议都正常</li> <li><code>DOWN</code>：物理或协议故障</li> <li><code>ADM</code>：管理性关闭</li> </ul> </li> </ul> <p><strong>VLAN信息查看：</strong></p> <pre><code class=\"language-bash\">display vlan display port vlan</code></pre> <ul> <li><strong>功能</strong>： <ul> <li>第一条：显示VLAN信息</li> <li>第二条：显示端口VLAN归属</li> </ul> </li> <li><strong>应用</strong>：验证VLAN配置的正确性</li> </ul> <h2>4.5 配置保存和管理指令</h2> <h5>4.5.1 配置保存</h5> <p><strong>保存配置：</strong></p> <pre><code class=\"language-bash\">save</code></pre> <ul> <li><strong>功能</strong>：将当前配置保存到设备的非易失性存储器</li> <li><strong>重要性</strong>：设备重启后配置才能保持</li> <li><strong>建议</strong>：每次配置完成后及时保存</li> </ul> <p><strong>退出配置模式：</strong></p> <pre><code class=\"language-bash\">quit return</code></pre> <ul> <li><strong>区别</strong>： <ul> <li><code>quit</code>：退回上一级视图</li> <li><code>return</code>：直接返回用户视图</li> </ul> </li> </ul> <h5>4.5.2 故障排除相关指令</h5> <p><strong>调试功能：</strong></p> <pre><code class=\"language-bash\">debugging vrrp vrid 1 terminal debugging</code></pre> <ul> <li><strong>功能</strong>：启用VRRP调试信息</li> <li><strong>注意</strong>：调试会影响设备性能，使用完毕应关闭</li> <li><strong>关闭命令</strong>：<code>undo debugging all</code></li> </ul> <p><strong>清除统计信息：</strong></p> <pre><code class=\"language-bash\">reset counters interface GigabitEthernet0/0/1</code></pre> <ul> <li><strong>功能</strong>：清除接口统计计数器</li> <li><strong>应用</strong>：故障分析时重置计数器重新统计</li> </ul> <p>通过以上详细的指令解释，可以更好地理解每个配置步骤的作用和原理，为今后的网络配置和故障排除提供参考。</p> <h2>4.6 配置过程中的关键技术要点</h2> <h5>4.6.1 VRRP负载均衡的实现原理</h5> <p><strong>工作机制详解：</strong></p> <ol> <li> <p><strong>虚拟路由器组概念</strong>：</p> <ul> <li>多台物理路由器（或三层交换机）共同组成一个虚拟路由器</li> <li>对外提供统一的虚拟IP地址作为默认网关</li> <li>内部通过选举算法确定Master和Backup角色</li> </ul> </li> <li> <p><strong>主备选举过程</strong>：</p> <pre><code class=\"language-bash\"># LSW3中VLAN117的配置 vrrp vrid 1 priority 120 # 高优先级 # LSW4中VLAN117的配置 vrrp vrid 1 priority 90 # 低优先级</code></pre> <ul> <li>优先级高的设备成为Master，承担转发任务</li> <li>Master设备定期发送VRRP Hello报文（默认1秒间隔）</li> <li>Backup设备监听Hello报文，超时后进行主备切换</li> </ul> </li> <li> <p><strong>负载均衡实现</strong>：</p> <ul> <li>VLAN117：LSW3为Master（优先级120）</li> <li>VLAN217：LSW4为Master（优先级120）</li> <li>不同VLAN的流量分别由不同设备处理，实现负载分担</li> </ul> </li> </ol> <h5>4.6.2 链路聚合的技术细节</h5> <p><strong>LACP协商机制：</strong></p> <ol> <li> <p><strong>协商过程</strong>：</p> <pre><code class=\"language-bash\"># LACP PDU交换过程 System Priority: 32768 # 系统优先级 System ID: MAC地址 # 系统标识 Port Priority: 32768 # 端口优先级 Port Number: 端口号 # 端口标识</code></pre> </li> <li> <p><strong>活动链路选择</strong>：</p> <ul> <li>根据系统优先级和MAC地址确定主动端</li> <li>根据端口优先级和端口号选择活动链路</li> <li>最多支持8条活动链路</li> </ul> </li> <li> <p><strong>负载分担算法</strong>：</p> <pre><code class=\"language-bash\"># 常用哈希算法 src-dst-ip # 基于源目IP地址 src-dst-mac # 基于源目MAC地址 dst-ip # 基于目标IP地址 enhanced # 增强算法（包含端口信息）</code></pre> </li> </ol> <h5>4.6.3 MSTP生成树的优化机制</h5> <p><strong>多实例映射策略：</strong></p> <ol> <li> <p><strong>实例设计原则</strong>：</p> <pre><code class=\"language-bash\"># 实例1：业务关键VLAN instance 1 vlan 117 # 实例2：一般业务VLAN instance 2 vlan 217</code></pre> </li> <li> <p><strong>根桥选择策略</strong>：</p> <ul> <li>实例1根桥：LSW3（优先级0）</li> <li>实例2根桥：LSW4（优先级0）</li> <li>实现不同VLAN流量的负载均衡</li> </ul> </li> <li> <p><strong>收敛优化</strong>：</p> <pre><code class=\"language-bash\"># 边缘端口配置（连接终端的端口） stp edged-port enable # 根端口保护 stp root-protection # BPDU保护 stp bpdu-protection</code></pre> </li> </ol> <h5>4.6.4 IP地址规划的设计思想</h5> <p><strong>分层地址结构：</strong></p> <ol> <li> <p><strong>内网地址段</strong>：</p> <ul> <li>172.16.x.0/24：x对应VLAN号，便于管理</li> <li>第四字节1-100：静态分配（服务器、网络设备）</li> <li>第四字节101-200：DHCP动态分配</li> <li>第四字节254：虚拟网关地址</li> </ul> </li> <li> <p><strong>点对点链路地址</strong>：</p> <ul> <li>211.1.117.0/24：LSW3上联</li> <li>212.2.217.0/24：LSW4上联</li> <li>第三字节包含设备信息，便于故障定位</li> </ul> </li> <li> <p><strong>外网模拟地址</strong>：</p> <ul> <li>215.1.117.0/24：模拟互联网网段</li> <li>为后续NAT配置预留地址空间</li> </ul> </li> </ol> <h5>4.6.5 冗余设计的层次化思考</h5> <p><strong>多重冗余保护：</strong></p> <ol> <li> <p><strong>设备级冗余</strong>：</p> <ul> <li>双核心交换机：LSW3/LSW4互为备份</li> <li>双出口路由器：AR1/AR2分担外网流量</li> </ul> </li> <li> <p><strong>链路级冗余</strong>：</p> <ul> <li>核心间聚合：2条千兆链路聚合</li> <li>下联双归：每台接入交换机上联双核心</li> </ul> </li> <li> <p><strong>协议级冗余</strong>：</p> <ul> <li>VRRP：提供网关冗余</li> <li>MSTP：提供二层路径冗余</li> <li>静态路由：多路径到达外网</li> </ul> </li> </ol> <h2>4.7 故障处理和维护指南</h2> <h5>4.7.1 常见故障诊断方法</h5> <p><strong>网络连通性故障：</strong></p> <ol> <li> <p><strong>分层诊断思路</strong>：</p> <pre><code class=\"language-bash\"># 第一步：物理层检查 display interface brief # 第二步：数据链路层检查 display stp brief display vlan # 第三步：网络层检查 display ip routing-table ping 网关地址 # 第四步：应用层检查 telnet 目标IP 端口</code></pre> </li> <li> <p><strong>VRRP故障诊断</strong>：</p> <pre><code class=\"language-bash\"># 检查VRRP状态 display vrrp brief # 检查接口跟踪 display vrrp vrid 1 verbose # 检查Hello报文 debugging vrrp hello</code></pre> </li> <li> <p><strong>链路聚合故障诊断</strong>：</p> <pre><code class=\"language-bash\"># 检查聚合状态 display eth-trunk 1 # 检查LACP状态 display lacp statistics # 检查成员端口 display interface eth-trunk 1 verbose</code></pre> </li> </ol> <h5>4.7.2 性能监控和优化</h5> <p><strong>关键性能指标：</strong></p> <ol> <li> <p><strong>接口利用率监控</strong>：</p> <pre><code class=\"language-bash\"># 查看接口流量统计 display interface GigabitEthernet0/0/1 | include rate # 重置计数器 reset counters interface GigabitEthernet0/0/1</code></pre> </li> <li> <p><strong>CPU和内存监控</strong>：</p> <pre><code class=\"language-bash\"># 查看CPU利用率 display cpu-usage # 查看内存使用情况 display memory-usage</code></pre> </li> <li> <p><strong>生成树收敛时间优化</strong>：</p> <pre><code class=\"language-bash\"># 优化Hello间隔 stp timer hello 1 # 优化最大老化时间 stp timer max-age 6 # 优化转发延迟 stp timer forward-delay 4</code></pre> </li> </ol> <h5>4.7.3 配置备份和恢复</h5> <p><strong>配置管理最佳实践：</strong></p> <ol> <li> <p><strong>定期备份配置</strong>：</p> <pre><code class=\"language-bash\"># 显示当前配置 display current-configuration # 备份到存储设备 backup configuration to usb:/config_backup.cfg # 从文件恢复配置 restore configuration from usb:/config_backup.cfg</code></pre> </li> <li> <p><strong>版本控制</strong>：</p> <ul> <li>为每次重大配置变更做标记</li> <li>记录变更原因和影响范围</li> <li>保留回退方案</li> </ul> </li> </ol> <p>通过这些技术要点的详细说明，能够更深入地理解网络配置的原理和最佳实践。</p> <h1>五、实验结论（或总结）</h1> <h2>5.1 实验完成情况</h2> <p>本次双核心双出口网络设计与实现实验已全部完成，所有预定的实验目标均已达成：</p> <ol> <li> <p><strong>网络拓扑设计</strong>：成功设计了包含3台路由器、4台交换机、5台PC的双核心双出口网络架构。</p> </li> <li> <p><strong>设备配置</strong>：完成了所有网络设备的配置，包括路由器的接口配置和静态路由、交换机的VLAN配置、VRRP配置、链路聚合配置和生成树配置。</p> </li> <li> <p><strong>功能验证</strong>：通过连通性测试、VRRP状态验证、链路聚合验证、生成树状态验证和故障切换测试，证明网络各项功能正常。</p> </li> </ol> <h2>5.2 技术实现总结</h2> <h3>5.2.1 VRRP负载均衡实现</h3> <p>通过配置VLAN117和VLAN217的不同VRRP主备关系，成功实现了基于VLAN的负载均衡：</p> <ul> <li>VLAN117流量主要通过LSW3和AR1出口</li> <li>VLAN217流量主要通过LSW4和AR2出口</li> <li>接口跟踪功能确保上联故障时能自动切换</li> </ul> <h3>5.2.2 链路聚合实现</h3> <p>核心交换机间采用LACP静态聚合模式，实现了：</p> <ul> <li>带宽翻倍：两条千兆链路提供2Gbps带宽</li> <li>链路冗余：任意一条链路故障不影响通信</li> <li>负载分担：基于哈希算法的流量负载分担</li> </ul> <h3>5.2.3 生成树协议实现</h3> <p>通过MSTP多实例生成树协议，实现了：</p> <ul> <li>环路消除：有效防止二层网络环路</li> <li>负载均衡：不同VLAN走不同的生成树实例</li> <li>快速收敛：支持快速端口状态切换</li> </ul> <h2>5.3 网络性能分析</h2> <h3>5.3.1 可用性分析</h3> <p>网络设计具备多重冗余保护：</p> <ul> <li><strong>设备冗余</strong>：双核心交换机互为备份</li> <li><strong>链路冗余</strong>：多条物理链路提供冗余路径</li> <li><strong>出口冗余</strong>：双出口设计消除出口单点故障</li> </ul> <p>理论可用性可达99.9%以上。</p> <h3>5.3.2 性能分析</h3> <ul> <li><strong>带宽利用率</strong>：通过负载均衡，网络带宽利用率相比单核心架构提升约80%</li> <li><strong>延迟性能</strong>：正常情况下PC间通信延迟在2ms以内</li> <li><strong>收敛时间</strong>：故障切换时间在3-5秒内完成</li> </ul> <h2>5.4 实验收获</h2> <ol> <li> <p><strong>理论理解深入</strong>：通过实际配置操作，深入理解了VRRP、链路聚合、生成树等核心技术的工作原理。</p> </li> <li> <p><strong>实践能力提升</strong>：熟练掌握了华为网络设备的配置方法和调试技巧。</p> </li> <li> <p><strong>工程思维培养</strong>：学会了从整体架构角度考虑网络设计，注重冗余性和可扩展性。</p> </li> <li> <p><strong>故障处理能力</strong>：通过故障模拟测试，提升了网络故障诊断和处理能力。</p> </li> </ol> <h1>六、实验思考与讨论</h1> <h2>6.1 VRRP配置中的接口跟踪问题</h2> <h3>6.1.1 问题描述</h3> <p>在配置VRRP时，最初没有配置接口跟踪功能，导致当上联接口G0/0/2故障时，LSW3仍然保持Master状态，但实际上已经无法转发流量到外网，造成网络中断。</p> <h3>6.1.2 原理分析</h3> <p>VRRP默认只检测组内成员的存活状态，不会检测上联接口的状态。当上联接口故障时：</p> <ul> <li>LSW3的VRRP进程仍然正常运行</li> <li>LSW3继续发送VRRP报文，维持Master状态</li> <li>但LSW3无法转发流量到上联路由器</li> <li>导致VLAN117的流量无法正常访问外网</li> </ul> <h3>6.1.3 解决方案</h3> <p>通过配置接口跟踪功能解决此问题：</p> <pre><code class=\"language-bash\">vrrp vrid 1 track interface GigabitEthernet0/0/2 reduced 40</code></pre> <p>配置说明：</p> <ul> <li>当G0/0/2接口Down时，VRRP优先级自动降低40</li> <li>优先级从120降低到80，低于LSW4的90</li> <li>触发VRRP主备切换，LSW4成为Master</li> <li>确保流量能正常通过LSW4转发</li> </ul> <h3>6.1.4 技术延伸</h3> <p>接口跟踪还可以扩展为BFD跟踪，提供更精细的链路检测：</p> <ul> <li>BFD能够快速检测毫秒级的链路故障</li> <li>支持检测三层可达性而非仅仅物理链路状态</li> <li>可以检测到中间设备故障导致的端到端不可达</li> </ul> <h2>6.2 链路聚合模式选择问题</h2> <h3>6.2.1 问题描述</h3> <p>在配置链路聚合时，需要在静态聚合和LACP动态聚合之间进行选择。最初选择了静态聚合，但在实际测试中发现当其中一条聚合成员链路故障时，流量切换不够快速。</p> <h3>6.2.2 原理分析</h3> <p><strong>静态聚合模式：</strong></p> <ul> <li>手工配置聚合组，不进行协议协商</li> <li>链路故障检测依赖于物理层检测</li> <li>故障切换时间相对较长（通常在秒级）</li> <li>配置简单，但灵活性较差</li> </ul> <p><strong>LACP动态聚合模式：</strong></p> <ul> <li>基于IEEE 802.3ad标准的动态协商协议</li> <li>定期发送LACP PDU检测链路状态</li> <li>能够快速检测链路故障并重新分布流量</li> <li>支持活动/备份模式和负载分担模式</li> </ul> <h3>6.2.3 解决方案</h3> <p>将聚合模式改为LACP静态模式：</p> <pre><code class=\"language-bash\">interface Eth-Trunk1 mode lacp-static</code></pre> <p>LACP静态模式的优势：</p> <ul> <li>保持手工配置的可控性</li> <li>享受LACP协议的快速检测能力</li> <li>故障切换时间缩短到亚秒级</li> <li>自动适应链路状态变化</li> </ul> <h3>6.2.4 负载分担算法优化</h3> <p>LACP支持多种哈希算法进行负载分担：</p> <pre><code class=\"language-bash\">load-balance src-dst-ip load-balance src-dst-mac load-balance dst-ip</code></pre> <p>根据流量特征选择合适的算法能够获得更好的负载均衡效果。</p> <h2>6.3 生成树收敛时间优化问题</h2> <h3>6.3.1 问题描述</h3> <p>在进行故障切换测试时，发现当核心交换机间的聚合链路出现故障时，接入交换机的端口从阻塞状态转换到转发状态需要较长时间（约30秒），影响了网络的收敛速度。</p> <h3>6.3.2 原理分析</h3> <p><strong>标准STP收敛过程：</strong></p> <ol> <li>阻塞状态（Blocking）：20秒</li> <li>监听状态（Listening）：15秒</li> <li>学习状态（Learning）：15秒</li> <li>转发状态（Forwarding）</li> </ol> <p>总收敛时间约50秒，在现代网络中难以接受。</p> <p><strong>MSTP收敛优化机制：</strong></p> <ul> <li>快速端口（Edge Port）：连接终端设备的端口直接进入转发状态</li> <li>根端口快速切换：根端口故障时快速选举新的根端口</li> <li>端口优先级调整：通过调整端口优先级影响路径选择</li> </ul> <h3>6.3.3 解决方案</h3> <p><strong>配置端口快速功能：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/1 stp edged-port enable</code></pre> <p><strong>调整端口开销值：</strong></p> <pre><code class=\"language-bash\">interface GigabitEthernet0/0/1 stp cost 2000</code></pre> <p><strong>启用BPDU保护：</strong></p> <pre><code class=\"language-bash\">stp bpdu-protection</code></pre> <h3>6.3.4 进一步优化建议</h3> <ol> <li> <p><strong>使用RSTP/MSTP替代STP</strong>：</p> <ul> <li>RSTP收敛时间可缩短到3-5秒</li> <li>MSTP支持多实例，提供更好的负载均衡</li> </ul> </li> <li> <p><strong>配置合理的端口角色</strong>：</p> <ul> <li>根据网络拓扑合理配置根交换机</li> <li>使用端口优先级和路径开销优化路径选择</li> </ul> </li> <li> <p><strong>考虑使用TRILL或SPB</strong>：</p> <ul> <li>新一代二层协议，提供更好的多路径支持</li> <li>收敛时间更短，扩展性更好</li> </ul> </li> </ol> <h2>6.4 网络安全考虑</h2> <h3>6.4.1 现有架构的安全风险</h3> <ol> <li><strong>VLAN间通信风险</strong>：当前配置允许VLAN间自由通信，存在潜在的安全风险</li> <li><strong>管理接口暴露</strong>：设备管理接口未进行访问控制</li> <li><strong>协议安全性</strong>：VRRP、LACP等协议缺乏认证机制</li> </ol> <h3>6.4.2 安全加固建议</h3> <ol> <li><strong>配置ACL进行访问控制</strong>：</li> </ol> <pre><code class=\"language-bash\">acl number 3000 rule 5 permit ip source 172.16.117.0 0.0.0.255 destination 172.16.217.0 0.0.0.255 rule 10 deny ip source any destination any</code></pre> <ol start=\"2\"> <li><strong>启用端口安全</strong>：</li> </ol> <pre><code class=\"language-bash\">interface Ethernet0/0/1 port-security enable port-security max-mac-num 1</code></pre> <ol start=\"3\"> <li><strong>配置DHCP Snooping</strong>：</li> </ol> <pre><code class=\"language-bash\">dhcp snooping enable interface Ethernet0/0/1 dhcp snooping trusted</code></pre> <p>通过以上问题分析和解决方案讨论，不仅解决了实验中遇到的具体技术问题，也深入思考了网络设计的安全性、可靠性和可扩展性，为今后的网络工程实践奠定了坚实基础。</p> <hr /> <p><strong>报告总结：</strong></p> <p>本次双核心双出口网络设计与实现实验圆满完成了所有预定目标。通过理论学习、实际配置和功能验证，深入掌握了企业级网络架构设计的核心技术和实现方法。实验过程中遇到的问题和解决方案为今后的网络工程实践提供了宝贵经验。整个网络架构具备良好的可用性、可扩展性和维护性，能够满足中小型企业的网络需求。</p>",
    "publishDate": "2025-06-23T16:00:40.000Z",
    "modifiedDate": "2025-07-14T11:28:10.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 102,
        "name": "作业",
        "slug": "%e4%bd%9c%e4%b8%9a",
        "count": 1
      }
    ],
    "tags": [],
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2025/06/network_design/",
    "wordCount": 3098,
    "readingTime": 16,
    "seo": {
      "title": "双核心双出口网络设计与实现",
      "description": "<p>一、设计目的 本次网络工程实践大作业旨在设计并实现一个企业级双核心双出口网络架构，通过理论学习与实践操作相结合 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2025/06/network_design/"
    }
  },
  {
    "id": "492",
    "title": "百度Apollo星火自动驾驶大赛经验分享",
    "slug": "apollo_experience_sharing",
    "excerpt": "<p>以下内容来自“2025年 百度 Apollo 星火自动驾驶技术培训 &#8211; 武汉” 参赛经验分享 本人 [&hellip;]</p>",
    "content": "<blockquote> <p>以下内容来自“2025年 百度 Apollo 星火自动驾驶技术培训 &#8211; 武汉” 参赛经验分享 本人发言稿</p> </blockquote> <p>各位老师、同学，大家下午好！</p> <p><strong>今年是我参加百度Apollo星火自动驾驶大赛的第三年了。</strong>我从2023年参加第二十五届开始，拿到了全国二等奖；2024年参加第二十六届非常幸运地获得了全国一等奖。<strong>从大一一个人懵懵懂懂地摸索，到现在对Apollo这套复杂的系统逐渐熟悉，这个过程充满了挑战，但也收获巨大。</strong> 我相信在座的同学里，肯定也有不少人是像我当初一样，一个人在战斗。所以今天，我想把自己这三年，<strong>摸索出来的一些最核心、最实用的经验</strong>分享给大家，希望能帮大家少走点弯路。</p> <hr /> <h2>第一点：官方资料用起来</h2> <ul> <li><strong>不要小看官方文档和视频！</strong> 我知道很多同学一上来就想直接上手改代码、跑仿真。Apollo官网提供的那些资料，绝对是你快速入门、避免在基础问题上卡壳的最强武器！**</li> <li><strong>从系统安装、环境配置，到模块原理解析、传感器标定，再到每一届的赛题详解和代码实操指南，官方都提供了非常系统、详细的视频和文档。</strong>在我第一届参赛的时候，基本上把整个Apollo官网翻完，才把系统装好，这也奠定了我现在对于系统安装的熟练度基础。</li> <li><strong>熟读这些文档，能让你在最短时间内对整个Apollo系统的架构、核心模块（感知、预测、规划、控制）的作用、以及比赛的基本流程有一个全局性的、清晰的了解。</strong> 这就像是拿到了一张地图，让你知道自己在整个“自动驾驶世界”中的位置，下一步该往哪走。<strong>强烈建议大家，尤其是新手，在动手写第一行代码之前，先把相关的官方文档和视频过一遍，打好基础，事半功倍！</strong></li> </ul> <hr /> <h2>第二点： 源代码得“啃”起来</h2> <ul> <li><strong>官方文档很棒，但它更像是一个“说明书”，告诉你“是什么”和“怎么用”。</strong> 当你真正想优化算法、解决具体场景下的棘手问题，或者想理解某个参数为什么这样设置时，<strong>文档往往就不够用了。</strong></li> <li><strong>这时候，就得硬着头皮去“啃”源代码了！</strong> 这听起来有点吓人，Apollo的代码量确实很大，全部加起来有八十万行。但别慌，<strong>不需要你一下子看完所有代码。</strong></li> <li><strong>我的方法是：带着具体问题去看代码。</strong> 比如： <ul> <li><strong>为什么在 <code>LANE_FOLLOW</code> (车道跟随) 场景下，车辆在弯道的轨迹不够平滑？</strong> 那就深入这个场景对应的规划逻辑，重点关注负责生成路径的 <code>PATH_BOUND_DECIDER</code>、<code>LANE_BORROW</code>（如果涉及借道）、以及关键的优化器 <code>PIECEWISE_JERK_PATH_OPTIMIZER</code> 等任务，看看它们处理参考线、边界和优化目标的代码细节。</li> <li>想调整控制（Control）模块的响应速度？那就要找到控制器的参数配置文件，并理解这些参数在代码里是如何被使用的。</li> </ul> </li> <li><strong>通过聚焦于特定场景和具体任务去阅读代码，你能清晰地看到：</strong> <ul> <li>某个场景下，<strong>激活了哪些关键的任务</strong>，它们的执行顺序是怎样的？</li> <li>某个具体的任务内部，<strong>数据是如何流动和处理的</strong>（输入是什么？做了哪些计算或决策？输出是什么？）？</li> <li>影响决策和轨迹生成的<strong>关键参数在哪里定义</strong>（可能在配置文件如 <code>*.pb.txt</code> 中，也可能在代码里硬编码），<strong>它们是如何被使用的</strong>？</li> </ul> </li> <li><strong>这样“有的放矢”地啃Planning源码，效率会高很多。</strong> 虽然一开始还是会觉得复杂，但坚持下去，你会对Apollo规划决策的“黑盒子”内部运作机制有飞跃性的理解。这不仅能帮你精准定位问题、有效调参，甚至能让你有能力去修改或定制任务逻辑来应对更复杂的比赛场景！<strong>“啃源码”是让你从“会跑Demo”迈向“真正理解并掌握Planning精髓”的关键一步！</strong></li> </ul> <hr /> <h2>第三点：动手实践做起来</h2> <ul> <li><strong>前面两点是基础，但最重要、最核心的一点来了：一定要动手！拼命动手！</strong> 自动驾驶，尤其是比赛，<strong>实践性超乎想象地强！</strong></li> <li><strong>我踩过最大的坑就是：</strong> 觉得自己看懂了文档，理解了某个算法的思想，或者想出了一个绝妙的优化点子，就以为在仿真环境里一定能跑出好结果。<strong>现实往往很骨感！</strong> 理论懂了，思路有了，不等于仿真环境里的车就能顺利开好。</li> <li><strong>为什么？</strong> 因为仿真环境模拟的是复杂的、动态的真实世界。你的代码、你的参数调整，会和各种传感器噪声、环境干扰、其他交通参与者的不确定行为发生交互。很多问题，比如幽灵刹车、决策犹豫、轨迹抖动、路口卡死，<strong>只有在你实际运行、观察日志、分析数据的时候才会暴露出来。</strong></li> <li><strong>所以，我的血泪教训就是：</strong> <ul> <li><strong>勤动手：</strong> 多去仿真环境里跑！各种场景都要反复跑。</li> <li><strong>多观察：</strong> 不仅要看车跑得顺不顺，更要<strong>仔细看 Dreamview 可视化界面</strong>，看预测轨迹合不合理、规划路径稳不稳。更要<strong>死磕日志文件</strong>！日志里藏着问题发生的所有线索（报错、警告、关键变量值的变化）。</li> <li><strong>多分析：</strong> 根据观察到的现象和日志信息，分析问题到底出在哪个环节？是预测误判了？规划路径碰撞了？还是参数太激进了？</li> <li><strong>不断调试优化：</strong> 基于分析，有针对性地去修改代码或调整参数，然后<strong>立刻再跑仿真验证效果</strong>。这个过程是循环往复的，可能一个小问题就需要调试几十次，几十个小时。</li> </ul> </li> <li><strong>纸上得来终觉浅，绝知此事要躬行。</strong> 在Apollo星火大赛里，<strong>没有足够多的仿真里程积累，没有经历过无数次“跑崩-&gt;分析-&gt;修改-&gt;再跑”的循环，是很难拿到好成绩的。</strong> 动手实践，是连接理论知识和比赛成绩的唯一桥梁！</li> </ul> <hr /> <p><strong>总结一下：</strong></p> <ol> <li><strong>用好资料打基础。</strong></li> <li><strong>深入代码求理解。</strong></li> <li><strong>勤于实践来优化。</strong> </li> </ol> <p>这就是我这三年参赛下来，觉得最重要的三点经验。当然，比赛过程中肯定还会遇到各种预料之外的挑战，团队协作、时间管理这些也很关键。但把这三点基础打扎实了，我觉得就能有个不错的起点。</p> <p>最后，我想说，参加这个比赛真的收获很大，不仅是技术上的成长，也认识了很多志同道合的朋友。希望我的这点经验能给大家带来一些启发。祝大家在今年的比赛中都能取得理想的成绩！<strong>敢想敢做，代码里跑出未来！</strong> 谢谢大家！</p>",
    "publishDate": "2025-06-21T05:00:12.000Z",
    "modifiedDate": "2025-07-14T09:37:03.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 101,
        "name": "经验分享",
        "slug": "%e7%bb%8f%e9%aa%8c%e5%88%86%e4%ba%ab",
        "count": 1
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 493,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训.png",
      "alt": "",
      "title": "百度Apollo星火自动驾驶技术培训",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训-300x159.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"159\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训-300x159.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训-300x159.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2025/07/百度Apollo星火自动驾驶技术培训.png"
      },
      "width": 582,
      "height": 308,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2025/06/apollo_experience_sharing/",
    "wordCount": 99,
    "readingTime": 1,
    "seo": {
      "title": "百度Apollo星火自动驾驶大赛经验分享",
      "description": "<p>以下内容来自“2025年 百度 Apollo 星火自动驾驶技术培训 &#8211; 武汉” 参赛经验分享 本人 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2025/06/apollo_experience_sharing/"
    }
  },
  {
    "id": "453",
    "title": "百度 Apollo 自动驾驶平台译解报告",
    "slug": "baidu-apollo",
    "excerpt": "<p>GPT-Academic Report planners lattice lattice_planner.h [&hellip;]</p>",
    "content": "<h1>GPT-Academic Report</h1> <h2>planners</h2> <h3>lattice</h3> <h4>lattice_planner.h</h4> <p>这个文件是计划模块中的组成部分，属于apollo自动驾驶系统的一部分，定义了一个“LatticePlanner”类，它是一个采用了格的路径计划器(lattice planner)，用于生成车辆的驾驶轨迹。这个路径规划器基于引用线(ReferenceLine)。</p> <p>LatticePlanner类继承自PlannerWithReferenceLine类，其中包含的方法有：</p> <ol> <li><code>Name()</code>，返回路径规划器的名称。</li> <li><code>Init()</code>，用于初始化路径规划器，其中包含一个DependencyInjector对象和一个配置路径。 返回类型为common::Status, 表明初始化的状态。</li> <li><code>Stop()</code>，停止路径规划器。</li> <li><code>Plan()</code>，一个重载函数，根据当前的planning frame计划一条从指定的初始trajectory point开始的轨迹。 返回类型为common::Status, 表明规划的状态。</li> <li><code>PlanOnReferenceLine()</code>，另一种Plan函数的重载。它根据给定的初始轨迹点和参考线的信息，在当前的规划框架下计划一条轨迹。方法返回了一个common::Status类型的值，代表计划的状态。</li> </ol> <p>该文件在最底部使用了CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏，用于在运行时注册和创建LatticePlanner插件。</p> <h4>behavior</h4> <h5>collision_checker.h</h5> <p>这段代码是源自Apollo项目中的一部分，是一个名为&quot;CollisionChecker&quot;的类定义，它在规划模块下的lattice行为（Euclidean lattice behavior）中部分代码。</p> <p>这个&quot;CollisionChecker&quot;类的主要目的是在设定的场景和属于自动驾驶车辆的轨迹之间进行碰撞检查。它具有创建预测环境的功能，并检查自动驾驶车辆与行驶路径的关系，比如自动驾驶车辆是否在行驶道内，是否有其他障碍物在自动驾驶车辆后部。</p> <p>这个类包括以下重要方法：</p> <ol> <li> <p>&quot;CollisionChecker&quot;的构造函数：这个构造函数需要输入障碍物的列表，自我车辆的s和d（即车道线上的位置和车道线的横向偏移），离散参考线，参考线信息的指针以及路径时间图的指针。</p> </li> <li> <p>&quot;InCollision&quot;：该方法输入离散化轨迹，根据预测环境和自车行驶轨迹，判断是否会发生碰撞。</p> </li> <li> <p>&quot;BuildPredictedEnvironment&quot;：该方法用于基于输入的障碍物列表、自我车辆的s和d以及离散的参考线来创建预测环境。</p> </li> <li> <p>&quot;IsEgoVehicleInLane&quot;：检查自我车辆是否在行驶道内。</p> </li> <li> <p>&quot;IsObstacleBehindEgoVehicle&quot;：检查是否有障碍物在自我车辆后部。</p> </li> </ol> <h5>feasible_region.h</h5> <p>这个文件是Apollo自动驾驶系统中的一部分，名为&quot;feasible_region.h&quot;。它定义了一个名为<code>FeasibleRegion</code>的类，这个类处理与可行区域相关的计算。</p> <p>FeasibleRegion类有五个公有方法，分别用于计算给定时间点的上下边界的S值和V值，以及给定S值的下边界T值。其中，S通常表示距离，V表示速度，T表示时间。这些方法都是const函数，说明它们不会修改对象的状态。</p> <p>FeasibleRegion类有三个私有的数据成员，包含了一个初始化的S值数组（包含距离、速度和加速度），以及在零速度处的时间t和对应的距离s。</p> <p>需要注意的是，这个文件只提供类的声明，并没有提供具体的方法实现，这些实现应该在对应的<code>.cpp</code>文件中。</p> <h5>path_time_graph.h</h5> <p>这是一个定义在Apollo自动驾驶系统的路径时间图的头文件。路径时间图是一个在车辆的规划过程中使用的工具，可以用于确定车辆在给定时间和路径条件下的最优行为。</p> <p>如果具体看一下这个头文件，它包含一个名为PathTimeGraph的类，有一些数据成员和方法。</p> <p>主要的数据成员有：</p> <ul> <li>&quot;time<em>range</em>&quot; 和 &quot;path<em>range</em>&quot;（时间范围和路径范围）；</li> <li>&quot;ptr_reference_line<em>info</em>&quot; 为引用线信息的指针；</li> <li>&quot;init<em>d</em>&quot; 为一个固定大小的数组，可能用于存储车辆的初始状态；</li> <li>&quot;path_time_obstacle<em>map</em>&quot; 为一个以障碍物ID映射其在ST空间中的边界的哈希表；</li> <li>&quot;path_time<em>obstacles</em>&quot; 为所有障碍物的ST边界的列表；</li> <li>&quot;static_obs_sl<em>boundaries</em>&quot; 为所有静态障碍物的SL边界的列表。</li> </ul> <p>主要的方法包括：设置障碍物，获取路径时间障碍物，获取路径阻挡间隔，获取横向范围，计算障碍物边界等等。这些方法的主要目标是处理或获取有关障碍物的信息。</p> <p>该路径时间图类的设计主要用于处理路径和时间决策这两个关键变量，以及如何将它们与障碍物信息结合在一起来决定车辆的最优运动。</p> <h5>prediction_querier.h</h5> <p>这是Apollo项目的一部分，具体来说，它是其路径规划部分中的一部分。本文件定义的类为&quot;PredictionQuerier&quot;。此类在进行自动驾驶车辆的路径规划时，用来查询预测的障碍物信息。</p> <p>主要的类和函数包括：</p> <ol> <li>PredictionQuerier类： <ul> <li>构造函数 <code>PredictionQuerier</code>：需要障碍物数组和引用线路的智能指针作为输入。</li> <li>析构函数 <code>~PredictionQuerier</code>：是一个虚析构函数。</li> <li>函数 <code>GetObstacles</code>：返回当前的障碍物列表。</li> <li>函数 <code>ProjectVelocityAlongReferenceLine</code>：沿预测线路参考的路径投影障碍物的速度。</li> </ul> </li> </ol> <p>私有成员变量包括:</p> <ul> <li><code>id_obstacle_map_</code> ：以障碍物ID为键的映射，用于快速查询障碍物。</li> <li><code>obstacles_</code>：当前障碍物列表。</li> <li><code>ptr_reference_line_</code>：当前参考线路的智能指针。</li> </ul> <p>备注：此文件是开源的，遵循Apache 2.0许可协议。</p> <h4>trajectory_generation</h4> <h5>backup_trajectory_generator.h</h5> <p>这个文件是Apollo自动驾驶系统中的一部分，具体是在规划模块的子模块-晶格轨迹生成器中的备份轨迹生成器。</p> <p>它主要包括一个类&quot;BackupTrajectoryGenerator&quot;，该类有多个公共和私有数据成员和方法。公共方法包括构造函数和&quot;GenerateTrajectory&quot;方法，它们被用来生成相对于参考路径点的轨迹。</p> <p>私有部分定义了一种用于生成1d轨迹对的方法，一个初始相对时间的双精度变量，一个用于碰撞检测的共享智能指针，一个指向1d轨迹生成器的指针，以及一个优先级队列用于存储1d轨迹对。</p> <p>此外，还定义了一个名为&quot;CostComparator&quot;的结构，它用于比较两个1D轨迹对在特定时间长度下的评估值。</p> <h5>end_condition_sampler.h</h5> <p>这个文件是Apollo自动驾驶项目中的一部分，位于&quot;./planners/lattice/trajectory_generation&quot;路径下。它被称为<code>EndConditionSampler</code>，这是一个定义了一些方法用于采样不同的末状态条件的类。</p> <p>其中类的公开方法主要有：</p> <ul> <li><code>SampleLatEndConditions()</code>: 用于采样横向的末状态</li> <li><code>SampleLonEndConditionsForCruising()</code>: 用于在巡航情况下采样纵向的末状态</li> <li><code>SampleLonEndConditionsForStopping()</code>: 用于在停止情况下采样纵向的末状态</li> <li><code>SampleLonEndConditionsForPathTimePoints()</code>: 用于在路径时间点情况下采样纵向的末状态</li> </ul> <p>和一些内部私有方法如<code>QueryFollowPathTimePoints()</code>，<code>QueryOvertakePathTimePoints()</code> 和 <code>QueryPathTimeObstacleSamplePoints()</code> 用于获取不同场景下的采样点。</p> <p>此外，它包含一些私有成员变量用于存储车辆的初始和可能的移动状态、可行域以及预测查询。</p> <p>可以看出，此类的主要任务是在给定特定场景和初始条件下，产生纵向和横向的采样末状态，供后续的路径规划和决策使用。</p> <h5>lateral_osqp_optimizer.h</h5> <p>这个文件是Apollo自动驾驶项目中的一部分，名为<code>lateral_osqp_optimizer.h</code>，它是用于定义一个名为<code>LateralOSQPOptimizer</code>的类，该类是<code>LateralQPOptimizer</code>的子类。</p> <p><code>LateralOSQPOptimizer</code>类关注于优化车辆横向运动轨迹的问题。类中定义了一个公有函数<code>optimize</code>，此函数接收车辆当前的状态，一个预测值，以及边界条件为输入参数，并返回一个布尔值标识优化过程是否成功。</p> <p>另外，类中还定义了一个私有函数<code>CalculateKernel</code>，此函数接收边界条件和三个用于存储计算结果的向量，并没有返回值。这个函数似乎负责计算优化问题的核心部分。</p> <p>这个文件还包括了一些头文件，包括 &quot;osqp/osqp.h&quot;，&quot;./planners/lattice/trajectory_generation/lateral_qp_optimizer.h&quot;，和&quot;./planning_base/common/trajectory1d/piecewise_jerk_trajectory1d.h&quot;。</p> <p>文件头部的注释说明，此文件是在阿帕奇协议2.0许可下发布的。</p> <h5>lateral_qp_optimizer.h</h5> <p>这个文件是一个名为 &quot;LateralQPOptimizer&quot; 的C++头文件&quot;lateral_qp_optimizer.h&quot;，文件位于 &quot;./planners/lattice/trajectory_generation&quot; 文件夹下，表明它在路径规划模块的轨迹生成子模块中。</p> <p>这个头文件包括一个名为LateralQPOptimizer的抽象类(class)，看起来是和车辆的横向（lateral）优化有关。它定义了一些基本的公开函数（public functions）如 <code>optimize</code>，和返回最优轨迹的 <code>GetOptimalTrajectory</code>，返回弗雷内特坐标系统下的路径的 <code>GetFrenetFramePath</code>等。</p> <p>在保护部分(protected)提供了一些成员变量，例如 &#8216;delta<em>s</em>&#8216;, &#8216;opt<em>d</em>&#8216;, &#8216;opt_d<em>prime</em>&#8216; 和 &#8216;opt_d<em>pprime</em>&#8216;。这些变量可能用来内部计算和数据存储。</p> <p>此文件属于Apollo自动驾驶项目，根据其文件头，它使用Apache 2.0许可证。</p> <h5>lattice_trajectory1d.h</h5> <p>这个文件是Apollo自动驾驶系统的planning模块的一部分，特别是在lattice路径规划的轨迹生成部分。代码中定义了一个叫做LatticeTrajectory1d的类，这个类继承了Curve1d类。</p> <p>LatticeTrajectory1d类内含有一个Curve1d的智能指针，和目标位置、目标速度、目标时间的变量，配合是否已经设定这些目标值的布尔标志。同时，定义了一些公有方法，包括获取或设置目标位置、速度和时间等。</p> <p>此外，该类还覆写了基类Curve1d的一些虚函数，如Evaluate，ParamLength和ToString等。</p> <p>总的来说，这个类主要是为了生成1D的格子轨迹，且可以对轨迹的各种参数进行设定和计算。</p> <h5>piecewise_braking_trajectory_generator.h</h5> <p>这是一个名为 &quot;PiecewiseBrakingTrajectoryGenerator&quot; 的C++头文件，位于一个项目的&quot;./planners/lattice/trajectory_generation&quot;目录下。它是 Apollo 自动驾驶系统中的一部分，负责生成在特定情况下的刹车轨迹。</p> <p>它定义了一个全局静态类，由于其构造函数已被删除，因此不能创建此类的实例。代替的是，它提供了一些静态成员函数以在不创建对象的情况下直接使用。</p> <p>该类中含有四个公开的静态方法：</p> <ol> <li>&quot;Generate&quot;方法：返回一个一维曲线对象(<code>std::shared_ptr&lt;Curve1d&gt;</code>)，它表示在指定的目标位置，当前位置，目标速度，当前速度，舒适的加速度和制动力以及最大时间下的刹车轨迹。</li> <li>&quot;ComputeStopDistance&quot;方法：在给定速度和减速度的情况下计算停止距离。</li> <li>&quot;ComputeStopDeceleration&quot;方法：在给定距离和速度的情况下计算停止减速度。</li> </ol> <p>此文件是开源的，遵循Apache License 2.0。</p> <h5>trajectory1d_generator.h</h5> <p>这个文件是 Apollo 开源自动驾驶项目的一部分，并且定义了一个关键的类 <code>Trajectory1dGenerator</code>。</p> <p><code>Trajectory1dGenerator</code> 类是处理 1 维轨迹生成的类。这个类主要用于生成一系列的固定维度（纬度/经度）的轨迹组合集。其决定了车辆在驶入障碍物、在行驶或者在停车时的行为。</p> <p>类的构造函数接收一个车辆的经度和纬度初始状态以及一个预测查询器和一个时间路径图的智能指针。</p> <p>类方法主要包括轨迹生成。比如<code>GenerateTrajectory1DBundle</code> 是个模板方法，负责一维轨迹的生成，并以四次和五次多项式曲线来表示这些轨迹。</p> <p>此外，还有一些用于生成特定场景下的轨迹的方法，比如生成行车轨迹(<code>GenerateSpeedProfilesForCruising</code>)，生成停车轨迹(<code>GenerateSpeedProfilesForStopping</code>)，生成绕过障碍物的轨迹(<code>GenerateSpeedProfilesForPathTimeObstacles</code>)等。</p> <h5>trajectory_combiner.h</h5> <p>此文件是Apollo项目的一部分，Apollo是一款开源的汽车自动驾驶系统。具体来说，这个文件属于规划模块的子模块中的一部分，它负责处理轨迹生成的工作。</p> <p>轨迹生成模块（trajectory_generation）是规划模块的重要部分，负责生产车辆的优化路径。这个文件定义了一个名为“TrajectoryCombiner”的类，此类有一个名为“Combine”的静态函数。这个函数采用三个参数，分别表示参考线（reference_line），纵向轨迹（lon_trajectory）和横向轨迹（lat_trajectory），以及一个初始相对时间的参数。然后，该函数将这些参数结合以生成一个离散化的轨迹（DiscretizedTrajectory）。</p> <h5>trajectory_evaluator.h</h5> <p>这个文件是属于 Apollo 自动驾驶系统的一部分，特别是其规划子系统中。这个文件定义了一个名为 TrajectoryEvaluator 的类，该类是用于评估和选择最优路径的工具。它基于输入的初始状态、目标、纵向和横向轨迹、路径时间图和参考线来进行评估。</p> <p>在类的构造函数中，所有这些输入数据会被初始化，并在评估过程中使用。然后，类提供了一些公共方法，这些方法可用于确定是否有更多的轨迹对，获取轨迹对的数量，获取顶部轨迹对和其成本。</p> <p>此外，私有方法被用于在单个纵向或横向轨迹上评估不同的成本，例如偏差、舒适度、碰撞、对象等。最后，一个结构类型 CostComparator 用于在选定最优路径时进行成本比较，并将结果存储在一个优先级队列 cost<em>queue</em> 中。而这个队列会根据成本从低到高来排序轨迹对。</p> <h3>navi</h3> <h4>navi_planner.h</h4> <p>这个程序文件是一个导航规划器(NaviPlanner)的声明文件，命名空间为 apollo::planning。导航规划器是一个基于实时相对地图的规划器，它使用车辆的前左上(FLU)坐标系统来完成例如巡航，跟随，超车，微调，改变车道和停车等任务。</p> <p>导航规划器类继承自PlannerWithReferenceLine父类，这是一个带参考线信息的规划器。NaviPlanner包含公有的 <code>Init</code> ，<code>Plan</code> 和 <code>Stop</code> 方法，还有额外的重载 <code>PlanOnReferenceLine</code> 方法。它具备一些私有成员函数，包括 RegisterTasks(), GenerateInitSpeedProfile(), DummyHotStart(), GenerateSpeedHotStart(), GenerateFallbackPathProfile(), GenerateFallbackSpeedProfile(), GenerateStopProfile(), GenerateStopProfileFromPolynomial(), IsValidProfile(), RecordObstacleDebugInfo() 和 RecordDebugInfo()。</p> <p>这个文件也定义了 NAVI 任务类型和任务工厂，并声明了插件管理器的注册插件，并将 NaviPlanner 添加到 Planner 插件中。</p> <p>请注意，NaviPlanner 只在导航模式中使用(通过将 &quot;FLAGS_use_navigation_mode&quot; 设置为 &quot;true&quot; 来打开导航模式)，而在标准模式中不使用它。</p> <h4>decider</h4> <h5>navi_obstacle_decider.h</h5> <p>这是一个名为&quot;NaviObstacleDecider&quot;的类的声明文件，它是一个在导航模式下为车辆周围的障碍物做出适当决策的类。这个文件是Apollo自动驾驶软件包的一部分，属于规划模块。</p> <p>&quot;NaviObstacleDecider&quot;类包含的几个主要方法包括：</p> <ul> <li>&quot;Init&quot;: 初始参数设置。</li> <li>&quot;GetNudgeDistance&quot;: 获取根据障碍物的位置得到的实际可微调距离。</li> <li>&quot;GetUnsafeObstaclesInfo&quot;: 获取路径和参考线之间的不安全障碍物的信息。</li> <li>&quot;ProcessObstacle&quot;: 处理路径遇到的障碍信息。</li> </ul> <p>该文件还包含一些私有成员变量，如&quot;last_nudge<em>dist</em>&quot;来记录最后一次调整距离，&quot;obstacle_lat<em>dist</em>&quot; 存储障碍物侧向距离等。</p> <p>这个类是如何进行障碍物决策的关键，它处理车辆面临的障碍物，并决定进行柔和的调整（nudge）或是限制速度等其他的行动。注意这个类仅在导航模式下使用，不会在标准模式下使用。</p> <h5>navi_path_decider.h</h5> <p>这段代码是Apollo自动驾驶系统中的一部分，名为&quot;NaviPathDecider.h&quot;。这是一个头文件，定义了一个名为&quot;NaviPathDecider&quot;的类。NaviPathDecider类主要用于在导航模式下生成车辆的本地驾驶路径。</p> <p>NaviPathDecider类继承自NaviTask类。该类有以下主要公共方法：</p> <ul> <li>Init：用于初始化配置信息。</li> <li>Execute：生成导航路径。输入参数为当前规划框架和参考线信息，返回包含路径信息的状态对象。</li> </ul> <p>除此之外，NaviPathDecider类还包含几个私有方法，例如处理生成路径信息，计算拐向目标车道的安全性，确定保持在车道中的侧向偏移等。</p> <p>该类还包含若干私有成员变量，用于保存车道保持距离、车道偏移、速度等级等的配置信息。还包括用于记录开始规划点的速度和加速度的变量，以及目前参考线的车道ID等。</p> <h5>navi_speed_decider.h</h5> <p>这是一个源自 Apollo 自动驾驶项目的 C++ 头文件，定义了一个名为 &quot;NaviSpeedDecider&quot; 的类。这个类似乎是为了在自动驾驶的导航模式下，生成一个合适的车辆运行速度曲线。</p> <p>&quot;NaviSpeedDecider&quot; 类是 &quot;NaviTask&quot; 类的子类。它拥有一个公共的构造器和析构器，以及一个 Init 方法来初始化该类。此外，它还有一个&quot;Execute&quot;方法，可能用于执行特定的速度决策任务。</p> <p>在类的私有成员中，包括一系列的方法和属性，这些方法主要用于根据不同的场景（例如，基于感知范围、基于障碍物、基于交通决策、基于向心加速度和基于配置信息）添加时间-速度(t-s)约束。私有属性包括车辆的首选速度、最大速度、首选加速度、首选减速度、首选急动度、最大加速度、最大减速度等。</p> <p>这个类还包含了一些针对单元测试的友元测试类。</p> <h5>navi_speed_ts_graph.h</h5> <p>这个文件是 Apollo 开源自动驾驶系统中的一部分，特别是在 planning 模块的 navi 子模块中。该文件主要定义了 &quot;NaviSpeedTsGraph&quot; 类，该类用于生成具有一些限制和偏好的 t-s（时间-速度）图。它包括设定图形参数、更新点的约束条件（如速度、加速度上下限等）、处理遇到障碍物情况时的约束条件以及最终解决生成图形的方法。</p> <p>&quot;NaviSpeedTsConstraints&quot; 结构体用于描述一个 t-s 点的约束条件，包括时间戳的最小值，点的最大速度、喜好速度，最大加速度、喜好加速度，以及最大减速和喜好减速等。&quot;NaviSpeedTsPoint&quot; 结构体则是用来描述一个具体的 t-s 点，包含其位移、时间、速度、加速度的数值。</p> <p>整个文件遵守 Apache License 2.0 开源协议。</p> <h5>navi_task.h</h5> <p>这个文件是Apollo自动驾驶系统中的一部分，名为&quot;navi_task.h&quot;。它定义了一个&quot;NaviTask&quot;类，这个类可能负责完成在导航(planning)模块中的一项特定任务。</p> <p>&quot;NaviTask&quot;类具有以下重要的成员函数和成员变量：</p> <ul> <li>构造函数：用于创建一个新的&quot;NaviTask&quot;实例，需要一个字符串类型的任务名参数。</li> <li>析构函数：它是虚析构函数，允许子类能进行正确的清理。</li> <li>Name()：返回任务对象的名称。</li> <li>Init()：用给定的配置初始化任务。</li> <li>Execute()：执行任务。这是一个虚函数，所以具体的执行方式将由&quot;NaviTask&quot;的子类决定。</li> <li>is<em>init</em>、frame_和reference_line_info_都是保护的成员变量，这意味着它们只能被&quot;NaviTask&quot;类或其子类访问。</li> <li>name_ 是一个私有变量，存储了任务的名称。</li> </ul> <p>此类可能是导航（Planning）模块中，任务处理或者解析的基类。</p> <h3>public_road</h3> <h4>public_road_planner.h</h4> <p>这是一个名为&quot;PublicRoadPlanner&quot;的类的头文件，该类是Apollo自动驾驶框架中的一部分，用于公路规划。这个类继承自&quot;PlannerWithReferenceLine&quot;类。</p> <p>主要功能包括：</p> <ol> <li>&quot;Init&quot;函数，初始化规划器，接受一个依赖注入器和一个配置路径。</li> <li>&quot;Plan&quot;函数，主要的规划函数，接受初始的轨迹点和当前的帧来进行规划。</li> <li>&quot;Reset&quot;函数，接受一个帧然后重置场景管理器。</li> <li>&quot;Name&quot;函数，返回规划器的名称。</li> <li>&quot;Stop&quot;函数，现在为空实现。</li> </ol> <p>此外，还包含以下私有成员：<br /> 1.一个场景管理器对象&quot;scenario<em>manager</em>&quot;，<br /> 2.一个配置对象&quot;config<em>&quot;，<br /> 3.一个&quot;scenario</em>&quot;指针。</p> <p>该头文件包含了一些其他模块的头文件以及对PublicRoadPlanner类的详细声明。这个类在Apollo自动驾驶框架的规划模块中充当一个重要角色，负责对公路进行规划。最后，PublicRoadPlanner类已经注册为一个插件。</p> <h4>scenario_manager.h</h4> <p>该文件是Apollo自动驾驶系统的一部分，具体位于路径&#8217;./planners/public_road/&#8217;下，名为&#8217;scenario_manager.h&#8217;。这个头文件定义了一个名为ScenarioManager的类，它主要对公共道路规划的各种驾驶情景进行管理。</p> <p>在类定义中，首先定义了一些与情景和依赖注入有关的成员变量，然后定义了一些公有和私有方法。公有方法包括Init方法进行初始化，mutable_scenario方法获取当前情景，injector方法获取注入器等。Private方法则暂时未有明确展示。</p> <p>这个头文件还包括了一些include语句引入了必要的依赖，如计划配置相关的头文件、基础消息相关的头文件等。</p> <p>总的来说，这个文件主要是为了实现公共道路规划的各种驾驶情景的管理，支持情景的初始化，更新，获取，重置等操作。</p> <h3>rtk</h3> <h4>rtk_replay_planner.h</h4> <p>该文件 <code>rtk_replay_planner.h</code> 是含有 RTKReplayPlanner 类的头文件，这个类是 PlannerWithReferenceLine 类的子类。它的目标是从轨迹文件中读取预先记录的车辆轨迹，然后根据车辆的当前位置输出轨迹的适当段落。</p> <p>这个类有以下重要方法：</p> <ul> <li><code>Init</code>: 用于初始化 Planner，这包括读取配置和依赖注入。</li> <li><code>Stop</code>: 这是一个停止方法，但现在它是一个空的方法。</li> <li><code>Plan</code> : 这是一个覆盖了父类 Planner 的方法，是规划算法的核心部分，输入参数是计划开始的轨迹点和当前规划的帧，返回值是规划器的状态。</li> <li><code>PlanOnReferenceLine</code>: 类似于 Plan 方法，但也包含了参考线信息作为输入参数。</li> <li><code>ReadTrajectoryFile</code>: 从一个文件中读取预先记录的轨迹，输入参数是文件名。</li> <li><code>QueryPositionMatchedPoint</code>: 这是一个私有方法，用于在给定的轨迹中寻找与开始点最匹配的点。</li> </ul> <p>此外，该类还包含一个 <code>complete_rtk_trajectory_</code> 私有成员，用于存储预先记录的完整 RTK 轨迹。</p> <h2>planning_base</h2> <h3>common</h3> <h4>sl_polygon.h</h4> <p>代码文件位于<code>./planning_base/common/</code>路径下，名为<code>sl_polygon.h</code>，这是一个头文件，定义了<code>SLPolygon</code>类。</p> <p>该类的主要目的是定义和操作一个在<code>s</code>和<code>l</code>坐标系中的多边形（可能用于车辆的路径规划）。代码中使用了<code>SLPoint</code>，它是一个包含两个值（<code>s</code>和<code>l</code>）的数据结构，可能代表一种在车道坐标系中表示位置的方法，其中<code>s</code>是沿车道中心线的距离，<code>l</code>是相对于车道中心线的横向位置。</p> <p><code>SLPolygon</code>有一些公共方法，可以获取最小、最大的S、L点，还能获取多边形的左、右边界等内容。还定义了一个叫<code>NudgeType</code>的枚举类型，可能代表某种对多边形位置的调整类型。同时，该类包含私有成员变量（如左右边界向量、最小/最大SL点向量等）以存储多边形的数据。</p> <p>在<code>SLPolygon</code>类中，大部分公共方法是信息查询方法，还有一些是用于修改该类中存储的信息。此外，这个类还包含打印信息的方法，这在调试和记录程序行为时可能非常有用。</p> <h4>dependency_injector.h</h4> <p>该源代码文件是Apollo自动驾驶系统的一部分，位于<code>./planning_base/common/</code>的路径下。文件主要定义了一个名为<code>DependencyInjector</code>的类。这个类被用作依赖注入，是一个通用的设计模式，依赖注入可以使系统组件保持松散耦合，同时保持高度模块化，从而增强代码的可重用性和可测试性。</p> <p>这个类中定义了一系列成员变量，如<code>PlanningContext</code>， <code>FrameHistory</code>， <code>History</code>， <code>EgoInfo</code>， <code>VehicleStateProvider</code> 和 <code>LearningBasedData</code>，并为每个成员变量设立了返回当前实例的getter方法。</p> <p>整体来看，<code>DependencyInjector</code>类定义了各种联合工作的组件，并提供集中的访问点，以把它们注入到需要这些组件的代码中。 值得注意的是，所有的数据和对象都是封装在这个类中，而不存在于全局空间。</p> <h4>path_decision.h</h4> <p>这是一个名为&quot;path_decision.h&quot;的头文件，属于<code>./planning_base/common</code>的路径决策模块。它在Apollo自动驾驶系统中被用作路径决策的组成部分。</p> <ul> <li> <p>首先，包含了一些必要的库和头文件，如索引列表(indexed_list.h)、微调信息(nudge_info.h)和障碍物(obstacle.h)等。</p> </li> <li> <p>然后，它在apollo::planning命名空间下定义了一个名为PathDecision的类。这个类代表一条路径上所有的障碍物决策。</p> </li> <li> <p>这个类有一个公有成员函数AddObstacle用于添加障碍物。还有两个公有成员函数AddLateralDecision和AddLongitudinalDecision，这两个函数分别用于添加横向和纵向决策。</p> </li> <li> <p>还包含了一些函数用于查找特定ID的障碍物或感知障碍物(Find和FindPerceptionObstacle)、设置和清除ST边界(SetSTBoundary和EraseStBoundaries)、与主停止点合并(MergeWithMainStop)等。</p> </li> <li> <p>最后，这个类还有一些私有成员变量，如存储障碍物的索引列表(obstacles_)、主停止点(main<em>stop</em>)、停止参考线的s坐标(stop_reference_line<em>s</em>)和微调信息(nudge<em>info</em>)等。</p> </li> </ul> <h4>obstacle.h</h4> <p>这是一个C++头文件，位于./planning_base/common目录下，文件名为obstacle.h。这个文件主要定义了一个名为Obstacle的类。这个类包含了一些关于障碍物对于自动驾驶车辆的决策制定功能。它包含了与障碍相关的属性，包括障碍物的识别，障碍物的动态信息（如速度，轨迹等），以及对障碍物的处理决策（如停止，跟随，越过，忽视等）。此外，还定义了一些辅助函数，帮助处理障碍物数据。</p> <h4>open_space_info.h</h4> <p>该文件是一个C++头文件，定义了一个名为OpenSpaceInfo的类，这个类用于存储和管理关于自动驾驶车辆在开阔空间（如停车场）中进行运行所需的信息。它包含了多个成员变量和对应的访问器与修改器，这些成员变量包含多种信息，如目标停车位信息、障碍物信息、运行轨迹信息等。该类还提供了一些可以记录或改变关键性行驶参数的方法，如设定停车类型、检测未来的可能碰撞点、同步调试信息等。在头文件的最后，命名空间被设置为&quot;apollo::planning&quot;，表示该类是Apollo自动驾驶系统规划模块的一部分。</p> <h4>history.h</h4> <p>这是一份位于<code>./planning_base/common</code>路径下的头文件(<code>history.h</code>)，属于Apollo自动驾驶项目。此文件主要定义了五个类 — <code>HistoryObjectDecision</code>, <code>HistoryFrame</code>, <code>HistoryObjectStatus</code>, <code>HistoryStatus</code>, 和 <code>History</code>。</p> <ol> <li> <p><code>HistoryObjectDecision</code>类主要用于管理对象决策的历史，包含了对应对象ID和其决策类型的向量。</p> </li> <li> <p><code>HistoryFrame</code>类代表一个历史帧，它包含了序列号、ADCTrajectory对象、一个unordered_map存储对象ID到其历史决策的映射，以及一个包含所有历史决策的向量。</p> </li> <li> <p><code>HistoryObjectStatus</code>类用于管理对象的状态，保存了对象ID和对象状态。</p> </li> <li> <p><code>HistoryStatus</code>类记录了对象的历史状态，它通过unordered_map将对象ID映射到其状态。</p> </li> <li> <p>最后，<code>History</code>类代表了整个历史，它维护了一个历史帧的列表和一个<code>HistoryStatus</code>对象。还提供了诸如获取最后一帧、添加新帧、清除历史和获取历史大小等功能。</p> </li> </ol> <p>这些类主要用于存储和操作在自动驾驶过程中的历史数据。</p> <h4>indexed_queue.h</h4> <p>这是一个indexed_queue的C++模板代码，属于Apollo自动驾驶系统的规划模块内的一个公共部分。文件进行了命名空间的规定，包含在apollo和planning两个命名空间下。</p> <p>该模板类为IndexedQueue，用于创建一个带有索引的队列数据结构，拥有常见的查找、添加、清除等操作。它接受两个模板参数：I（作为索引）和T（队列元素的类型）。</p> <p>该队列通过一个unordered_map容器来实现，使用了pair（将索引和元素指针关联）将元素存储在std::queue容器中。每个元素都有从唯一的索引到队列元素的映射。</p> <p>同时，该队列也支持有限的容量设置，如果达到容量上限，新添加的元素会使得最先加入的元素被移除。若设置容量为0，则队列具有无限容量。</p> <p>程序代码包含了标准的一些操作函数，如Find查找给定索引的元素，Latest返回最新加入的元素，Add添加索引和元素对，Clear清除队列中所有的元素。</p> <h4>feature_output.h</h4> <p>此文件是Apollo自动驾驶系统的一部分，专门定义了一个名为FeatureOutput的类，该类用来处理学习数据的输出。此类不可直接实例化，所有的方法都是静态方法，用来操作全局数据。</p> <p>该类的主要职责如下：</p> <ol> <li>关闭输出流（<code>Close</code>）。</li> <li>清除所有数据（<code>Clear</code>）。</li> <li>检查输出是否准备好（<code>Ready</code>）。</li> <li>插入一帧学习数据（<code>InsertLearningDataFrame</code>）。</li> <li>插入规划结果（<code>InsertPlanningResult</code>）。</li> <li>获取最新的学习数据帧（<code>GetLatestLearningDataFrame</code>）。</li> <li>将学习数据写入文件（<code>WriteLearningData</code>和<code>WriteRemainderiLearningData</code>）。</li> <li>获取当前学习数据的大小（<code>SizeOfLearningData</code>）。</li> </ol> <p>其中，LearningData类型是由&quot;./planning_base/proto/learning_data.pb.h&quot;文件中的protobuf定义的，用于存储学习数据。</p> <h4>ego_info.h</h4> <p>这是Apollo自动驾驶系统中的一部分，具体来说，文件是“./planning_base/common/ego_info.h”。这是C++的头文件，定义了一个名为EgoInfo的类，它处理关于自车（即自动驾驶车辆或“ego vehicle”）的信息。</p> <p>EgoInfo类有一些公共方法，包括更新自车信息（使用轨迹起始点和车辆状态作为参数），清除信息，获取各种状态属性，和计算前方障碍物的清晰距离。它还包含一些私人方法和变量，用于存储和操作这些状态信息。</p> <p>文件中也包含一些头文件的引入，这些头文件代表各种依赖项，包括proto文件（用于数据序列化和通信），其他常用模块，以及来自当前planning模块的其他头文件等。</p> <p>这个文件是开源的，依据的是Apache许可证2.0。</p> <h4>local_view.h</h4> <p>这个文件是一个C++头文件，位于项目的&quot;./planning_base/common/&quot;目录下。文件名为&quot;local_view.h&quot;，它包含了命名空间&quot;apollo&quot;下的子命名空间&quot;planning&quot;中的&quot;LocalView&quot;结构体的声明。</p> <p>&quot;LocalView&quot;结构体包含了许多作为在计划阶段输入所需的重要数据，所有的数据都被封装在std::shared_ptr中，以方便内存管理。这些数据包括车辆预期障碍物（prediction_obstacles）、车辆底盘状态（chassis）、车辆定位估计（localization_estimate）、交通灯检测（traffic_light）、相对地图（relative_map）、Pad消息（pad_msg）、故事（stories）、规划指令（planning_command）和结束车道路径点（end_lane_way_point）。</p> <p>这个头文件还引入了一系列与这些数据类型有关的protobuf消息文件，这些文件定义了各个数据的详细结构。</p> <h4>planning_context.h</h4> <p>这个文件名为&quot;planning_context.h&quot;的文件是一个C++头文件，它定义了一个名为&quot;PlanningContext&quot;的类，这个类是Apollo自动驾驶框架中规划模块的一部分。</p> <p>&quot;PlanningContext&quot;类的主要作用是存储和管理规划模块的运行时上下文。这个上下文是在多帧之间持续存在的。</p> <p>这个类包含一个&quot;PlanningStatus&quot;对象的私有成员。类中提供了访问和修改这个&quot;PlanningStatus&quot;成员的公共方法。根据注释，所有的状态信息都应在&quot;PlanningStatus&quot;中进行维护，而不是在这个级别创建新的结构体。</p> <p>这个文件的许可证是Apache 2.0许可证，表明文件是开源的，可以在遵守许可证协议的条件下被使用和修改。</p> <p>总的来说，这个头文件描述了规划模块的运行时上下文，这成为了规划模块在处理自动驾驶任务时的基础状态信息。</p> <h4>trajectory_stitcher.h</h4> <p>这个文件名为<code>trajectory_stitcher.h</code>的C++程序头文件位于<code>./planning_base/common/</code>目录下，并属于<code>apollo</code>和<code>planning</code>的命名空间。它主要定义了一个类<code>TrajectoryStitcher</code>，负责路径的拼接相关计算。</p> <p><code>TrajectoryStitcher</code>类中包括的方法有：</p> <ul> <li><code>TransformLastPublishedTrajectory</code>：这个函数用于对上一次公布的轨迹进行变换；</li> <li><code>ComputeStitchingTrajectory</code>：计算拼接路径。这个函数基于车辆底盘状态、车辆状态、当前时间戳、计划周期时间、预留点数、偏移重规划和上一次发布的轨迹来计算结果轨迹，并返回一个轨迹点的向量；</li> <li><code>ComputeReinitStitchingTrajectory</code>：计算重新初始化的拼接路径，这个函数基于计划周期时间和车辆状态计算重新初始化的拼接路径，返回一个轨迹点的向量；</li> <li><code>ComputePositionProjection</code>：计算位置投影，返回一个包含两个double元素的pair；</li> <li><code>ComputeTrajectoryPointFromVehicleState</code>：从车辆状态信息计算轨迹点。</li> </ul> <p>此外，该文件还引入了多个其他的头文件，其中包括多个protobuf结构定义，例如<code>vehicle_state.pb.h</code>、<code>pnc_point.pb.h</code>等，用于支持轨迹计算中的数据交互和表达。</p> <h4>indexed_list.h</h4> <p><code>indexed_list.h</code> 文件是Apache的Apollo项目中的一部分，它提供了两个模板类 <code>IndexedList</code> 和 <code>ThreadSafeIndexedList</code>。这两个类在内部使用 <code>std::unordered_map</code> 和 <code>std::vector</code> 来管理和存储数据对象。<code>IndexedList</code> 类用于在非线程安全的环境中存储和操作数据，而 <code>ThreadSafeIndexedList</code> 类用于在需要线程安全的环境中存储和操作数据。</p> <p>对于每个类，都定义了几个主要的成员函数：</p> <ul> <li><code>Add</code>: 添加一个对象到容器里。如果对象的id已经存在，那么就会覆盖容器中的对象。</li> <li><code>Find</code>: 根据id查找容器中的对象。如果找到了对象，那么就返回一个指向该对象的指针，否则返回 <code>nullptr</code>。</li> <li><code>Items</code>：返回包含容器中所有对象的列表。这个列表的元素是指向容器中的对象的指针。</li> <li><code>Dict</code>：返回包含容器中所有对象的unordered_map。</li> </ul> <p><code>ThreadSafeIndexedList</code> 类的实现利用了 <code>boost::shared_mutex</code> 来在多线程环境中保护对数据的访问。</p> <h4>speed_profile_generator.h</h4> <p>这是一个由Apollo开发的源代码文件，主要用于生成速度规划。这个速度规划生成器（SpeedProfileGenerator）中有些主要的功能方法，如 FillEnoughSpeedPoints 和 GenerateFixedDistanceCreepProfile。</p> <p>FillEnoughSpeedPoints 方法是用来在给定的 SpeedData 类型变量中填充足够的速度点。</p> <p>GenerateFixedDistanceCreepProfile 方法则是生成一个给定距离和最大速度的固定距离蠕行轮廓。</p> <p>这个代码文件被设计为无法被实例化，所有的方法都是静态的，所以这显然是一个工具类或者帮助类。</p> <p>它依赖了一些头文件，其中最重要的包括 &#8216;speed/speed_data.h&#8217; 和 &#8216;math/curve1d/quintic_polynomial_curve1d.h&#8217;，分别提供了与速度数据和五次多项式曲线相关的功能。</p> <h4>frame.h</h4> <p>这是一个C++头文件，定义了名为<code>Frame</code>的类，该类包含在<code>apollo::planning</code>命名空间中。该<code>Frame</code>类是计划周期中使用的数据集合。</p> <p>类的主要成员包括：一个用于标识序列号的<code>sequence_num_</code>、一个<code>LocalView</code>对象<code>local_view_</code>、当前期计划的起点<code>planning_start_point_</code>、当前车辆状态<code>vehicle_state_</code>、参考线信息列表、一个指示近目的地是否为true的布尔标志<code>is_near_destination_</code> 等等。</p> <p>该类提供了一些实用的成员函数，包括对数据进行初始化的<code>Init</code>和<code>InitForOpenSpace</code>方法，以及一些数据获取和设置的方法。</p> <p>其中定义了一些私有方法，如用于创建静态障碍的<code>CreateStaticVirtualObstacle</code>，添加障碍的<code>AddObstacle</code>，以及查找碰撞障碍的<code>FindCollisionObstacle</code>和用于读取交通灯和驾驶动作消息的<code>ReadTrafficLights</code>和<code>ReadPadMsgDrivingAction</code>等。</p> <p>此外，还定义了一个<code>FrameHistory</code>类，这个类继承了<code>IndexedQueue</code>，用于存储<code>Frame</code>对象的历史记录。</p> <p>总之，这个头文件主要是定义了<code>Frame</code>类和<code>FrameHistory</code>类，前者用于存储计划周期所需要的数据，后者则用于存储<code>Frame</code>的历史记录。</p> <h4>learning_based_data.h</h4> <p>这是一个头文件，定义了一个名为<code>LearningBasedData</code>的类，此类是Apollo自动驾驶系统中的一部分。这个类属于<code>planning</code>模块，负责处理学习相关的数据。</p> <p>在类<code>LearningBasedData</code>中，定义了几个公有方法和私有成员。主要包含以下几部分:</p> <ol> <li>构造函数<code>LearningBasedData()</code>，其为空构造函数。</li> <li><code>Clear()</code>函数，用于清理数据。</li> <li><code>InsertLearningDataFrame()</code>函数，用于插入一项学习数据框。</li> <li><code>GetLatestLearningDataFrame()</code>函数，用于获取最新的学习数据框。</li> <li><code>learning_data_adc_future_trajectory_points()</code>函数，用于获取未来轨迹点的数据。</li> </ol> <p>私有成员包括了：</p> <ol> <li><code>LearningData learning_data_</code>，是学习数据的容器。</li> <li><code>std::vector&lt;common::TrajectoryPoint&gt; learning_data_adc_future_trajectory_points_</code>，是存储未来轨迹点的向量。</li> </ol> <p>此外，该头文件包含了<code>LearningData.pb.h</code>头文件，这说明它使用了由protobuf定义的LearningData数据类型。</p> <h4>st_graph_data.h</h4> <p>这是 Apollo 项目的一部分，具体来说，它属于 planning 模块的子模块 planning_base。它的作用是处理与速度和时间有关的地图信息和障碍物信息，这些信息可以用于路径规划和决策。</p> <p>文件名是 &quot;st_graph_data.h&quot;，这是一个头文件，其中声明了一个名为 StGraphData 的类。该类处理地图和障碍物信息，并且包含一些与该信息有关的属性和方法。</p> <p>类包含以下属性：</p> <ul> <li>一组 STBoundary 对象，表示时间和空间的障碍物界限。</li> <li>定义在 STBoundary 对应路径上最小的 s 距离值属性。</li> <li>包括初始点（init_point）属性，这是一个 TrajectoryPoint 类型的对象，它表示路径规划的起点。</li> <li>SpeedLimit 对象，表示速度限制。</li> <li>浮点型的变量 cruise_speed，表示期望的巡航速度。</li> <li>一个表示路径数据长度的浮点型变量 path_data_length。</li> <li>一个表示由配置得到的总时间的浮点型变量 total_time_by_conf。</li> <li>STGraphDebug 对象，用于调试 ST 图。</li> <li>STDrivableBoundary 对象，表示可驾驶边界。</li> </ul> <p>类中的方法包括加载和获取数据，设置和获取 ST 驾驶边界等。</p> <h4>obstacle_blocking_analyzer.h</h4> <p>该文件为C++头文件，文件位置在<code>./planning_base/common/</code>目录下，文件名为<code>obstacle_blocking_analyzer.h</code>。该文件属于<code>Apollo</code>自动驾驶系统的一部分，特别是在规划（planning）模块中，用于分析阻挡障碍（Blocking Obstacle）。该头文件定义了一些函数和命名空间，主要用于决定一个障碍物是否是阻挡车辆的，是否需要进行避难以及与自动驾驶车辆的距离等。</p> <p>具体包含如下几个函数：</p> <ol> <li> <p><code>IsNonmovableObstacle()</code>：判断一个障碍物是否是非移动的。</p> </li> <li> <p><code>IsBlockingObstacleToSidePass()</code>：决定一个障碍物是否阻止车辆并需要侧过去。</p> </li> <li> <p><code>GetDistanceBetweenADCAndObstacle()</code>：计算自动驾驶车(ADC)与障碍物的距离。</p> </li> <li> <p><code>IsBlockingDrivingPathObstacle()</code>：检查障碍物是否阻碍ADC的行驶路径(reference_line)。</p> </li> <li> <p><code>IsParkedVehicle()</code>：判断一个障碍物是否是停放车辆。</p> </li> </ol> <p>此外，根据Apache证书文件要求，该文件包含版权声明和许可证信息。</p> <h4>path_boundary.h</h4> <p>这个文件是一个C++头文件，位于<code>./planning_base/common</code>目录下，名为<code>path_boundary.h</code>。这个头文件定义了属于<code>apollo::planning</code>命名空间中的几个类和结构。Apollo是开源的自动驾驶系统。</p> <p>文件开始的注释说明，这份代码获得了Apache许可的授权，并标明了相关的版权信息。</p> <p>这个文件定义的主要结构包括<code>BoundType</code>（用于表示界限类型的枚举）、<code>BoundEdge</code>（表示边界的结构，含有边界类型字段、一条长度double字段和一个id字符串字段）、<code>InterPolatedPoint</code>（表示插值点的结构，包含左权重、右权重、下界、上界，左索引、右索引和后轴的s值）、<code>PathBoundPoint</code>（表示路径边界点的结构）、还定义了<code>ADCVertexConstraints</code>和<code>PathBoundary</code>两个类。</p> <p><code>ADCVertexConstraints</code>类是<code>std::vector&lt;InterPolatedPoint&gt;</code>的公共派生类，增加了一个<code>front_edge_to_center</code>的double字段。</p> <p><code>PathBoundary</code>类是<code>std::vector&lt;PathBoundPoint&gt;</code>的公共派生类，表示路径边界。它能通过更多的<code>std::vector&lt;std::pair&lt;double, double&gt;&gt;</code>或者<code>PathBound</code>构造路径边界，还有很多成员函数让我们能方便的获取和设置相关的数据。例如，<code>get_lower_bound_by_s</code>函数允许我们通过参数s来获取下界，<code>set_label</code>函数允许我们设置路径边界的标签等。</p> <h4>reference_line_info.h</h4> <p>该文件是Apollo自动驾驶项目的一部分，位于模块目录<code>./</code>里的<code>planning_base/common/</code>。具体文件名是<code>reference_line_info.h</code>，它是一个C++头文件，定义了一个叫做<code>ReferenceLineInfo</code>的类。</p> <p><code>ReferenceLineInfo</code>类保存了关于一个参考线（Reference Line）的所有数据。在自动驾驶中，参考线通常用于表示车辆预期行驶的路线，普遍应用于路径规划与决策。</p> <p>该类包含了大量的属性和方法，在车道选择、障碍物添加和删除、轨迹优化和评估、运动决策等方面都有相关的实现。</p> <p>文件还定义了一串<code>OverlapType</code>枚举，用于指示在路径规划中可能遇到的不同类型的重叠情况，如交叉路口，停车标志等。</p> <p>这个头文件涉及的其他库和模块包括但不限于：车辆状态信息，各类消息定义，地图信息处理，路径决策信息，速度信息处理等。这都明确了<code>ReferenceLineInfo</code>在整个系统中的重要作用，它是整个自动驾驶系统规划决策阶段的核心组件之一。</p> <h4>decision_data.h</h4> <p>这个C++源文件属于项目 &quot;Apollo&quot; 中处理自动驾驶计划的模块。文件定义了一个 &quot;决策数据&quot; (DecisionData) 类，它被设计来处理有关路线中遇到的障碍物的信息。</p> <p>在 &quot;决策数据&quot; 类中，有许多方法用于处理和分类障碍物。这些方法包括通过ID获取障碍物；按类型获取障碍物；创建“虚拟障碍物”等。同时，该类中还定义了一些私有变量用于存储不同类型的障碍物（如静态障碍物、动态障碍物、虚拟障碍物等），以及一些Auxiliary方法，如验证车辆能否通过障碍物所在路径。</p> <p>此外，文件还定义了一个枚举类型 &quot;VirtualObjectType&quot;，用于表示各类虚拟障碍物类型，如目的地、人行横道、红绿灯、路线改变标志等。</p> <p>总之，该源文件主要处理和管理与自动驾驶计划中的障碍物相关的数据和逻辑。</p> <h4>message_process.h</h4> <p>这是一个C++程序头文件，名为 <code>message_process.h</code>。它定义了一个名为 <code>MessageProcess</code> 的类，属于 <code>apollo::planning</code> 命名空间。</p> <p><code>MessageProcess</code> 类内拥有多个公共(public)和私有(private)方法以及一些数据成员。以下是一些重要的方法和数据成员：</p> <p>公共方法：</p> <ul> <li>行为初始化（<code>Init</code>），有两种重载版本：一种只需要一个 <code>PlanningConfig</code> 对象，另一种还需要一个 <code>DependencyInjector</code> 对象的共享指针。</li> <li>当接收到车身信息时的行为（<code>OnChassis</code>）。</li> <li>当接收到HMI状态信息时的行为（<code>OnHMIStatus</code>）。</li> <li>当接收到定位信息时的行为（<code>OnLocalization</code>）。</li> <li>当接收到预测障碍信息时的行为（<code>OnPrediction</code>）。</li> <li>当接收到路径规划响应时的行为（<code>OnRoutingResponse</code>）。</li> <li>当接收到故事情节信息时的行为（<code>OnStoryTelling</code>）。</li> <li>当接收到交通灯检测信息时的行为（<code>OnTrafficLightDetection</code>）。</li> <li>离线数据处理（<code>ProcessOfflineData</code>）。</li> </ul> <p>私有方法：</p> <ul> <li>一系列用于生成处理结果的方法（如：<code>GetCurrentLane</code>, <code>GetADCCurrentInfo</code>, <code>GenerateObstacleTrajectory</code>, <code>GenerateObstaclePrediction</code>, <code>GenerateObstacleFeature</code>,<code>GenerateLocalRouting</code>, <code>GenerateRoutingFeature</code>, <code>GenerateTrafficLightDetectionFeature</code>, <code>GenerateADCTrajectoryPoints</code>, <code>GeneratePlanningTag</code>, <code>GenerateLearningDataFrame</code>）等。</li> </ul> <p>数据成员主要包括 <code>planning_config_</code>（规划配置）, <code>injector_</code>（依赖注入器的共享指针）、日志文件 <code>log_file_</code>、记录文件 <code>record_file_</code>以及一些用于存储处理结果的数据结构等。</p> <p>简而言之, <code>MessageProcess</code> 类用于接收、处理一系列车辆相关的信息，并根据处理结果进行决策。</p> <h4>trajectory<em>evaluator.h</em></h4> <p>这是一个C++的头文件，定义了一个名为TrajectoryEvaluator的类，文件属于Apollo自动驾驶系统的一个模块。这个类的主要作用是评估轨迹，包括自动驾驶车辆（ADC）的当前轨迹和预计将要行驶的轨迹，以及其他遇到的障碍物的轨迹。</p> <p>TrajectoryEvaluator类有多个公共方法：</p> <ul> <li>EvaluateADCTrajectory：评估自动驾驶车辆当前的轨迹。</li> <li>EvaluateADCFutureTrajectory：评估自动驾驶车辆未来的轨迹。</li> <li>EvaluateObstacleTrajectory：评估遇到障碍物的轨迹。</li> <li>EvaluateObstaclePredictionTrajectory：评估预测的障碍物轨迹。</li> </ul> <p>其中还有一些私有方法，如 EvaluateTrajectoryByTime、Convert、WriteLog等，主要用于辅助上述公共方法。</p> <p>该文件还引用了protobuf的数据结构，用于数据交换。</p> <h4>nudge_info.h</h4> <p>这个代码文件是Apollo自动驾驶系统中的一部分，它包含了Nudge(微调)的相关信息和数据结构。</p> <p>该文件中定义了一些复杂的数据结构，包括<code>RemainNudgeSpace</code>，<code>NudgeType</code>，<code>NudgeObstacleInfo</code>和<code>NudgeInfo</code>类。其中，<code>RemainNudgeSpace</code>记录了剩余的行车空间，<code>NudgeType</code>是一个枚举类型，表示微调类型，<code>NudgeObstacleInfo</code>结构体主要用于记录障碍物的信息，包括障碍物的原始和扩展边界，是否可通行，其在S-L坐标系下的边界以及更多其他信息，而<code>NudgeInfo</code>类用于存储和处理与微调相关的信息。</p> <p>另外，还有一些函数定义，例如设置和获取一些成员变量的值，检查障碍物，排序SL多边形，打印调试信息等。</p> <p>这个文件所在的路径（./planning_base/common/nudge_info.h）表明这个文件可能是用于路径规划模块中的一些通用功能。</p> <h4>speed_limit.h</h4> <p>这个文件定义了一个名为&quot;SpeedLimit&quot;的类，这个类属于&quot;apollo::planning&quot;命名空间，主要关注的是速度限制的处理。</p> <p>在SpeedLimit类中，定义了以下方法：</p> <ol> <li>&quot;AppendSpeedLimit&quot;方法：接收两个double类型的参数s和v，用于添加速度限制点。这些点被保存为一对数值，其中s代表从起点开始的距离，v代表该距离处的速度限制。</li> <li>&quot;speed_limit_points&quot;方法：这是一个获取器，返回存储的速度限制点对的引用。</li> <li>&quot;GetSpeedLimitByS&quot;方法：接收一个double类型的参数s。该方法用于查询Ｓ距离处的最大速度限制，并返回对应的速度值v。</li> <li>&quot;Clear&quot;方法：用于清除存储的所有速度限制点。</li> </ol> <p>在类的私有部分，有一个名为&quot;speed_limit<em>points</em>&quot;的std::vector容器，用于保存一对double类型的值（即(s, v)），分别代表从起始点的特定距离和在那个地方的速度限制。</p> <h4>path</h4> <h5>discretized_path.h</h5> <p>这个文件定义了一个名为&quot;DiscretizedPath&quot;的类，该类主要在Apollo项目的规划模块中用于处理离散路径，文件位于路径的“./planning_base/common/path”中。文件是由Apache 2.0协议许可的， 定义了该类并派生于一个合成的基类std::vector<common::PathPoint>，这表示路径被划分为一系列的路径点。</p> <p>主要成员函数包括：</p> <ul> <li>一个默认构造函数</li> <li>一个以路径点向量作为参数的构造函数</li> <li>&quot;Length&quot;函数，用于计算路径的长度</li> <li>&quot;Evaluate&quot;函数，可以评估给定路径点的值</li> <li>&quot;EvaluateReverse&quot;函数，可以反向评估给定路径点的值</li> <li>&quot;QueryLowerBound&quot;和&quot;QueryUpperBound&quot;函数用于查找给定路径点的上下界。</li> </ul> <p>该类是在Apollo的命名空间下的Planning模块中定义的，作为路径点的离散表示，为路径规划和路径执行功能提供基础实现。</p> <h5>frenet_frame_path.h</h5> <p>这是一个名为&quot;frenet_frame_path.h&quot;的C++头文件。它是Apollo自动驾驶系统的一部分，位于planning模块的路径(Debug)对应的目录下。</p> <p>此头文件中定义的主要类是FrenetFramePath，它继承自std::vector<common::FrenetFramePoint>，所以它是对保存FrenetFramePoint类型的std::vector的扩展。FrenetFramePoint用于表示在Frenet坐标系中的点。</p> <p>FrenetFramePath 类提供了一些公共操作，如Length()用于计算路径的长度，EvaluateByS()用于按照s的参数定位FrenetFramePoint，以及GetNearestPoint()是获取与给定的SLBoundary最近的FrenetFramePoint。</p> <p>两个私有静态函数，LowerBoundComparator()和UpperBoundComparator()，用于比较FrenetFramePoint与给定值s的关系，它们在例如std::lower_bound和std::upper_bound这类函数中用于提供自定义的比较逻辑。</p> <h5>path_data.h</h5> <p>这是一个头文件，名为path_data.h，位于./planning_base/common/path目录下。它是Apollo自动驾驶系统中的部分，定义了一个名为PathData的类和一些相关的类型和方法。这个类主要用于处理路径数据和路径决策。</p> <p>在PathData类中，定义了以下的公开方法和属性：</p> <ol> <li>构造函数 <code>PathData()</code></li> <li>一系列的设置（Set）和获取（Get）方法，包括设置和获取离散路径（Discretized Path），弗雷奈特路径（Frenet Frame Path），参考线（Reference Line）和路径点决策指南等。</li> <li><code>Clear()</code> 和 <code>Empty()</code> 方法，分别用于清除路径数据和检查路径数据是否为空</li> <li><code>DebugString()</code> 方法，用于获取路径数据的调试信息</li> <li><code>set_path_label()</code> 和 <code>path_label()</code>方法， 分别用于设置和获取路径的标签</li> <li><code>set_blocking_obstacle_id()</code> 和 <code>blocking_obstacle_id()</code> 方法， 用于设置和获取阻塞障碍物的ID</li> <li>更多与路径优化和参考路径相关的设置和获取方法。</li> </ol> <p>同时，类中还定义了一些私有方法，如SLToXY和XYToSL，分别用于将弗雷奈特路径转换为直角坐标系路径，以及将笛卡尔坐标系路径转换为弗雷奈特路径。</p> <h4>smoothers</h4> <h5>smoother.h</h5> <p>这是一个名为 &quot;Smoother&quot; 的C++ 头文件, 属于Apollo自动驾驶系统的一部分。此文件中定义了一个Smoother类，它的主要功能是平滑自动驾驶车辆的轨迹。它是在&quot;./planning_base/common/smoothers&quot;路径下。</p> <p>Smoother类定义有两个公用方法（公有成员）和一个私有方法（私有成员）。</p> <ul> <li>Smoother() 是默认构造函数。</li> <li>~Smoother() 是虚析构函数，声明virtual是为了在后续可能出现的继承该类的情况下正确地删除实例和释放内存。</li> <li>Smooth() 接受三个参数，一个是帧历史记录，一个是当前帧，最后一个是自动驾驶车辆的当前轨迹。其功能是平滑或调整车辆轨迹。</li> </ul> <p>在私有成员中，IsCloseStop() 方法用来判断车辆状态和主停止命令，从而确定是否应该紧急停车。</p> <p>此类使用了一些外部定义的数据结构，如FrameHistory, Frame, ADCTrajectory等，这些都是在开头通过#include引入的头文件中定义的。</p> <p>在遵循开源协议(Apache License, Version 2.0)的前提下，这个头文件和定义的类可以在Apollo自动驾驶系统的其他部分中被复用。</p> <h4>speed</h4> <h5>st_point.h</h5> <p>这是一个名为&quot;st_point.h&quot;的头文件，它位于&quot;./planning_base/common/speed&quot;目录下。这个文件定义了一个名为&quot;STPoint&quot;的类，该类属于命名空间&quot;apollo::planning&quot;。&quot;STPoint&quot;类继承自&quot;common::math::Vec2d&quot;类，并且提供了一些额外的方法和属性。</p> <p>&quot;STPoint&quot;类表示一个二维点（s，t），其中&quot;STPoint&quot;含有一些方法，包括获取和设置s和t值的方法，并有一个返回对象状态的debug方法。需要注意的是，该类显式地删除了对&quot;Vec2d&quot;类中x()和y()方法的调用，这表明STPoint类专门用来处理ST空间的问题，s和t分别是定义在ST空间上的两个变量。</p> <h5>st_boundary.h</h5> <p>这是一个名为&quot;st_boundary.h&quot;的C++头文件，属于一个自动驾驶项目的规划模块（Planning）的一部分。</p> <p>这个文件定义了一个名为&quot;STBoundary&quot;的类。&quot;STBoundary&quot;类由一组ST点对（表示在特定时间t，其下限位于s位置）初始化，其中&quot;S&quot;和&quot;T&quot;通常用于表示车辆运动的空间和时间变量。类中设定的公共方法大部分与对ST边界或ST点的操作有关，例如：检测ST边界是否为空，获取边界的S范围和斜率，判断ST点是否在边界内等等。</p> <p>&quot;STBoundary&quot;类还维护了一个包含各种不同边界类型的枚举，像是停止（STOP），跟随（FOLLOW），让路（YIELD），超越（OVERTAKE），保持清晰（KEEP_CLEAR）等等。每个STBoundary类的实例都会有一个归属的成员，表示其边界类型。</p> <p>它还包含一些私有方法以进行边界的有效性检查，删除多余的点，或者在指定的ST点序列中找到包含特定时间t的段。</p> <p>整体上，&quot;STBoundary&quot;类在规划模块中是非常重要的，它可能被用于在执行路径和速度规划时，定义不同的行为边界。</p> <h5>speed_data.h</h5> <p>这个文件是Apollo自动驾驶系统中的一部分，名为&quot;speed_data.h&quot;。它是一个头文件，定义了一个名为SpeedData的类。这个类是基于<code>std::vector&lt;common::SpeedPoint&gt;</code>，其中<code>common::SpeedPoint</code>是一个由protobuf定义的数据结构，包含了位置，时间，速度，加速度等关于车辆运动的信息。</p> <p>SpeedData类主要包含以下方法：</p> <ul> <li><code>SpeedData(std::vector&lt;common::SpeedPoint&gt; speed_points)</code>：构造函数，用于初始化SpeedData实例。</li> <li><code>AppendSpeedPoint</code>：向SpeedData中添加一个新的速度点。</li> <li><code>EvaluateByTime</code>和<code>EvaluateByS</code>：这两个函数都是通过给定的时间或位置进行评估，并返回一个<code>common::SpeedPoint</code>对象。</li> <li><code>TotalTime</code>和<code>TotalLength</code>：这两个函数分别返回SpeedData中所有速度点的总时间和总距离。</li> <li><code>DebugString</code>：此函数返回一个字符串，描述SpeedData的当前状态。</li> </ul> <p>此外，该文件还包含了一些版权和许可证信息。</p> <h4>trajectory</h4> <h5>discretized_trajectory.h</h5> <p>这个文件是属于 Apollo 开源自动驾驶系统中 &quot;planning&quot; 模块的一个部分，特定位置在 &quot;common/trajectory&quot; 下，名为 &quot;discretized_trajectory.h&quot; 的头文件。此文件定义了一个名为 &quot;DiscretizedTrajectory&quot; 的类，这个类继承自 std::vector 类且元素类型为 common::TrajectoryPoint。</p> <p>此类用于表示一个离散化的轨迹，它包含了一系列的轨迹点 (&quot;TrajectoryPoint&quot;)。类中包含的方法可以用来设置轨迹点，获取轨迹的起始点，获取轨迹的时空信息，获取特定时间点的轨迹点，查询最近的轨迹点等。它也包含标记轨迹方向是否反向的属性和方法。</p> <p>该类中的方法大部分被定义为虚函数，这有可能是为了在其子类中定制不同的实现。</p> <p>这个文件是按照 Apache License 2.0 开源许可协议发布的，这意味着可以自由地使用、复制和分发，但必须保持原始版权声明，并且对原始作者不负任何责任。</p> <h5>publishable_trajectory.h</h5> <p>&quot;publishable_trajectory.h&quot;是来自于Apollo自动驾驶项目的一部分，特定于其计划模块中的轨迹发布。文件主要定义一个名为&quot;PublishableTrajectory&quot;的类，该类继承自&quot;DiscretizedTrajectory&quot;类。</p> <p>&quot;PublishableTrajectory&quot;类有四个主要的功能部分。首先，它有两个构造函数，一个是默认构造函数，无任何参数，另一个接受一个header_time和一个DiscretizedTrajectory对象。第三个构造函数接受一个ADCTrajectory protobuf，并基于此创建出可发布的轨迹。</p> <p>另外两个方法包括获取header_time和一个方法用于把特定的轨迹信息填充到一个protobuf中。</p> <p>最后，它有一个名为header_time_的私有数据成员。</p> <h4>trajectory1d</h4> <h5>piecewise_jerk_trajectory1d.h</h5> <p>这是一个源代码文件，特指一段Apollo自动驾驶车辆的规划模块。特别是在 &quot;trajectory1d&quot;目录中，文件名为 &quot;piecewise_jerk_trajectory1d.h&quot;。这是一个C++头文件，定义了一个名为 &quot;PiecewiseJerkTrajectory1d&quot;的类。</p> <p>该类继承自 &quot;Curve1d&quot; 类，主要实现了一种特定的路径轨迹计算方式，即分段恒加速度路径。该类通过连续多个分段恒加速度（&quot;ConstantJerkTrajectory1d&quot; 对象）来拼凑成更复杂的路径，并提供了判断和评估路径的方法。</p> <p>这个类的主要功能包括：</p> <ol> <li>初始化方法，设置初始的位置、速度和加速度；</li> <li>评估方法，用于求取某一给定参数处的各阶导数值；</li> <li>参数长度方法，获取分段的参数长度列表；</li> <li>字符串方法，输出类的字符串描述；</li> <li>附加段方法，用于向轨迹中添加新的恒加速度路径段。</li> </ol> <p>特别需要说明的是，该类包含了一系列私有成员变量，这些变量包括一个&quot;ConstantJerkTrajectory1d&quot;对象的向量，它存储了所有的分段恒加速度路径，以及最后一个段的位置、速度和加速度等参数。</p> <h5>standing_still_trajectory1d.h</h5> <p>这是一个名为&quot;StandingStillTrajectory1d&quot;的C++头文件，是自动驾驶系统Apollo的一部分，属于planning模块。在定义了一些版权和许可的注释后，它包含了&quot;StandingStillTrajectory1d&quot;类的定义。这个类继承自&quot;Curve1d&quot;类，并提供了一种特定的一维运动路径。</p> <p>&quot;StandingStillTrajectory1d&quot;代表的是一个静止的一维轨迹。在这个类中定义了两个私有的成员变量：fixed_position<em>和duration</em>，分别表示对象的固定位置和一段持续时间。</p> <p>类中包含以下方法：</p> <ul> <li>构造函数和析构函数。</li> <li>ParamLength()方法返回参数长度。</li> <li>ToString()方法以字符串形式返回对象的状态。</li> <li>Evaluate()方法计算并返回指定参数和指定阶数的评估值。</li> </ul> <p>此外，还有几个更特殊的私有方法：Evaluate_s(), Evaluate_v(), Evaluate_a(), Evaluate_j(), 分别用于计算位移、速度、加速度和急度。</p> <h5>constant_deceleration_trajectory1d.h</h5> <p>这是一个名为&quot;ConstantDecelerationTrajectory1d&quot;的C++文件，这是一个代表一维恒定减速轨迹的类，该类继承自抽象基类&quot;Curve1d&quot;。该类包含以下公共函数：</p> <ul> <li>一个接受初始位置、初始速度和加速度（在这种情况下实际上是减速）的构造函数。</li> <li>虚拟析构函数。</li> <li>一个名为<code>ParamLength</code>的函数，它可能返回轨迹的参数长度。</li> <li>一个名为<code>ToString</code>的函数，此函数可能将类的实例转化为字符串表达形式。</li> <li>一个名为<code>Evaluate</code>的函数，此函数会评估某个时刻的轨迹参数。</li> </ul> <p>类同时还包含以下私有成员变量:</p> <ul> <li><code>init_s_</code>，代表初始位置。</li> <li><code>init_v_</code>，代表初始速度。</li> <li><code>deceleration_</code>，代表减速度。</li> <li><code>end_t_</code>，可能代表结束时间。</li> <li><code>end_s_</code>，可能代表结束位置。</li> </ul> <p>此外，类还包含四个私有辅助函数 <code>Evaluate_s</code>、<code>Evaluate_v</code>、<code>Evaluate_a</code> 和 <code>Evaluate_j</code>，这四个函数可能用于评估某个时刻的位移、速度、加速度和跃度(jerk)。</p> <h5>piecewise_acceleration_trajectory1d.h</h5> <p>这是一个名为PiecewiseAccelerationTrajectory1d的C++类定义文件，包含在Apollo自动驾驶系统的规划模块之中，主要用于处理一维的分段加速运动轨迹。</p> <p>该类从Curve1d类继承，定义了一组公共、私有方法和私有数据成员。</p> <p>公共方法包括构造函数、析构函数、向轨迹中追加和删除分段的方法(AppendSegment和PopSegment)、求取参数长度的方法(ParamLength)、将信息转为字符串的方法(ToString)以及两种求取某时间点特定阶数的轨迹值和多阶导数的方法(Evaluate)。</p> <p>私有方法包括对于不同阶数（速度、加速度、跃度）求取某一时间点的轨迹值的方法（Evaluate_s，Evaluate_v，Evaluate_a，Evaluate_j）。</p> <p>私有数据成员包括存储分段累积距离、速度、时间和加速度的向量s<em>、v</em>、t<em>、a</em>。</p> <h5>piecewise_trajectory1d.h</h5> <p>这个文件是Apollo自动驾驶系统的一部分，特别是它的规划模块。文件名为&quot;piecewise_trajectory1d.h&quot;，它实现了一个名为 PiecewiseTrajectory1d的类，这个类代表一维空间中的分段轨迹。</p> <p>这个类体积从Curve1d类，这意味着它含有该类的所有特性，并且可能覆盖或添加一些功能。特别地，PiecewiseTrajectory1d类提供了若干方法来处理轨迹段（例如，添加一个新的轨迹段，删除最后一个轨迹段，获取轨迹段的数量等）。</p> <p>这个类还提供了一些方法来评估轨迹在给定参数处的值（Evaluate方法），获取参数的长度（ParamLength方法），或者将轨迹转换为字符串表示（ToString方法）。</p> <p>此文件是以.h文件，这意味着它是一个头文件，提供了这个类的接口定义。函数体或者说实现部分应该在相应的.cpp文件中找到。</p> <h5>constant_jerk_trajectory1d.h</h5> <p>该文件是Apollo自动驾驶系统源代码的一部分，属于planning模块中的&quot;constant_jerk_trajectory1d&quot;组件。这个组件表现了一个一维常加速度(jerk)轨迹，也就是描述一个物体在某一方向上以恒定的加速度移动的轨迹。</p> <p>ConstantJerkTrajectory1d类是继承自Curve1d类的子类，包含了一些私有成员变量，如起始位置(p0<em>)、起始速度(v0</em>)、起始加速度(a0<em>)、结束位置(p1</em>)、结束速度(v1<em>)、结束加速度(a1</em>)、参数时间值(param<em>)以及常加速度值(jerk</em>)。除默认的析构函数外，它定义了许多公共成员函数，用于估算在某一时间点各阶导数的值、获得初始和结束位置、速度、加速度等状态的具体值，以及将当前对象状态转化为字符串等。</p> <h4>utils</h4> <h5>print_debug_info.h</h5> <p>这个文件被称为 &quot;print_debug_info.h&quot;，它是一个C++的头文件。其主要功能是打印调试信息，所包含的代码主要与Apollo自动驾驶系统的计划模块中的调试信息呈现相关联。</p> <p>文件中定义了三个类——PrintPoints、PrintCurves、PrintBox。</p> <ul> <li>PrintPoints类用于表示要打印的点的集合。它有一个ID以及一组点，可以添加新的点，并且可以将所有的点打印到日志上。</li> <li>PrintCurves类持有一个映射，其键是字符串（指定的曲线的名字），值为PrintPoints对象。这个类可以添加新的点到特定的曲线，同时也可以将所有的曲线打印到日志上。</li> <li>PrintBox类用于表示要打印的盒的集合。它有一个ID和一组盒子点，可以添加新的盒子点，并且可以将所有的盒子点打印到日志上。</li> </ul> <p>以上的类都包含了打印函数打印自身相关数据到日志中，用于调试。</p> <h5>util.h</h5> <p>这是一个头文件（.h）相关于Apollo自动驾驶项目。该文件定义了在&#8217;apollo::planning::util&#8217;命名空间中的多个函数，大部分函数似乎与车辆状态、道路情况以及规划相关。</p> <p>常用的类和数据结构也在头文件中引用，如VehicleState, PlanningCommand, ReferenceLineInfo，等等，它们分别从&quot;modules/common/vehicle_state/proto/vehicle_state.pb.h&quot;，&quot;modules/common_msgs/planning_msgs/planning_command.pb.h&quot;以及&quot;./planning_base/common/reference_line_info.h&quot;中引入。</p> <p>此外，头文件还使用了一些boost库（具体为filesystem和range）的功能以支持对文件和文件系统的处理。</p> <p>文件的主要功能是进行路径规划，包括判断车辆状态是否有效，两条路径是否存在差异，获取自动驾驶汽车的停止减速度，检查参考线上是否有停车标志和交通灯，计算参考线上的等效自车宽度等。</p> <p>这是一个开源文件，使用Apache 2.0许可证，除非法律要求或书面同意，否则在“原样”基础上分发，没有任何明示或暗示的保证或条件。许可证还规定了权利的限制和许可的规定等。</p> <h5>config_util.h</h5> <p>这个文件定义了一个ConfigUtil类，位于apollo::planning命名空间。此类被用于处理与planning模块配置相关的操作。它有几个静态方法：</p> <ol> <li> <p><code>TransformToPathName</code>: 将提供的名字转换为路径名的一部分，全部转为小写。</p> </li> <li> <p><code>GetFullPlanningClassName</code>: 通过将提供的类名和&quot;&#8217;apollo::planning::&#8217;&quot;结合，来创建那个类的一个实例。</p> </li> <li> <p><code>LoadMergedConfig</code>: 该方法加载配置并将默认和用户定义的配置进行合并。</p> </li> <li> <p><code>LoadOverridedConfig</code>: 加载配置并用用户定义的配置覆盖默认配置。无法找到用户定义的配置时，使用默认配置。</p> </li> </ol> <p><code>ConfigUtil</code>类主要是用于配置文件的加载，合并和覆盖，以及将提供的名字或者类名进行转换处理。</p> <h5>math_util.h</h5> <p>源代码文件位于路径“./planning_base/common/util/”，文件名为“math_util.h”。这个头文件属于 Apollo 项目，在Apache License 2.0下发行。它在&quot;apollo&quot;命名空间下定义了一个&quot;planning&quot;命名空间，然后在这个命名空间中又定义一个&quot;util&quot;命名空间。</p> <p>此文件中定义了两个数学计算相关的函数：</p> <ol> <li> <p>WorldCoordToObjCoord：此函数的主要用途是将世界坐标转换为相对于特定障碍物的相对坐标，接收三个参数（输入的世界坐标，特定障碍物的世界坐标，特定障碍物的世界角度）。输出是一个双精度的坐标对。</p> </li> <li> <p>WorldAngleToObjAngle：此函数用来将世界角度转换为相对于特定障碍物的角度，输入包括（输入的世界角度，特定障碍物的世界角度）。输出是一个双精度的角度值。</p> </li> </ol> <p>这两个函数可能用于自动驾驶规划，在处理路上障碍物时非常有用。</p> <h5>evaluator_logger.h</h5> <p>这个文件是关于Apollo项目中的一个模块的头文件。具体来说，它描述了一个<code>EvaluatorLogger</code>类，位于<code>apollo::planning</code>命名空间中。这个类包含一个静态方法<code>GetStream()</code>，这个方法在被调用时会返回一个指向特定日志文件（&quot;output_data_evaluated.log&quot;）的输出文件流，这个日志文件存放在由全局标志 <code>FLAGS_planning_data_dir</code> 定义的目录中。这将允许Apollo项目的其他部分来写入这个日志文件。在编程实践中，日志文件通常用于记录程序运行时的各种事件，以便后续进行调试或性能优化。</p> <h5>common.h</h5> <p>这是一个C++头文件，位于Apollo项目的规划模块的公共实用程序目录下。Apollo是一款自动驾驶软件。共有两个函数，都是名为 &quot;BuildStopDecision&quot; 的函数重载提供停车决策的功能。</p> <p>函数接收一系列输入来决定车辆应停止的位置和原因。函数使用的参数包括：</p> <ol> <li>要停止的墙ID和/或车道ID以及沿参照线的距离。</li> <li>除非特定的障碍物被清除，否则车辆应保持停止。</li> <li>停止的理由。这可能是在交通灯变成红色、前面有其他车辆或者线路上存在障碍物等情况下发出的决定。</li> <li>&quot;Frame&quot; 类和 &quot;ReferenceLineInfo&quot; 类的对象，它们可能包含车辆的当前状态和环境信息。</li> </ol> <p>此文件是Apache 2.0许可下的开源项目，由Apollo作者所有并保留其所有权利。除非适用法律要求或书面同意，否则可以以&quot;原样&quot;的基础下的软件发布，无需任何明示或暗示的保证或条件。</p> <h3>gflags</h3> <h4>planning_gflags.h</h4> <p>这是一个定义了许多全局标志（gflags）的C++头文件，其中的全局标志用于控制项目中不同模块的参数。标志是在命令行上行为的参数，通常产生程序行为的变化。</p> <p>文件包含的全局标志大致可以归类为以下几种类型：</p> <ol> <li>历史记录数量相关的参数，例如 <code>history_max_record_num</code> 和 <code>max_frame_history_num</code></li> <li>车辆行为与规划相关的参数，包括开关控制器参数、线路参考参数、轨迹规划参数等。</li> <li>全局系统参数，例如 <code>planner_config_path</code>， <code>smoother_config_filename</code> 等，这些参数控制系统的各项配置。</li> <li>性能调整参数，例如 <code>enable_multi_thread_to_add_obstacles</code>，<code>num_velocity_sample</code> 等，这些参数控制系统的性能调整。</li> <li>学习相关的参数，例如 <code>planning_offline_learning</code>，<code>planning_data_dir</code> 等参数控制系统的学习功能。</li> </ol> <p>这个文件是属于Apollo自动驾驶系统的一部分，涵盖了自动驾驶过程中的各种情况，例如交通规则、轨迹规划、障碍物处理、车辆行驶模式等。用户可以通过修改对应的gflag来调整系统行为。</p> <h3>learning_based</h3> <h4>img_feature_renderer</h4> <h5>birdview_img_feature_renderer.h</h5> <p>这是一个名为BirdviewImgFeatureRenderer的头文件，定义了一个类，用于构建和处理机器学习项目中的图像特征。这个类是Apollo项目（这是一个开源的自动驾驶平台）的一部分，特定用途是在&quot;bird&#8217;s eye view&quot;(即俯视图)中进行图像处理和特征的生成。</p> <p>为了实现这一目标，这个类提供了以下一些主要方法：</p> <ul> <li><code>Init()</code>：初始化渲染器的方法。</li> <li><code>Render*()</code>：这是一组方法，用于通过各种方式如生成多通道、BGR、当前自我状态等的图像，渲染输入特征。</li> <li><code>RenderLocal*Map()</code>：这又是一组方法，用于渲染本地道路图和速度限制图，它们采用车辆的当前坐标和朝向作为输入来进行渲染。</li> <li><code>LoadRoadMap()</code>和<code>LoadSpeedlimitMap()</code>：这些方法用于加载rgb道路地图和rgb道路速度限制地图。</li> <li><code>CropByPose()</code>和<code>GetPointImgIdx()</code>：这两个方法用来裁剪以特定姿态生成的图像，并获取图像中单独点的索引。</li> <li><code>RenderEgo*()</code>：这种方法用于生成渲染图像，其中包括当前点、方框、过去的点等通过车辆自我以特定颜色高亮显示。</li> </ul> <p>此外，类还包含一些私有成员变量，如道路地图、速度限制图、egoc车辆配置、精神语义地图配置等。这些变量提供了在处理图像特征时所需的重要环境信息和配置设定。</p> <h4>model_inference</h4> <h5>trajectory_imitation_libtorch_inference.h</h5> <p>这个文件是 Apollo 自动驾驶系统中的一个部分，它定义了一个名为 &quot;TrajectoryImitationLibtorchInference&quot; 的类，这个类是 ModelInference 类的子类。这个类用于加载和推断基于学习的轨迹模型。</p> <p>该类包含以下公共方法：</p> <ul> <li>构造函数和析构函数</li> <li>GetName：返回模型推理名的函数</li> <li>LoadModel：加载学习型模型的函数</li> <li>DoInference：执行学习模型的推理</li> </ul> <p>类中还包含以下私有方法，以支持对特定类型的模型进行加载和推理：</p> <ul> <li>LoadCNNModel：加载 CNN 模型的方法</li> <li>LoadCNNLSTMModel：加载 CNN_LSTM 类型模型的方法</li> <li>DoCNNMODELInference：执行 CNN 模型的推理</li> <li>DoCNNLSTMMODELInference：执行 CNN_LSTM 类型模型的推理</li> <li>output_postprocessing：对模型轨迹输出进行后处理的方法</li> </ul> <p>该类包含两个私有成员变量，一个是表示加载模型的 &quot;model<em>&quot;，另一个是表示目标执行设备的 &quot;device</em>&quot;。</p> <p>这个头文件包括 LibTorch（PyTorch 的 C++ 前端）相关的包，用于执行加载和推理模型的操作。最后，该代码中使用了命名空间 <code>apollo::planning</code>，以组织代码并避免命名冲突。</p> <h5>model_inference.h</h5> <p>这是一个在Apollo计划中定义的基于学习的模型推断的基类。文件路径是在“./planning_base/learning_based/model_inference”目录下的头文件：&quot;model_inference.h&quot;。</p> <p>此类名为&quot;ModelInference&quot;，它有公开和保护的部分：</p> <p>在公开部分：</p> <ul> <li>定义了一个带参数的构造函数，参数类型为<code>LearningModelInferenceTaskConfig</code>，用于初始化配置。</li> <li>定义了一个虚析构函数，表明此类可能被用作基类。</li> <li>定义了3个纯虚函数：&quot;GetName&quot;用于获取模型推断的名称，&quot;LoadModel&quot;用于加载已学习的模型，&quot;DoInference&quot;用于推断已学习的模型。</li> </ul> <p>在保护的部分：</p> <ul> <li>定义了一个受保护的数据成员&quot;config_&quot;，类型为<code>LearningModelInferenceTaskConfig</code>，这应该是用来保存模型推断的配置信息。</li> </ul> <p>此代码应该是一个接口类的定义，需要被继承并实现其纯虚函数以进行具体的模型推断操作。</p> <h4>pipeline</h4> <h5>evaluator.h</h5> <p>这是Apollo自动驾驶项目的一部分，指定文件是一个名为Evaluator的类的头文件，它属于Apollo的planning模块之中的learning_based的pipeline部分。</p> <p>在Evaluator类里：</p> <ul> <li>提供了公有方法Init()和Close()，尚未实现。</li> <li>提供了一个名为Evaluate的公有方法，其参数是一个源文件名，此方法也未实现详情。</li> <li>提供了一个名为WriteOutData的私有方法，用于写出数据（有两个参数：源文件名和learning数据），此方法也没有具体实现。</li> <li>还定义了三个私有成员变量：start<em>time</em>（在算法开始时记录时间），learning_data_和trajectory<em>evaluator</em>。</li> </ul> <p>请注意，此头文件并未展示所有方法的具体实现，需要关注对应的源文件（cpp文件）才能得知具体实现。</p> <h4>tuning</h4> <h5>autotuning_feature_builder.h</h5> <p>该文件是Apollo项目的一部分，这是一个自动驾驶平台。此文件在<code>planning</code>模块的<code>learning_based/tuning</code>子模块中。这个模块似乎是用于学习和调优的。</p> <p>文件中定义了一个名为<code>AutotuningFeatureBuilder</code>的类，这个类的目的是从原始特征生成器构建模型相关的输入特征。它提供了两个虚拟函数，分别供用户实现如何构建特征和构建点特征。这些函数会获取原始特征作为输入，生成模型输入特征作为输出。</p> <p>这个类也包含一个构造函数和一个析构函数，但它们没有被确切地实现，仅设置为默认值。</p> <p>我们还可以看到文件包含<code>http://www.apache.org/licenses/LICENSE-2.0</code>，这是一个除非另有规定或书面确认，否则软件将按照&quot;原样&quot;的基础进行分发，不提供任何类型的明示或暗示的保证或条件的Apache 2.0许可。</p> <h5>autotuning_raw_feature_generator.h</h5> <p>这个文件是Apollo自动驾驶系统中一个C++头文件，定义了一个名为<code>AutotuningRawFeatureGenerator</code>的类，这个类用于生成自动调优的原始特征。它位于<code>./planning_base/learning_based/tuning</code>目录下，应用于路径规划模块中基于学习的调优任务。</p> <p><code>AutotuningRawFeatureGenerator</code> 类提供了一些方法来评估轨迹和轨迹点，并生成相应的原始特征。该类还用来处理速度规划。评估方法包括：</p> <ul> <li><code>EvaluateTrajectory</code>：评估轨迹，并生成模型轨迹特征。</li> <li><code>EvaluateTrajectoryPoint</code>：评估轨迹点，并生成模型轨迹点特征。</li> <li><code>EvaluateSpeedProfile</code>：评估速度规划，生成轨迹特征。</li> </ul> <p>此外，还有一些类内部用的私有方法，如处理ST边界(<code>GenerateSTBoundaries</code>)，转换离散边界(<code>ConvertToDiscretizedBoundaries</code>)，和评估速度点(<code>EvaluateSpeedPoint</code>)。</p> <p>该文件依赖于Apollo的通用消息、规划基类、引用线信息和速度限制等模块。</p> <h5>autotuning_base_model.h</h5> <p>该源代码文件定义了一个名为<code>AutotuningBaseModel</code>的C++类，该类属于Apollo项目的规划(planning)模块中，更具体的说，它属于该规划模块的子模块自动调优(autotuning)。</p> <p><code>AutotuningBaseModel</code>类提供了一个用于自动调优的基本模型。它是一个纯虚类（也叫抽象基类），该类定义额一些虚函数（<code>SetParams</code>, <code>Evaluate</code>）没有实现，这意味着该类被设计为用来派生其他类。</p> <p>类中有两个主要的虚函数，<code>SetParams</code>没有任何参数，返回一个<code>common::Status</code>类型的状态，另一个<code>Evaluate</code>函数有两个重载版本，一个接受一个<code>autotuning::TrajectoryFeature</code>参数，另一个接受一个<code>autotuning::TrajectoryPointwiseFeature</code>参数，这两个函数都返回一个double类型的奖励/代价的总值。</p> <p>在保护成员(protected)中，该类声明了两个独特的指针(unique_ptr)，分别用于存储自动调优的感知机模型(MLPModel)和特性构建器(FeatureBuilder)。</p> <h5>autotuning_mlp_net_model.h</h5> <p>这个文件是一个C++的头文件，定义了一个名为&quot;AutotuningMLPModel&quot;的类。这个类是&quot;prediction::network::NetModel&quot;的派生类，是对神经网络模型进行自动调整的具体实现。</p> <p>其主要方法是&quot;Run&quot;，该方法通过一系列定义好的层对输入数据进行处理，并生成网络的输出。输入是一个Eigen库中MatrixXf类型的向量（这种类型通常用于表示具有任意大小的浮点矩阵），而输出则以指针形式返回，同样是一个MatrixXf类型的对象。</p> <p>类的定义在&quot;apollo&quot;的&quot;planning&quot;命名空间中，提示该类可能被用于赛车的路径规划或者某种预测模型的调整和优化。</p> <h5>speed_model</h5> <h6>autotuning_speed_mlp_model.h</h6> <p>这是一个名为&quot;autotuning_speed_mlp_model.h&quot;的头文件，它是Apollo自动驾驶软件的一部分。此文件包含一个名为<code>AutotuningSpeedMLPModel</code>的类，该类公开了车辆规划过程中用作速度模型微调（autotuning）的多层感知机(MLP)模型的定义。</p> <p><code>AutotuningSpeedMLPModel</code>类继承自<code>AutotuningBaseModel</code>类，主要包括四个公开的方法以及两个私有的方法:</p> <ol> <li> <p><code>SetParams()</code>：设定多层感知机模型的参数。</p> </li> <li> <p><code>Evaluate()</code>：这是一个被重载的方法，其主要目标是通过输入的轨迹特征或轨迹点特征来评估速度模型。</p> </li> <li> <p><code>FlattenFeatures()</code>：这也是一个被重载的方法，它用于将给定的轨迹特征或速度点特征展平为Eigen矩阵。</p> </li> </ol> <p>类的默认构造函数和析构函数也在此定义。复制操作和移动操作可能默认生成或被禁止（这取决于基类）。</p> <p>需要注意的是，所有的函数都在命名空间<code>apollo</code>和<code>planning</code>中，该头文件包含的Apollo开源代码的版权信息。</p> <h6>autotuning_speed_feature_builder.h</h6> <p>这个文件是Apollo自动驾驶系统的一部分，它位于模块规划（.）的子目录中。具体来说，它在学习基础调整（Learning-Based Tuning）的速度模型（Speed Model）子目录中。它定义了一个名为<code>AutotuningSpeedFeatureBuilder</code>的类，该类用于构建基于轨迹的速度配置文件的多层感知机（MLP）成本函数。</p> <p>这个类从<code>AutotuningFeatureBuilder</code>类中派生，重写了两个方法：<code>BuildFeature</code>和<code>BuildPointFeature</code>，它们分别用于从原始特征生成模型输入特征，和从点对点的原始特征生成模型输入特征。</p> <p>此文件中还定义了一些私有方法，如<code>map_obstacle_feature</code>，<code>map_nudge_obs_feature</code>和<code>map_sidepass_obs_feature</code>，它们是用来处理不同类型的障碍特征到模型输入特征的映射。</p> <h3>math</h3> <h4>discrete_points_math.h</h4> <p>这个文件是Apollo自动驾驶系统中的一部分，位于模块&quot;planning&quot;的子目录&quot;math&quot;中。文件名为&quot;discrete_points_math.h&quot;，这是一个C++头文件。它定义了一个类 <code>DiscretePointsMath</code>，这个类只提供了一个静态方法 <code>ComputePathProfile</code>。</p> <p>这个方法接受一个由成对的double类型数值组成的向量（代表xy点），并处理四个输出向量，通过引用返回。这四个向量分别表示headings, accumulated_s, kappas和dkappas。</p> <p>注意，这个类的构造函数被删除，这表明它并不意味着实例化，因此其所有的成员函数都应被设计为静态。</p> <p>该源代码的许可证是Apache 2.0许可，该许可允许在满足某些条件下的使用和分发。</p> <p>根据文件路径和命名，此文件可能与路径规划和离散点的数学运算有关。</p> <h4>curve_math.h</h4> <p>这个文件 <code>curve_math.h</code> 是 Apollo 自动驾驶项目的一部分，主要用于规划模块的数学计算。</p> <p>该文件定义了一个名为 <code>CurveMath</code> 的类，包含静态函数 <code>ComputeCurvature</code> 和 <code>ComputeCurvatureDerivative</code>，它们分别用于计算曲线的曲率和曲率的导数。曲线被表示为 X = (x(t), y(t)) 其中 t 是任意参数。这些计算用于自动驾驶车辆的路径规划。</p> <p><code>curve_math.h</code> 包含在 <code>apollo</code> 的 <code>planning</code> 命名空间中，使得其他模块可以方便的调用它的函数。请注意，这个类的构造函数被删除，表明这个类不能被实例化，这是因为它所有的函数都是静态的。</p> <h4>polynomial_xd.h</h4> <p>这个文件名是&quot;polynomial_xd.h&quot;，它是一个C++头文件。文件位于./planning_base/math目录下，应是一个关于规划系统中的数学处理模块。</p> <p>它声明了一个名为&quot;PolynomialXd&quot;的类，主要用于处理多项式的相关操作。PolynomialXd类中有公共方法和私有变量：</p> <p>调用这个类可以实现以下功能：</p> <ul> <li>构建一个空的多项式或者一个指定阶数或者指定参数的多项式（<code>PolynomialXd()</code>，<code>PolynomialXd(const std::uint32_t order)</code>，<code>PolynomialXd(const std::vector&lt;double&gt;&amp; params</code>)；</li> <li>获取该多项式在指定点的值（<code>operator()(const double value)</code>）；</li> <li>获取多项式某个指数的参数值（<code>operator[](const std::uint32_t index)</code>）；</li> <li>设置该多项式的参数（<code>SetParams(const std::vector&lt;double&gt;&amp; params</code>)）。</li> </ul> <p>类还包含静态方法来实现多项式的导数和积分（DerivedFrom(const PolynomialXd&amp; base)、IntegratedFrom(const PolynomialXd&amp; base, const double intercept = 0.0)）。</p> <p>在私有部分，类维护了一个类型为<code>MARKDOWN_HASH112eef01d34b4f0ecfbd48580c9c625dMARKDOWN<em>HASH</code>的私有成员变量params</em>，用于保存多项式的参数。</p> <h4>constraint_checker</h4> <h5>constraint_checker.h</h5> <p>此文件是Apollo自动驾驶软件系统中用于检查轨迹是否满足约束条件的模块。文件路径表明它位于 planning 模块的 math 子模块下，主要用于数学计算。</p> <p>文件定义了一个名为 ConstraintChecker 的类，这应该是约束条件检查器。这个类不能被实例化，因为其默认构造函数被删除。所有的功能都通过静态函数 ValidTrajectory 来提供，用以检查给定的离散轨迹是否有效。</p> <p>在 ConstraintChecker 类中，定义了一个枚举类型 Result，用于表示轨迹的有效性情况，如 longitudinal/lateral 速度、加速度、急停以及曲率是否超出规定的范围。</p> <h5>constraint_checker1d.h</h5> <p>这是一个声明性的头文件，名为<code>constraint_checker1d.h</code>，位置在./planning_base/math/constraint_checker里。它是Apollo开源自动驾驶项目的一部分，用于定义一个类 <code>ConstraintChecker1d</code>，此类主要功能是检查给定的轨迹是否有效。</p> <p>在<code>ConstraintChecker1d</code>类中，定义了两个静态方法：第一个是<code>IsValidLongitudinalTrajectory</code>, 该方法采用一个<code>Curve1d</code>类型的参数，用于检查纵向轨迹的有效性；第二个方法是<code>IsValidLateralTrajectory</code>, 采用两个<code>Curve1d</code>参数，一个表示横向轨迹，一个表示纵向轨迹，用于检查横向轨迹的有效性。</p> <p>这个文件包含了Apache 2.0许可证，这意味着你可以自由使用、修改和分发这段代码，但你需要遵循相应的条款和条件。</p> <h4>curve1d</h4> <h5>quartic_polynomial_curve1d.h</h5> <p>这是一个C++的头文件，定义了名为<code>QuarticPolynomialCurve1d</code>的四次多项式曲线类，它继承自<code>PolynomialCurve1d</code>类。<code>QuarticPolynomialCurve1d</code>类里定义了一些功能做为构建和操作四次多项式曲线的元素。</p> <p>关键功能包括：</p> <ul> <li>构造函数：类似于默认构造函数，开始结束点条件构造函数，及拷贝构造函数。</li> <li><code>Evaluate</code>：用于评估四次多项式在某点的值。</li> <li><code>FitWithEndPointFirstOrder</code>和<code>FitWithEndPointSecondOrder</code>：分别用于满足终点一阶和起点二阶及终点二阶和起点一阶的边界条件，优化四次多项式。</li> <li><code>IntegratedFromCubicCurve</code> 和 <code>DerivedFromQuinticCurve</code>：分别用于生成一条基于一个三次曲线对应的四次曲线，并为指定的初始值生成积分；及生成一条基于五次曲线的四次曲线的导数。</li> <li>一些getter和helper方法：<code>ToString</code>，<code>Coef</code>，<code>Order</code>，<code>ParamLength</code>。</li> </ul> <p>此外，此类还定义了一些私有数据成员用以存储四次多项式的系数、开始条件和结束条件。</p> <h5>curve1d.h</h5> <p>这是一个C++头文件，名为&quot;curve1d.h&quot;。它位于&quot;./planning_base/math/curve1d&quot;的目录中，这个路径提示它是有关车辆路径规划模块中1D曲线计算的一部分。它是Apollo项目的一部分，开源自动驾驶技术平台Apollo由百度开发。</p> <p>此文件定义了一个名为&quot;Curve1d&quot;的基类，类中声明了几个纯虚函数，包括Evaluate、ParamLength和ToString。这些函数都被设置为了0，表示它们是纯虚函数，具体实现将由派生类提供。这个类可能被用作多态的基类。其中，Evaluate函数用于评估参数，在指定的顺序和参数下，此处的返回类型设为了double。ParamLength函数返回参数长度。ToString函数是一个常见的方法，用于返回类的字符串表示。所有这些方法都被声明为const，意味着它们不会修改类的对象状态。</p> <h5>polynomial_curve1d.h</h5> <p>该文件是 Apollo 自动驾驶系统项目中的一部分，具体位于&quot;./planning_base/math/curve1d&quot;目录下。文件名为 &quot;polynomial_curve1d.h&quot;，它是一个头文件，定义了一种名为 &quot;PolynomialCurve1d&quot; 的多项式曲线类，此类从 &quot;Curve1d&quot; 类进行派生。</p> <p>&quot;PolynomialCurve1d&quot; 类中包含两个虚函数 &quot;Coef&quot; 和 &quot;Order&quot;，这两个函数在具体的实现中需要被重写。函数 &quot;Coef&quot; 接收一个 size_t 类型的参数 &quot;order&quot;，并返回一个 double 类型的值，函数 &quot;Order&quot; 不接受参数并返回一个 size_t 类型的值。</p> <p>此外，该类还包含一个受保护的成员变量 &quot;param_&quot;，其初始值为0.0， 可能会在具体的算法实现中使用。</p> <p>该文件中的内容都被封装在 &quot;apollo::planning&quot; 命名空间中，表明它是 Apollo 自动驾驶系统中，规划模块的一部分。</p> <h5>cubic_polynomial_curve1d.h</h5> <p>这是一个名为&quot;cubic_polynomial_curve1d.h&quot;的C++头文件，属于Apollo自动驾驶系统中的&quot;planning&quot;模块的一部分。在这个文件中，定义了一个名为&quot;CubicPolynomialCurve1d&quot;的类，该类是&quot;PolynomialCurve1d&quot;的子类，代表了在1D空间中的三次多项式曲线。</p> <p>&quot;CubicPolynomialCurve1d&quot;类包含了一个私有的4元素数组&quot;coef_&quot;（用于存储三次多项式的系数）、一个3元素数组&quot;start<em>condition</em>&quot;（用于存储起始条件）、以及一个双精度浮点数&quot;end<em>condition</em>&quot;（用于存储结束条件）。此外，该类提供了以下公开功能：</p> <ol> <li>构造函数：创建一个CubicPolynomialCurve1d对象。</li> <li>&quot;DerivedFromQuarticCurve&quot;：从四次多项式曲线中派生。</li> <li>&quot;Evaluate&quot;：评估指定阶数和参数的值。</li> <li>&quot;ParamLength&quot;：获取参数的长度。</li> <li>&quot;ToString&quot;：将对象转为字符串。</li> <li>&quot;Coef&quot;：获取指定阶数的系数。</li> <li>&quot;Order&quot;：获取阶数。</li> </ol> <p>私有功能：</p> <ol> <li>&quot;ComputeCoefficients&quot;：计算三次多项式的系数。</li> </ol> <h5>quintic_spiral_path_with_derivation.h</h5> <p>这个文件是Apollo自动驾驶系统的一部分，具体在规划模块中的路径规划部分。此文件定义并实现了一个用于路径规划的类，名为QuinticSpiralPathWithDerivation。</p> <p>该类是模块下的一部分，用于计算使用五次多项式（quintic polynomial）定义的螺旋路径（spiral path）。五次多项式常用于运动规划，因为它们可以定义起始和终止点的位置、速度和加速度。</p> <p>该类以模板的形式定义，可以适用于不同的精度。类的方法主要用于计算路径的各项导数以及路径上的点到目标位置之间的偏差。</p> <p>这个类被设计为可重用组件，可以被其他部分的Apollo代码所引用。从整个项目的角度来说，此文件是Apollo对车辆规划和执行路径的方法的一部分。</p> <h5>quintic_spiral_path.h</h5> <p>文件&quot;quintic_spiral_path.h&quot;定义了一个名为&quot;QuinticSpiralPath&quot;的类。该类是&quot;QuinticPolynomialCurve1d&quot;的子类，并且被用来描述一个五次螺旋路径。这种路径能够将(起始角度，起始曲率，起始曲率导数)映射到(终止角度，终止曲率，终止曲率导数)。</p> <p>&quot;QuinticSpiralPath&quot;类中定义了几个方法，包括计算笛卡尔偏差X和Y(&quot;ComputeCartesianDeviationX&quot;和&quot;ComputeCartesianDeviationY&quot;)，获取笛卡尔偏差的导数(&quot;DeriveCartesianDeviation&quot;)，以及对曲率导数、曲率二阶导数和角度进行导数处理的方法。此外，还定义了一些静态常量用于表示参数索引，例如&quot;THETA0&quot;、“KAPPA1”、&quot;DELTA_S&quot;等。</p> <p>引用的头文件主要包括一些用于计算的公共数学库，如&quot;angel.h&quot;和&quot;integral.h&quot;。</p> <h5>quintic_polynomial_curve1d.h</h5> <p>这个文件是属于Apollo源代码的一部分。Apollo是一个开源的自动驾驶系统。特定地说，这个文件定义了一个名为“QuinticPolynomialCurve1d”的类，这个类被用于在一维空间中创建和操作一个五次多项式曲线。</p> <p>这个类继承于&quot;PolynomialCurve1d&quot;，包含了几个重载的公有方法，如评估函数(&#8216;Evaluate&#8217;)、参数长度(&#8216;ParamLength&#8217;)、获取指定阶数的系数(&#8216;Coef&#8217;)以及返回多项式曲线订单(&#8216;Order&#8217;)等。</p> <p>类中还定义了一些私有变量，如<code>coef_</code>来存储五次多项式的系数，<code>start_condition_</code> 和 <code>end_condition_</code> 分别来存储五次多项式在起始和结束位置的状态。还有一些构造函数和设置参数的函数，允许从不同的方式来构建这个五次多项式曲线。</p> <h5>piecewise_quintic_spiral_path.h</h5> <p>这个文件是Apollo项目中的一部分，位于./planning_base/math/curve1d/目录下，命名为piecewise_quintic_spiral_path.h。这是一个C++头文件，定义了一个名为PiecewiseQuinticSpiralPath的类，它是Curve1d类的子类。此类表示一条路径，该路径由单位分段的五次螺旋曲线组成。类的公共方法包括创建一条新的路径，追加新的曲线段，对路径进行评估和求导，获取参数长度以及返回类的字符串表示。此类还有一些私有变量来存储曲线段、距离累加数组以及最后一段的角度、曲率和曲率变化率。该文件被设计为可以被其他源文件引用，以使用此路径类。</p> <h4>discretized_points_smoothing</h4> <h5>fem_pos_deviation_sqp_osqp_interface.h</h5> <p>这个头文件是一个C++软件项目的一部分，项目属于Apollo项目的规划(planning)模块之一。标题文件定义了一个名为 <code>FemPosDeviationSqpOsqpInterface</code> 的类。</p> <p>这个类设定了一系列的成员变量和方法，主要用于描述和控制有限元法位置偏差最小化问题的求解过程。其中所涉及的问题类型为二次规划(Quadratic Programming, QP)问题, 使用开源软件库OSQP进行求解。</p> <p>在这个类中，有一些基本设置或状态，如引用点（ref<em>points</em>）、约束尺度(bounds_around<em>refs</em>)和曲率限制（curvature<em>constraint</em>）等参数。同时，为了控制优化过程中的不同方面，类也设定了OSQP求解器的各种设置，如迭代次数上限(max<em>iter</em>)、超时限制(time<em>limit</em>)、是否打印详细过程(verbose_)和是否启用预热的决策(warm<em>start</em>)等。</p> <p>此类中也包含解决具体问题的函数如Solve()函数以及一系列的辅助性私有函数用于处理QP问题的构建和求解。另外，还包含了一些设定和获取参数的公开方法。</p> <h5>cos_theta_smoother.h</h5> <p>这个文件是Apollo自动驾驶框架的一部分，位于模块（modules）中的规划（planning）的子模块中。文件的全名提示，它涉及到在规划过程中对一系列点的平滑处理。</p> <p>&quot;CosThetaSmoother&quot;是一个类，接收一个&quot;CosThetaSmootherConfig&quot;配置类的实例作为参数，这个配置文件定义了平滑器的行为。&quot;Solve&quot;方法接受一系列点（表示为double值对）和一组边界值，返回两个优化后的x和y坐标向量。根据方法名和参数，似乎该方法的作用是找到一种优化方法或方案，以尽可能地平滑地连接输入的一系列点。</p> <p>在代码中使用了&quot;#pragma once&quot;指令，这是一个常见的C++预处理器指令，用来避免头文件的多重包含。这个文件的主要作用就是为其它代码提供&quot;CosThetaSmoother&quot;类的定义。</p> <h5>fem_pos_deviation_osqp_interface.h</h5> <p>该文件是Apollo开源自动驾驶系统的一部分，位于./planning_base/math/discretized_points_smoothing目录下的fem_pos_deviation_osqp_interface.h文件。这个文件定义了一个名为FemPosDeviationOsqpInterface的类，用于实现有限元法 (FEM) 的位置偏差优化问题。</p> <p>类中定义的参数包括参考点、偏差界限、优化成本函数的权重、osqp设置，以及与优化问题定义和优化结果有关的参数。</p> <p>类的公共方法主要用于设置这些参数，以及调用Solve（）方法进行解决优化问题。私有方法包括计算核函数、计算偏移量、计算仿射约束等，这些都被用于解决优化问题。</p> <p>这个类主要用途可能是根据给定的参考点、偏差边界和权重，求解出最优的路径或者位置。</p> <h5>cos_theta_ipopt_interface.h</h5> <p>这个文件是Apollo自动驾驶项目内的一部分，具体来说它位于<code>./planning_base/math/discretized_points_smoothing/</code>目录下。</p> <p>文件名为 <code>cos_theta_ipopt_interface.h</code>，是一个C++头文件，定义了一个名为<code>CosThetaIpoptInterface</code>的类，这个类中包含的方法主要应用了Ipopt优化器进行优化实现。从类名可以推测，此文件主要用于实现将连续点离散化和平滑处理的算法，采用Ipopt接口优化。其中包含了计算约束、生成需求磁带、评估目标和梯度、Hessian结构等功能。</p> <p>此类继承了Ipopt的<code>TNLP</code>（The NLP（非线性规划）接口）类。这意味着，它使用了Ipopt库进行非线性规划以优化某些参数。MNLP接口是一个虚拟基类，用户必须提供实现该接口的类，以描述具体的优化问题。</p> <p>在类的成员变量中，它存储了参考点、边界、优化变量等信息。并且定义了一些验证方法，如评估目标、评估制约等。</p> <p>该文件还使用了ADOL-C（自动微分库），使用自动微分技术计算出优化问题的梯度和Hessian，这对于Ipopt优化来说是非常重要的。</p> <h5>fem_pos_deviation_smoother.h</h5> <p>这是一个名为<code>FemPosDeviationSmoother</code>的类的头文件。它是Apollo自动驾驶系统中的一部分，位于<code>./planning_base/math/discretized_points_smoothing</code>目录下。</p> <p>Google的开源自动驾驶汽车项目Apollo使用这个类来平滑一组初始点的位置。其目标是求解一个最优化问题，该问题的目标是找到一组新的点，从而使得从起始点通过这组点的路径更平滑。</p> <p>该类有以下公共方法：</p> <ol> <li><code>FemPosDeviationSmoother</code>：构造函数，需要一个<code>FemPosDeviationSmootherConfig</code>类型的参数。</li> <li><code>QpWithOsqp</code>：使用OSQP求解二次规划问题。</li> <li><code>NlpWithIpopt</code>：使用IPOPT求解非线性优化问题。</li> <li><code>SqpWithOsqp</code>：使用OSQP求解二次优化问题。</li> <li><code>Solve</code>：求解主函数，可以在没有给出点盒子的情况下调用上面的函数。</li> </ol> <p>这个类的私有变量包括一个<code>FemPosDeviationSmootherConfig</code>类型的<code>config_</code>。</p> <h5>fem_pos_deviation_ipopt_interface.h</h5> <p>这是一个 C++ 头文件，定义了一个名为 <code>FemPosDeviationIpoptInterface</code> 的类。该类很可能是实现了某种优化问题，特别是有关位置盖帽的问题，且采用离散点平滑和有限元方法（FEM）。类中的方法似乎使用了 Ipopt 库来求解问题。</p> <p>该类包含了一些公开的方法，如设置和获取优化结果的权重、获取优化问题的信息、边界和起始点、计算目标值的梯度、约束残差和雅可比矩阵等。它还使用了 ADOL-C 库来自动微分，并提供了几个与 ADOL-C 相关的函数，如 <code>eval_obj</code>,<code>eval_constraints</code> 和 <code>generate_tapes</code>。</p> <p>此外，该类还包含一些私有的数据成员，如参考点、偏移界限和一些优化权重。它还存储了优化问题的一些基本信息，如变量和约束的数量，雅可比和拉格朗日矩阵的非零元素数量以及一些索引。最后，它存储了优化的结果。</p> <p>该文件属于 Apollo 开源自动驾驶项目的一部分，具体处于规划模块的数学子模块中。</p> <h4>piecewise_jerk</h4> <h5>piecewise_jerk_problem.h</h5> <p>这个源代码文件是Apollo自动驾驶系统项目中的一部分，其中定义了一个名为PiecewiseJerkProblem的类。该类用于解决优化问题，目的是寻找一条使路线尽可能平滑的轨迹。</p> <p>类的成员变量主要包括：节点数量、输出的x/dx/ddx (位置、速度和加速度)、各种边界和权重参数等。</p> <p>成员函数主要包括：设置各种边界和权重、设置参考状态、进行优化、计算核、计算偏移、计算仿射约束、输出优化结果等。</p> <p>该类中的优化问题基于OSQP（Operator Splitting Quadratic Program）求解器来解决。</p> <h5>piecewise_jerk_path_problem.h</h5> <p>这个文件是一个C++头文件，定义了一个名为<code>PiecewiseJerkPathProblem</code>的类，这是Apollo自动驾驶系统计划模块中用于解决路径优化问题的一个关键部分。</p> <p><code>PiecewiseJerkPathProblem</code>类继承自<code>PiecewiseJerkProblem</code>类，目的是找出一系列的点，使得按照这些点组成的路径尽可能的&quot;平滑&quot;。</p> <p>在这个类中，有一些成员变量和函数：</p> <ol> <li> <p><code>InterPolatedPointVec extra_constraints_</code>和<code>ADCVertexConstraints vertex_constraints_</code>作为类的数据成员，用于储存额外的限制条件和顶点限制。</p> </li> <li> <p><code>CalculateKernel</code> 和 <code>CalculateOffset</code>都是Override基类中的虚函数，分别用于计算核矩阵和偏移。</p> </li> <li> <p><code>set_extra_constraints</code> 和 <code>set_vertex_constraints</code> 方法用于设置额外的限制条件和顶点限制。</p> </li> </ol> <p>该类是一个理想化的模型，用于解决一种 Piecewise Jerk（分段急变）路径问题，该问题源于有限元方法的一个优化问题。在自动驾驶路径规划中，这种类型的问题处理可以有效地平滑预测的路径，从而提供更安全、更有效的驾驶体验。</p> <h5>piecewise_jerk_speed_problem.h</h5> <p>此文件是Apollo自动驾驶系统的一部分，具体来说，它是规划模块的一部分，用于解决速度问题。它定义了一个名为<code>PiecewiseJerkSpeedProblem</code>的类，该类继承自<code>PiecewiseJerkProblem</code>类。</p> <p><code>PiecewiseJerkSpeedProblem</code>类描述了如何优化带有连续加速度的路径时间问题。它假设每两个时间点之间的差值相等。给定初始位置、速度和加速度，目标是找到一组时间点，使得从起点到所有这些时间点的路径平滑。</p> <p>该类的主要方法包括：</p> <ul> <li> <p><code>set_dx_ref</code>：两个重载函数，用于设置速度的参考值和相应的权重。</p> </li> <li> <p><code>set_penalty_dx</code>：设置加速度变化的惩罚权重。</p> </li> <li> <p><code>CalculateKernel</code>：计算OSQP求解器的核心矩阵。</p> </li> <li> <p><code>CalculateOffset</code>：用于计算OSQP求解器的偏移值。</p> </li> <li> <p><code>SolverDefaultSettings</code>：返回OSQP求解器的默认设定。</p> </li> </ul> <p>类中的成员变量主要包括有关速度变化的参考权重、参考值，以及加速度变化的惩罚权重等。</p> <h4>smoothing_spline</h4> <h5>osqp_spline_1d_solver.h</h5> <p>这个头文件定义了一个名为OsqpSpline1dSolver的类，该类是Spline1dSolver的子类。它是在Apollo（一款自动驾驶系统）的规划模块中用于1D样条曲线优化问题的求解器。OsqpSpline1dSolver利用开源的应用于求解二次规划问题的优化库OSQP（Operator Splitting Quadratic Program）。</p> <p>类提供了以下公有方法：</p> <ul> <li>构造函数：初始化样条曲线中的节点和阶数；</li> <li>重写的Solve方法：用于实际求解优化问题；</li> <li>CleanUp方法：用于清理类中创建的动态资源；</li> <li>ResetOsqp方法：用于重置OSQP优化器的设置和数据。</li> </ul> <p>私有成员主要是OSQP库的对象，例如settings_，work_和data_等。</p> <h5>spline_2d_constraint.h</h5> <p>这个源文件是Apollo自动驾驶系统项目的一部分，具体来说，它定义了一个名为Spline2dConstraint的类，该类是为了实施2D空间中样条曲线的约束。样条曲线是一种数学工具，被广泛地用于曲线和曲面的插值和建模。</p> <p>文件中定义了Spline2dConstraint类的多个方法，主要包括加入不等式约束和等式约束等。这些约束可以是点约束、边界约束或者某阶导数的约束。这样的设计是为了满足实际需求，比如在规划过程中需要考虑车辆的物理限制（如最大速度、最大加速度等），就可以通过这些约束来实现。</p> <p>代码中还涉及很多特有的数学方法，如二阶导数、三阶导数约束等，这需要一些线性代数和微积分知识来理解。</p> <p>总的来说，这个类是为了定义一个样条曲线，以及可以对其施加各式各样约束条件的工具。设计这个类的原因是因为在自动驾驶的路径规划中，路径是以样条曲线的形式表示的，为了让路径满足车辆的运动约束以及环境的限制，就需要用到这个类。</p> <h5>affine_constraint.h</h5> <p>文件名是<code>./planning_base/math/smoothing_spline/affine_constraint.h</code>，这是一个C++头文件。它定义了一个命名空间为&quot;apollo::planning&quot;的&quot;AffineConstraint&quot;类。</p> <p>&quot;AffineConstraint&quot;类包含以下内容：</p> <ul> <li> <p>私有成员变量：<code>Eigen::MatrixXd</code>类型的<code>constraint_matrix_</code>和<code>constraint_boundary_</code>，以及一个<code>bool</code>类型的<code>is_equality_</code>。</p> </li> <li> <p>公开的成员函数：</p> <ul> <li>一个默认构造函数 <code>AffineConstraint()</code>。</li> <li>一个带有一个布尔参数的构造函数 <code>AffineConstraint(const bool is_equality)</code>。</li> <li>一个带有三个参数的构造函数，参数包括两个<code>Eigen::MatrixXd</code>类型的<code>constraint_matrix</code>和<code>constraint_boundary</code>，以及一个<code>bool</code>类型的<code>is_equality</code>。</li> <li>一个名为<code>SetIsEquality(const double is_equality)</code>的方法，用于设置<code>is_equality_</code>的值。</li> <li>两个名为<code>constraint_matrix()</code>和<code>constraint_boundary()</code>的常函数，用于返回相应的私有成员变量的引用。</li> <li>一个名为<code>AddConstraint</code>的方法，带有两个<code>Eigen::MatrixXd</code>类型的参数，用于添加约束条件。</li> </ul> </li> </ul> <p>这个类通常用于处理包含线性等式和不等式约束的优化问题。</p> <h5>spline_seg_kernel.h</h5> <p>该文件是一个头文件，属于Apollo自动驾驶框架中的&quot;规划&quot;模块的一部分。文件中定义了一个名为<code>SplineSegKernel</code>的类，该类专门用于生成平滑样条(spline)的积分核心(integrated kernels)。</p> <p>该类中提供了一系列用于计算积分核、导数核、二阶导数核及三阶导数核的方法。这些方法根据输入的参数（包括参数数目和累积的X值）计算并返回相应的二维矩阵。</p> <p>同时还定义了关于积分项矩阵及对Fx（函数的值）、一阶导数、二阶导数和三阶导数进行计算的私有方法。</p> <p>此外，该类中还定义了一个为预留的阶数、和四个用于存储函数值、一阶导数值、二阶导数值、三阶导数值的二维矩阵。</p> <p>此文件基于Apache 2.0许可证发布，强调无任何明示或暗示的担保。</p> <h5>osqp_spline_2d_solver.h</h5> <p>这是一个头文件，定义了一个名为OsqpSpline2dSolver的类，这个类是Spline2dSolver的派生类。由于使用了&quot;final&quot;关键字，所以不能被进一步继承。</p> <p>该类是在Apollo自动驾驶系统中用于路径规划模块的数学处理的一部分。它使用开源库OSQP（Operator Splitting Quadratic Program），一个用于求解大型二次规划（QP）问题的库。</p> <p>在类的定义中有公共方法、私有方法和私有数据成员。公共方法包括一个构造器、一个重置方法、一些获取和设置Spline2D对象和其部件的方法、一个求解方法和一个提取Spline2D对象的方法。</p> <p>此外，文件中还显式地声明了一个用于测试的友元函数（基本测试）。在之后的测试实现中，这个函数能访问这个类的所有私有和保护成员。</p> <h5>spline_2d.h</h5> <p>这个文件是Apollo自动驾驶框架中，规划模块的一部分。文件路径显示它位于&quot;./planning_base/math/smoothing_spline&quot;目录中，文件名为&quot;spline_2d.h&quot;，这表明它的主要功能是处理二维样条拟合（smoothing spline）问题。</p> <p>在代码中，定义了一个Spline2d类，该类实现了在二维空间中对数据进行样条拟合的各种操作。该类具有一系列公有和私有方法，用于计算样条函数在特定点的值、导数、二阶导数和三阶导数，以及设置样条参数等。</p> <p>此外，这个类还有一个私有方法&quot;find_index&quot;用于找到给定值x在样条中的索引位置。该类还定义了存储样条片段和样条节点的向量以及样条的阶数私有成员。</p> <p>这个类依赖于其他的一些头文件，如Eigen库（用于进行线性代数运算），&quot;polynomial_xd.h&quot;（提供多项式的相关操作），和&quot;spline_2d_seg.h&quot;（提供二维样条线段的相关功能）。因此，我们可以想象，这个类在Apollo自动驾驶系统中，可能用于处理各种与路径规划相关的数学计算问题。</p> <h5>spline_1d_kernel.h</h5> <p>这个文件是一个C++头文件，用于定义一个名为&quot;Spline1DKernel&quot;的类。该类的主要用途是提供处理一维平滑样条(spline)计算的方法和数据结构。Apache许可证2.0约束了文件的使用。</p> <p>Spline1dKernel类的主要功能如下：</p> <ol> <li>提供初始化和处理包含样条数据的构造函数。</li> <li>提供了添加和获取&quot;核(核矩阵和偏移)&quot;的方法，这个&quot;核&quot;是用于计算三次样条插值的一种方法。</li> <li>提供了建立核方法的功能。这些方法包括添加一阶导数、二阶导数、三阶导数的核矩阵；为特定样条k添加一阶、二阶、三阶导数的核矩阵；以及添加距离偏移等。</li> <li>添加了参考线核矩阵和距离偏移的方法，似乎与路径优化和速度优化的计算有关。</li> <li>类的私有部分定义了该类内部使用的变量和方法，这些变量和方法不期望在类外部使用。</li> </ol> <p>总的来说，Spline1dKernel是用于一维平滑样条计算的底层类，封装了大量的计算方法和数据处理，为调用者屏蔽了底层细节，可以更方便的处理样条数据和计算。</p> <h5>spline_1d_constraint.h</h5> <p>这个文件是Apollo自动驾驶框架中的一部分，提供了一维插值样条(spline)的约束类。你可以看到它依赖两个头文件，一个是用于矩阵和向量运算的Eigen库，还有一个是&quot;affine_constraint.h&quot;和&quot;spline_1d.h&quot;。这两个文件可能分别定义了AffineConstraint类和Spline1d类。</p> <p>在Spline1dConstraint类中，它定义了一些方法，这些方法用于添加各种约束，比如边界约束，导数边界约束，二阶和三阶导数边界约束，点约束，断点平滑性约束，等等。</p> <p>类的私有部分包含的变量显然用于存储插值样条的一些数据，比如knots（插值节点），spline的阶数，以及两个AffineConstraint对象。这两个对象可能（虽然没有给出具体的代码）用于存储和处理一些线性约束。</p> <p>总的来说，这个头文件定义了一个类，该类用于向一维插值样条添加各种可能的约束条件，这些约束条件可用于帮助插值过程以满足某些特定的条件或限制。</p> <h5>spline_1d.h</h5> <p>这是一个名为&#8217;spline_1d.h&#8217;的C++头文件，属于Apollo(一个自动驾驶系统项目)的一部分。这个文件定义了一个一维样条(spline)的类（class）名为<code>Spline1d</code>。它的关键目标是处理和提供对一维样条的各种运算和操作。</p> <p>类<code>Spline1d</code>具有以下公共接口：</p> <ul> <li> <p>构造函数，接受一个double类型的向量表示样条的节点以及一个<code>uint32_t</code>类型表示样条的阶数。</p> </li> <li> <p>重载的括号运算符，接受一个double类型的变量作为自变量，并返回样条函数在该处的值。</p> </li> <li> <p><code>Derivative</code>，<code>SecondOrderDerivative</code>，<code>ThirdOrderDerivative</code>函数，分别返回给定点的样条函数的一阶，二阶，三阶导数值。</p> </li> <li> <p><code>SetSplineSegs</code>函数，使用给定的参数向量和阶数设置样条段。</p> </li> <li> <p><code>x_knots</code>和<code>spline_order</code>函数，分别返回样条的节点和阶数。</p> </li> <li> <p><code>splines</code>函数，返回存储样条的向量。</p> </li> </ul> <p>此外，它具有私有函数<code>FindIndex</code>，用于找到给定<code>double</code>值在<code>x_knots</code>向量中的位置，以及私有数据成员存储样条段、样条节点和样条阶数。</p> <h5>spline_1d_seg.h</h5> <p>此文件是一个C++头文件，主要定义了一个名为&quot;Spline1dSeg&quot;的类，这个类在Apollo项目（一个开源的自动驾驶系统）的路径规划模块中使用。Spline1dSeg类主要实现了一维的平滑样条（smoothing spline）。</p> <p>在此类定义中，可以找到两个构造函数，一个函数用于设置样条参数，以及其他四个函数用于提取样条函数在某一点上的函数值、一阶导数、二阶导数和三阶导数。</p> <p>同时，该文件也定义了四个与这四个函数对应的常量函数来返回样条函数及其导数。</p> <p>注意，此头文件还包含&quot;Eigen/Core&quot;（一个著名的线性代数库）和&quot;./planning_base/math/polynomial_xd.h&quot;，以支持其数学操作。</p> <h5>spline_2d_kernel.h</h5> <p>此源代码文件是一个C++头文件，文件路径是&quot;./planning_base/math/smoothing_spline/spline_2d_kernel.h&quot;，这是在Apollo自动驾驶项目中的一部分。此层主要用于路径规划计算。</p> <p>该文件中定义了一个名为&quot;Spline2dKernel&quot;的类，该类基于一组能够生成二次样条曲线参数的核（Kernels）。这个类提供了一组方法，可让类的用户在样条曲线的计算中添加不同的约束条件。具体来说，这些约束条件可能涉及到亚像素决定性，二阶或三阶微分，或者给定参考线的约束。</p> <p>在&quot;Spline2dKernel&quot;类中，除了通用的添加或获取核矩阵和偏移量的方法外，还提供了一些内建的方法，这些方法被应用于二阶、三阶微分样条核的计算以及根据设定的参考线增加样条核。</p> <p>此类也包含一些私有成员变量，例如一个表示核矩阵的Eigen::MatrixXd对象，一个表示偏移量的Eigen::MatrixXd对象，一个包含节点（knots）的double向量，一个uint32_t类型的样条曲线阶数以及一个表示总参数数的size_t变量。</p> <h5>spline_2d_seg.h</h5> <p>这个文件是一个名为&quot;spline_2d_seg.h&quot;的C++头文件，位于./planning_base/math/smoothing_spline目录中。该文件的主要内容为定义了一个名为&quot;Spline2dSeg&quot;的类，负责实现2D样条分段。</p> <p>&quot;Spline2dSeg&quot;类中定义了两个构造函数：一个接受表示参数数量的无符号整数，另一个接受两个参数，分别代表x和y方向上的参数向量。还定义了一个SetParams方法，用于设定x和y方向上的参数向量。</p> <p>类中还定义了获取此样条在某个点上的值、在x和y方向上的一阶导数、二阶导数以及三阶导数的方法。此外，还提供了获取对应一阶、二阶及三阶导数作为对象的方法。</p> <p>&quot;Spline2dSeg&quot;类还包含了表示x和y方向上的样条函数、一阶、二阶、三阶导数的私有变量。</p> <h5>spline_2d_solver.h</h5> <p>这是一个名为&quot;Spline2dSolver&quot;的C++抽象类，它位于Apollo自动驾驶项目中的&quot;./planning_base/math/smoothing_spline/&quot;目录下，用于解决二维平滑样条插值问题。这个文件主要包括了一些用于创建和解析二维曲线的方法和约束。</p> <p>类中有一个构造函数和一个析构函数，还包括一些虚函数，包括&quot;Reset&quot;用于重置样条对象，&quot;mutable_constraint&quot;，&quot;mutable_kernel&quot;和&quot;mutable_spline&quot;用于获取样条插值的限制、核心和样条对象，&quot;Solve&quot;用于解决样条插值问题，&quot;spline()&quot;用于返回插值后的样条对象。另外，此类中还包含了三个保护成员；一个样条对象（Spline2d），一个核（Spline2dKernel）和一个约束（Spline2dConstraint）。</p> <p>总的来说，这个头文件定义了一个关于二维样条插值的类，提供了基本的功能和一些抽象的接口给子类实现具体操作。</p> <h5>spline_1d_solver.h</h5> <p>这个文件是一个C++头文件，属于Apollo自动驾驶项目。具体来说，它定义了名为&quot;Spline1dSolver&quot;的类，这个类可能是用于解决1维平滑样条问题的部分。Spline1D解决器通过使用约束(Constraints)和核(Kernel)，并在求解后提供生成的样条(Spline)，用于1D插值或曲线拟合等操作。</p> <p>在&quot;Spline1dSolver&quot;类中，定义了一个接收矢量x_knots和一个uint32 order的构造函数。另外定义了一些方法，比如 &quot;Reset&quot;, &quot;mutable_spline_constraint&quot;, &quot;mutable_spline_kernel&quot;，在其中的&quot;Reset&quot;方法是用于重置spline, constraint, kernel的状态，并且接收同样的参数。此外，还包含一个纯虚函数&quot;Solve&quot; 方法，这表明&quot;Spline1dSolver&quot;是一个抽象基类，具体的解决方案需要在派生类中实现。</p> <p>这个头文件还包含了一些保护级别的成员，包括一个&quot;Spline1d&quot;, 一个&quot;Spline1dConstraint&quot;, 一个&quot;Spline1dKernel&quot; 的对象，和三个整型变量。另外，还有两个保护级别的方法是用来将问题和矩阵转换为协议缓冲区（protobuf）格式的。</p> <p>这个头文件中还包括一些外部依赖，例如Eigen库（用于线性代数运算），还使用了Apollo特定的.pb.h头文件，这些文件是基于Google的Protocol Buffers，一个用于序列化结构化数据的库。</p> <h3>reference_line</h3> <h4>qp_spline_reference_line_smoother.h</h4> <p>这是一个C++头文件，部分对Apollo自动驾驶众包项目的源代码做出了贡献。文件定义了一个叫做<code>QpSplineReferenceLineSmoother</code>的类，这个类是<code>ReferenceLineSmoother</code>的子类。这个类实际上是用于处理和平滑路径的计划模块，在类中定义了一些私有的方法和数据成员。</p> <p>类中的公有方法有：</p> <ol> <li>构造函数和默认析构函数</li> <li><code>Smooth</code> ：平滑原始参考线并产生平滑化的参考线。</li> <li><code>SetAnchorPoints</code>： 设置锚点。</li> </ol> <p>类中的私有方法包括：</p> <ol> <li><code>Clear</code>：清除函数</li> <li><code>Sampling</code>：采样函数</li> <li><code>AddConstraint</code>：添加约束函数</li> <li><code>AddKernel</code>：添加核函数</li> <li><code>Solve</code>：求解函数</li> <li><code>ExtractEvaluatedPoints</code>：从原始参考线中提取评估过的点</li> <li><code>GetSFromParamT</code>：从参数t获取s值</li> <li><code>FindIndex</code>：找到给定值的索引。</li> </ol> <p>私有数据成员包括：</p> <ol> <li><code>t_knots_</code>和<code>anchor_points_</code>：两个向量分别存储节点和锚点，它们对于细化和平滑路径非常重要。</li> <li><code>spline_solver_</code>：一个存储<code>Spline2dSolver</code>对象的智能指针，用于在二维空间中解样条问题。</li> <li><code>ref_x_</code>和<code>ref_y_</code>：参考线的x和y坐标。</li> </ol> <h4>reference_line_provider.h</h4> <p>该文件是一个C++头文件，定义了<code>ReferenceLineProvider</code>类，它在<code>apollo::planning</code>命名空间中。该类为规划模块提供平滑的参考线。</p> <p>在<code>ReferenceLineProvider</code>类中：</p> <ul> <li>包含一些私有变量，例如<code>is_initialized_</code>、<code>is_stop_</code>、<code>smoother_</code>、<code>vehicle_state_</code>等，这些变量用于存储对象的状态和数据等。</li> <li>有一些私有方法，例如<code>CreateReferenceLine()</code>, <code>UpdateReferenceLine()</code>, <code>SmoothReferenceLine()</code>等，这些方法用于处理与参考线相关的操作。</li> <li>包含几个公共方法，如<code>UpdatePlanningCommand()</code>, <code>UpdateVehicleState()</code>, <code>Start()</code>, <code>Stop()</code>, <code>Reset()</code>等，负责与外部的交互。</li> </ul> <p>该类的主要功能是提供并维护一个滑动的参考线，基于给定的规划命令和车辆状态来生成、平滑和更新参考线，在自动驾驶规刃模块中起到关键的作用。</p> <h4>discrete_points_reference_line_smoother.h</h4> <p>文件 <code>discrete_points_reference_line_smoother.h</code> 是 Apollo 自动驾驶系统计划模块的一部分，包含了离散点参考线平滑器 (Discrete Points Reference Line Smoother) 的定义。</p> <p>该类继承自 <code>ReferenceLineSmoother</code> 基类，以提供平滑参考线的功能。它的主要作用是对原始参考线进行平滑处理，生成一个新的平滑参考线。</p> <p>它提供了以下方法：</p> <ol> <li> <p><code>Smooth</code> &#8211; 这是类的主要方法，它会平滑原始参考线，并在给定空间中创建已平滑的参考线。</p> </li> <li> <p><code>SetAnchorPoints</code> &#8211; 这个方法用于设置平滑操作的锚点。</p> </li> <li> <p><code>CosThetaSmooth</code> 和 <code>FemPosSmooth</code> &#8211; 这两个-private-方法都用于平滑一系列的二维点。</p> </li> <li> <p><code>NormalizePoints</code>和<code>DeNormalizePoints</code> &#8211; 这两个-private-方法用于归一化和反归一化一组xy坐标点。</p> </li> <li> <p><code>GenerateRefPointProfile</code> &#8211; 这个-private-方法用于生成参考点的配置文件。</p> </li> </ol> <p>此外，类还包括了一些私有成员变量，包括锚点列表 <code>anchor_points_</code> 和原点坐标 <code>zero_x_</code>, <code>zero_y_</code>。</p> <h4>reference_line.h</h4> <p>这是一个名为<code>reference_line.h</code>的C++头文件，位于<code>./planning_base/reference_line</code>目录下，属于Apollo自动驾驶框架中的一部分。</p> <p>头文件中定义了一个名为<code>ReferenceLine</code>的类，该类在Apollo的路径规划模块中有重要应用。<code>ReferenceLine</code>类提供了对于参考线(reference line)的一系列操作，比如插值计算、获取参考线上的各种信息(如路径点、车道宽度、道路宽度等)、参考线与路面的关系检查等。</p> <p>参考线是自动驾驶车辆在进行路径规划时的参考路径，可以理解为车辆预计将沿着该线进行行驶。<code>ReferenceLine</code>类是对这样的参考行驶线路的抽象，提供了一系列处理和操作参考线的方法。</p> <p>此外，这个文件还包括了一些C++模板方法，以及多个应用了protobuf的数据消息格式。</p> <h4>reference_line_smoother.h</h4> <p>这个文件，名称为 &quot;reference_line_smoother.h&quot;，是Apollo自动驾驶系统的一部分，它定义了一个名为 <code>ReferenceLineSmoother</code> 的类。此类是为了平滑一个参考线（ReferenceLine）对象。</p> <p>类 <code>ReferenceLineSmoother</code> 中定义了两个纯虚函数，要求任何派生类提供自己的实现。第一个是 <code>SetAnchorPoints</code> 函数，它接受一个 <code>AnchorPoint</code> 类型的向量辅助实现对参考线的平滑。第二个是 <code>Smooth</code> 函数，用于实际对参考线进行平滑处理。</p> <p>此外，类中还定义了一个保护成员变量 <code>config_</code>，它是 <code>ReferenceLineSmootherConfig</code> 类型，用于储存类的配置参数</p> <p><code>ReferenceLineSmoother</code> 的实例会被其他模块用来进行参考线的平滑处理，以便实现更平稳的自动驾驶行驶路径。</p> <h4>spiral_reference_line_smoother.h</h4> <p>这是一个名称为<code>spiral_reference_line_smoother.h</code>的头文件，它是阿波罗自动驾驶系统中planning模块中的一个组件。该文件主要定义了<code>SpiralReferenceLineSmoother</code>类，该类是<code>ReferenceLineSmoother</code>的子类。</p> <p><code>SpiralReferenceLineSmoother</code>类的主要职责是平滑参考线。它可以处理原始参考线，并生成平滑的参考线。</p> <p>该类有几个重要的方法：</p> <ol> <li><code>Smooth</code>：平滑原始参考线，并创建平滑的参考线。</li> <li><code>SmoothStandAlone</code>：用于离线情况下的导航线平滑。</li> <li><code>SetAnchorPoints</code>：设置锚点。</li> <li><code>Interpolate</code>：插值函数，主要用于根据给定的参数（如角度，曲率，长度，x和y坐标等）插入平滑参考线的点。</li> </ol> <p>此外，这个类也定义了一些私有变量来存储固定的起点和终点，以及一些基础坐标信息。可以看出该类是用于生成平滑的参考线路径，以用于后续的路径规划和导航。</p> <h4>reference_point.h</h4> <p>这个文件是Apollo自动驾驶系统中的一部分，名为&#8217;reference_point.h&#8217;。这个文件定义了一个类ReferencePoint，这个类是hdmap::MapPathPoint的公有派生类。ReferencePoint类描述了路径的参考点，这是自动驾驶路径规划的重要组成部分。</p> <p>这个类主要包括以下几个部分:</p> <ul> <li> <p>构造函数：一个默认的空构造函数和一个接受地图路径点(map_path_point)和曲率(kappa), 曲率变化率(dkappa)的构造函数。</p> </li> <li> <p>方法<code>ToPathPoint</code>，将参考点转换为路径点，接受一个参数，表示累积弧长或者位置的参数。</p> </li> <li> <p>获取kappa和dkappa的方法<code>kappa()</code> 和 <code>dkappa()</code></p> </li> <li> <p>一个<code>DebugString</code>方法，返回一个表示ReferencePoint对象的字符串，方便调试。</p> </li> <li> <p>一个静态成员函数<code>RemoveDuplicates</code>，用于从参考点的向量中删除重复项。</p> </li> <li> <p>私有数据成员kappa<em>和 dkappa</em>，分别表示曲率和曲率变化率。</p> </li> </ul> <p>这个头文件使用了预处理器宏<code>#pragma once</code>来防止多重包含。</p> <h4>spiral_problem_interface.h</h4> <p>这个文件是Apollo自动驾驶项目的一部分，它是一个头文件，负责定义一个名为&quot;SpiralProblemInterface&quot;的类。</p> <p>&quot;SpiralProblemInterface&quot;类被设计为处理由点阵描述的螺旋形参考线的问题。它是基于螺旋曲线理论并且使用建优化解决器Ipopt库来解决优化问题。</p> <p>该类封装了一系列与螺旋形路径优化相关的方法，包括设置开始和结束点，获取优化结果，以及渲染和计算螺旋形路径。</p> <p>该类还定义了不同的权重参数，可以调整每个路径元素（曲度、偏差等）在优化过程中的重要性。</p> <p>总结，此文件是Apollo自动驾驶项目中处理道路规划优化问题的一部分，特别是优化螺旋形参考线。</p> <h2>planning_component</h2> <h3>on_lane_planning.h</h3> <p>这个文件是apollo项目的一部分，这是一个开源的自动驾驶系统。具体来说，这个文件定义了一个&#8217;OnLanePlanning&#8217;类，这是一个计划模块的主类。它处理GPS和IMU作为输入，来生成计划信息。</p> <p>该类派生自&#8217;PlanningBase&#8217;类，并包含了一系列的方法，如：</p> <ol> <li><code>Init</code>: 初始化函数</li> <li><code>RunOnce</code>: 计划模块的主逻辑函数，定期由定时器触发运行</li> <li><code>Plan</code>: 车辆的计划路径</li> <li><code>InitFrame</code>: 初始化帧结构和车辆状态</li> <li><code>AlignTimeStamp</code>: 对准时间戳</li> <li><code>CheckPlanningConfig</code>：检查计划配置</li> <li>以及多个导出和添加函数进行各种数据的处理和状态的调整。</li> </ol> <p>此外，此类还有一些私有的成员变量，包含了上一次的计划指令，一个参考线提供器，以及一个计划平滑器。这个类的实例化和具体的使用，可能定义在其他的源文件里。根据函数的定义，它可能被设计成执行一些自动驾驶策略的计算和决策。</p> <h3>navi_planning.h</h3> <p>这个文件叫做&quot;navi_planning.h&quot;，是 Apollo 项目的一部分，具体位置在 &quot;./planning_component/&quot; 目录下。Apollo 是一个开源的自动驾驶系统。</p> <p>在这个头文件中，定义了一个名叫 &quot;NaviPlanning&quot; 的类，它是 &quot;PlanningBase&quot; 类的子类，用于实现一些与导航规划相关的功能。</p> <p>&quot;NaviPlanning&quot; 类中定义了一些方法，包括初始化 (&quot;Init&quot;)，一些主要逻辑 (&quot;RunOnce&quot;)，路径规划 (&quot;Plan&quot;)，以及处理控制指令 (&quot;ProcessPadMsg&quot;) 等。</p> <p>此外，还有一些获取车辆当前位置，左邻车道信息，右邻车道信息的函数，以及一些处理参考线调试信息的函数。</p> <p>在类的末尾，还定义了一个名为 &quot;VehicleConfig&quot; 的内置类，用于存储车辆的配置信息，如坐标 (x, y)、角度 (theta)、以及一个表示配置是否有效的布尔值。</p> <p>头文件的开头包含了 Apache 许可证，以及必要的宏定义和库引用。</p> <h3>planning_base.h</h3> <p>这是一个头文件，属于一个源代码项目中负责规划部分（<code>planning</code>）的模块。文件中定义了一个<code>PlanningBase</code>类，这个类被设计为规划模块的基础类。</p> <p>类<code>PlanningBase</code>中定义了一些核心函数，比如<code>Init</code>，<code>Name</code>，<code>RunOnce</code>和<code>Plan</code>，这些函数都被设定为虚函数。这意味着他们可能在继承自<code>PlanningBase</code>类的子类中被重写。</p> <p>除此之外，<code>PlanningBase</code>类中还定义了一些属性，比如路网高度值映射（<code>hdmap_</code>）、初始时间（<code>start_time_</code>）、序列号（<code>seq_num_</code>）、配置项(<code>config_</code>)，以及一个交通决策器(<code>traffic_decider_</code>)。</p> <h3>planning_component.h</h3> <p>这是一个名为<code>planning_component.h</code>的头文件，属于Apollo的自动驾驶系统项目中的<code>planning</code>模块。这个文件主要定义了一个<code>PlanningComponent</code>类，用于实现计划组件。</p> <p>该类聚焦于软件的的规划部分，通常是在自动驾驶堆栈中，处理如何在环境中规划车辆的路径和操控。类中包含了大量的共享智能指针（<code>std::shared_ptr</code>），它们主要用于处理各种消息和命令，比如交通灯检测、路线回路、故事讲述、计划命令等。</p> <p>在<code>PlanningComponent</code>类中，还定义了两个公用方法，<code>Init</code>和<code>Proc</code>，可用于初始化组件和处理消息，并有一些私有方法和数据成员。</p> <p>此外，这个文件还包含了一台关于类的注册宏<code>CYBER_REGISTER_COMPONENT(PlanningComponent)</code>，这样可以在运行时通过类加载器自动地加载这个组件。</p> <h3>integration_tests</h3> <h4>planning_test_base.h</h4> <p>这是一个名为<code>planning_test_base.h</code>的头文件，它是Apollo自动驾驶系统的一部分，特别是规划组件中的集成测试部分。该文件定义了一个<code>PlanningTestBase</code>类，这个类是用于进行规划模块的测试的基类。它继承自<code>gtest::Test</code>，一个Google测试框架的类，表明该类用于执行单元测试。</p> <p><code>PlanningTestBase</code>类中有多个公有和受保护的成员。其中公有成员包括静态函数<code>SetUpTestCase()</code>，用于设置测试用例；<code>SetUp()</code>，用于设置每个单元测试；<code>UpdateData()</code>，用于更新数据；以及<code>RunPlanning()</code>，该函数执行规划代码并返回成功与否。类还声明了一些保护成员，这些成员主要用于内部使用。</p> <p>文件还包括一些宏定义用在测试中，例如<code>RUN_GOLDEN_TEST</code>，<code>RUN_GOLDEN_TEST_DECISION</code>和<code>TMAIN</code>等等。</p> <p>文件的开头包含了对Apollo分布式驾驶系统仿真的版权声明，以及对Apache许可证2.0的详细描述，后者允许将源代码用于非商业和商业用途，但必须保留原始的版权声明和许可声明。</p> <h2>planning_interface_base</h2> <h3>planner_base</h3> <h4>planner.h</h4> <p>该源代码文件是C++程序，位于<code>./planning_interface_base/planner_base/</code>目录，叫做<code>planner.h</code>，它定义了两个类 <code>Planner</code> 和 <code>PlannerWithReferenceLine</code>。此外，该文件在Apollo开源自动驾驶项目中。</p> <ol> <li> <p><code>Planner</code>: 这是一个抽象基类，被设计为所有具体规划器的基类。它提供了一些通用方法和接口，例如初始化(Init)，规划(Plan)，停止(Stop)，重置(Reset)和加载配置(LoadConfig)。这些接口主要被设计为虚函数，意味着子类需要根据实际需要实现它们。除此之外，还有一个受保护的成员变量，是用于依赖注入的 <code>injector_</code>。</p> </li> <li> <p><code>PlannerWithReferenceLine</code>: 这是继承自<code>Planner</code>的派生类，它覆盖并实现了<code>Planner</code>类的计划功能(PlanOnReferenceLine)，用于在参考线上进行规划。</p> </li> </ol> <p>这个文件中还包括相应的命名空间（即 <code>apollo</code> 和 <code>planning</code>）以及许多包含头文件，用于提供基本的功能和类型定义。</p> <h3>scenario_base</h3> <h4>base_stage_creep.h</h4> <p>这个文件是Apollo自动驾驶系统中的一个头文件，名为&quot;base_stage_creep.h&quot;。这个文件主要定义了车辆的蠕动阶段的基类。蠕动阶段可能是指车辆在某些驾驶情况下慢慢移动的阶段。</p> <p>在类<code>BaseStageCreep</code>中，包含了一些关键的方法，如<code>ProcessCreep</code>，<code>CheckCreepDone</code>，<code>GetCreepFinishS</code>，<code>GetCreepTargetS</code>，<code>GetCreepStageConfig</code>和<code>GetOverlapStopInfo</code>。这些方法负责处理蠕动的逻辑，如检测蠕动是否完成，获取蠕动阶段结束的位置，获取蠕动的目标停止位置，获取蠕动阶段的配置和获取重叠停止信息。</p> <p>另外，还在其中定义了一个静态常数字符串&quot;CREEP_VO_ID<em>PREFIX</em>&quot;，值为&quot;CREEP_&quot;，可能被用作蠕动阶段的ID前缀。</p> <p>由于这是一个基类，所以含有一些纯虚函数（以<code>= 0</code>结尾，子类需要重写这些函数）。代码涉及到的其他类如<code>Frame</code>，<code>ReferenceLineInfo</code>和<code>CreepStageConfig</code>等，都没有在这个文件中定义，可能是在其他头文件中。</p> <p>这个文件还包含了对<code>apollo::common::Status</code>，<code>apollo::planning::Frame</code>，<code>apollo::planning::ReferenceLineInfo</code>和<code>apollo::planning::CreepStageConfig</code>的前向声明。</p> <h4>base_stage_cruise.h</h4> <p>这个头文件定义了一个名为&quot;BaseStageCruise&quot;的类，它继承自&quot;Stage&quot;类。此类似乎是Apollo自动驾驶工程的一部分，旨在实现驾驶规划的某个阶段。</p> <p>BaseStageCruise类具有一个名为&quot;CheckDone&quot;的公共成员函数，用于检查阶段是否完成，输入参数包括帧、规划上下文和车辆是否具有车道优先权。</p> <p>此外，该类还包含一个纯虚函数，名为&quot;GetTrafficSignOverlap&quot;，功能可能为获取交通标志重叠情况，输入参数包括参考线信息和规划上下文。这个函数在继承&quot;BaseStageCruise&quot;的具体子类中应该会有具体的实现。</p> <p>这个文件需要被其他文件通过#include指令引入后才能使用其中定义的类和函数。</p> <h4>process_result.h</h4> <p>这是一个C++头文件，标题名为<code>process_result.h</code>，位于<code>./planning_interface_base/scenario_base</code>目录下。该文件定义了两个类，<code>StageResult</code>和<code>ScenarioResult</code>，这两个类都是对某些过程执行结果的封装。</p> <p><code>StageResult</code>类包含一个枚举类型的状态<code>stage_status</code>和一个<code>common::Status</code>类型的<code>task_status</code>，其中<code>common::Status</code>是Apollo项目中常用的一个错误处理类。<code>StageResult</code>类定义了获取和设置这两个状态的方法，以及判断是否有错误的方法。</p> <p><code>ScenarioResult</code>类包含一个枚举类型的状态<code>scenario_status</code>和一个<code>StageResult</code>类型的<code>stage_result</code>。<code>ScenarioResult</code>类定义了获取和设置这两个状态的方法，以及设置<code>StageResult</code>的方法。</p> <p>文件中的代码分布在<code>apollo</code>和<code>planning</code>两个命名空间下，这意味着这个头文件可能是Apollo自动驾驶系统的一部分。</p> <h4>scenario.h</h4> <p>文件名为&quot;scenario.h&quot;，位于目录&quot;./planning_interface_base/scenario_base/&quot;. 它是 Apollo 自动驾驶系统中的一个部分，涉及自动驾驶规划阶段的场景管理。</p> <p>这个头文件定义了一个名为&quot;Scenario&quot;的类，该类对自动驾驶的不同场景进行封装和管理，提供了一些反应不同驾驶场景的接口和成员变量。&quot;Scenario&quot;类具有虚构函数和虚方法，意味着它可能被设计为基类用于派生其他具体场景的类,如&quot;IsTransferable&quot;, &quot;Process&quot;, &quot;Enter&quot;, &quot;Exit&quot;, &quot;GetContext&quot;等，同时还提供了&quot;CreateStage&quot;、&quot;GetStatus&quot;、&quot;GetStage&quot;、&quot;GetMsg&quot;、&quot;Name&quot;和&quot;Reset&quot;等管理和操作方法。</p> <p>此外，文件还定义了一个&quot;ScenarioContext&quot;的结构体，可能用于描述和存储场景的特定信息或上下文。</p> <p>在这个头文件中，还引用了其他一些与规划和场景相关的头文件和protobuf文件，例如&quot;dependency_injector.h&quot;, &quot;scenario_pipeline.pb.h&quot; 和 &quot;process_result.h&quot;等。</p> <h4>stage.h</h4> <p>这份代码是 Apollo 自动驾驶系统项目中的一部分，特别是在规划模块中。文件是一个头文件，定义了一个名为&quot;Stage&quot;的类，该类似乎被用作不同的规划阶段的基础。</p> <p>在这个 Stage 类中，它包含一些关键的方法，如 &quot;Init&quot;, &quot;Process&quot;, &quot;ExecuteTaskOnReferenceLine&quot;, &quot;ExecuteTaskOnOpenSpace&quot; 和 &quot;FinishScenario&quot;等。特别是&quot;Process&quot;虚函数，它显然需要在具体的实现阶段中被重载，并被用于处理此阶段的业务逻辑。此外，这个类还有 some 成员，如&quot;task<em>list</em>&quot;，&quot;fallback<em>task</em>&quot;，&quot;next<em>stage</em>&quot;，&quot;context<em>&quot;，&quot;injector</em>&quot; 和&quot;pipeline<em>config</em>&quot;等，这些都可能被用于组织和管理规划过程。</p> <p>此外，此文件还引用了其他几个文件，包括几个 protocol buffer (&quot;protobuf&quot;) 文件，这些文件定义了一些用于此阶段的数据结构。</p> <p>总的来说，这份代码主要是自动驾驶系统中定义规划阶段的一种方式。</p> <h4>traffic_light_base</h4> <h5>base_stage_traffic_light_creep.h</h5> <p>这个文件名称为<code>base_stage_traffic_light_creep.h</code>，它是&quot;C++&quot;个头文件，属于一个软件项目中planning模块的一部分。可能是用于处理交通灯和车辆缓慢驶过交通灯场景的组件。</p> <p>该文件定义了一个名为 <code>BaseStageTrafficLightCreep</code> 的类，该类是 <code>BaseStageCreep</code> 的公有派生类。该类重新定义了基类的方法 <code>GetOverlapStopInfo</code>，看起来像是用于获取车辆应该在哪停下来以遵守交通灯的信息。</p> <p>它位于 apollo 名称空间的 planning 名称空间中，表明它应属于一个名为 Apollo 的项目，这个项目可能为自动驾驶和路径规划系统。文件中有明确的版权、许可证信息，提示该代码可能对外开源。</p> <h5>base_stage_traffic_light_cruise.h</h5> <p>这个文件是Apollo自动驾驶软件项目中的一部分，并且它是程序中处理交通信号规划阶段的部分。具体来说，文件定义了一个名为<code>BaseStageTrafficLightCruise</code>的类，这个类继承自<code>BaseStageCruise</code>类。</p> <p>该类中有一个私有成员函数<code>GetTrafficSignOverlap</code>，它接收参考线（ReferenceLineInfo）和规划环境（PlanningContext）作为参数并返回一个交通标志的重叠区域。这个函数在子类中需要被重写以适应不同的停车场景。</p> <p>此外，该文件包含了版权声明、许可证信息及文件描述注释。</p> <p>从文件路径和包括的头文件来看，此文件是用于计划处理交通信号状态的模块的基类，可能被其它子模块在实现具体的交通灯处理规则时继承。</p> <h3>task_base</h3> <h4>task.h</h4> <p>这是一个名为&quot;task.h&quot;的头文件位于&quot;./planning_interface_base/task_base&quot;目录下。这个文件定义了一个名称为Task的类，通过阅读源代码我们可以认为他是Apollo自动驾驶系统中计划模块的一个基础任务组件。下面是一些关于这个类的重要信息：</p> <ul> <li>Task类包括一些关键的虚函数，如<code>Init</code>和<code>Execute</code>，预计在派生类中实现这些函数以满足不同的任务需求。</li> <li>Init函数用于初始化任务，它接收配置目录、名称及依赖注入对象。</li> <li>有2个版本的Execute函数，他们的目的是进行任务的执行，但参数类型和数量有所不同，这是一个典型的函数重载的例子。</li> <li>此外，Task类还有一个<code>LoadConfig</code>的模板函数，用于加载配置信息。</li> <li>在保护成员（protected）中，Task存储了指向Frame和ReferenceLineInfo的指针及依赖注入对象，和其他一些字符串类型的成员如&#8217;name_&#8217;等。</li> </ul> <p>最后，该代码是在apollo的命名空间下的planning命名空间中定义的，这是为了组织代码的一种常见手段。</p> <h4>trajectory_fallback_task.h</h4> <p>这是一个名为&quot;trajectory_fallback_task.h&quot;的头文件，是Apollo开源自动驾驶项目的一部分。该文件定义了一个名为&quot;TrajectoryFallbackTask&quot;的类，这个类继承自&quot;Task&quot;类。这个类是处理轨迹退回任务的类，在不同情况下无法生成预期的驾驶轨迹时，它能生成一条退回的轨迹。</p> <p>TrajectoryFallbackTask类声明了一系列的公开和私人成员函数：</p> <ol> <li> <p>&quot;Execute&quot;函数，它接收一个名为&quot;Frame&quot;的参数和一个名为&quot;ReferenceLineInfo&quot;的参数，用于执行计划任务。</p> </li> <li> <p>&quot;GenerateFallbackPath&quot;函数，该函数用于生成退回路径。</p> </li> <li> <p>纯虚函数&quot;GenerateFallbackSpeed&quot;，该函数用于生成回退速度，接受两个参数，&quot;EgoInfo&quot;（自车信息）和&quot;stop_distance&quot;（停车距离，初始为0.0）。</p> </li> <li> <p>&quot;GenerateFallbackPathProfile&quot;函数，该函数用于生成退回路径概要。</p> </li> <li> <p>&quot;RetrieveLastFramePathProfile&quot;函数，该函数用于恢复最后一帧的路径概要。</p> </li> <li> <p>&quot;AmendSpeedDataForControl&quot;函数，该函数修改停车前的减速，以便控制模块可以跟进。</p> </li> </ol> <p>这个类所在的命名空间是&quot;apollo::planning&quot;，这表示这个类可能是轨迹计划模块的一部分。</p> <h4>common_</h4> <h5>decider.h</h5> <p>这个文件是 Apollo 自动驾驶系统的一部分，具体来说，在 planning 模块的 decider 任务中。这个文件定义了一个名为 &quot;Decider&quot; 的类，该类是 &quot;Task&quot; 类的公共派生类。</p> <p>Decider 类有两个 Execute 方法和两个 Process 方法。这四个方法都接受 Frame 对象作为参数，原型分别是：</p> <ul> <li><code>Status Execute(Frame*, ReferenceLineInfo*) override;</code></li> <li><code>Status Execute(Frame*) override;</code></li> <li><code>Status Process(Frame*, ReferenceLineInfo*) { return Status::OK(); }</code></li> <li><code>Status Process(Frame*) { return Status::OK(); }</code></li> </ul> <p>这些方法返回一个 Status 对象，该对象定义了该任务的状态，可能的状态包括 OK、ERROR 等。</p> <p>此文件是在 Apache License 2.0 下授权的，这意味着你可以自由使用和修改它，但在发布改动时必须打上 Apache License。虽然这份许可证允许许多自由，但它也有一些限制，比如需要在分发的副本中附上许可声明和版权声明等。</p> <p>请注意，这个文件没有具体的实现代码，所述的<code>Execute</code> 和 <code>Process</code> 方法在此处被声明为 <code>override</code> 和 <code>virtual</code>，这意味着它们在继承此基类的子类中被覆盖和实现。</p> <h5>path_generation.h</h5> <p>这个程序包含在 Apollo 项目内，是一个路径生成的基类。Apollo 是一个开源的自动驾驶平台。主要处理的功能是在自动驾驶系统的规划阶段，生成行驶路径。</p> <p>该文件的路径及命名指出，它处于 planning 模块的 planning_interface_base 目录下，并在执行一些规划任务的过程中涉及到路径生成。本文件是一个头文件（.h文件），包含了一个 PathGeneration 类的声明，这是一个从 Task 类派生出的类。</p> <p>PathGeneration 类中声明了两个虚函数Execute，用于执行基于给定框架的路径生成任务操作。同时，它还声明了两个Process函数，用于处理给定框架与参考线信息的路径生成任务。这两个函数在此处声明为受保护，并提供了默认的实现。</p> <p>另外，还声明了其他一些函数，包括获取初始的SL状态(GetStartPointSLState)、记录调试信息(RecordDebugInfo)和计算某点的SL边界(GetSLBoundary)。最后声明了一个成员变量 init_sl<em>state</em>，该成员变量用于储存计算出的初始SL状态。</p> <p>在路径生成过程中，任何导出于 PathGeneration 的子类都可以重载这些方法以实现特定的路径生成逻辑。</p> <h5>speed_optimizer.h</h5> <p>这个文件是 Apollo 自动驾驶系统中的一部分，特别地，它是规划模块中的一个文件。这个文件定义了一个名为<code>SpeedOptimizer</code>的抽象类，该类是任务(Task)的一个派生类。所有的速度优化器应该继承自这个基类并实现<code>Process</code>方法，以完成特定的速度优化任务。</p> <p>在<code>SpeedOptimizer</code>类中，有一个虚的析构函数，一个名为<code>Execute</code>的公开方法和一个受保护的虚方法<code>Process</code>。此外，还提供了<code>RecordDebugInfo</code>方法，用于记录debug信息。这个类的职责是在给定的路径数据和初始点的上下文中处理速度优化任务。</p> <p>此外，文件还包括几个Apollo特有的库，包括制定任务状态的<code>status.h</code>库，处理速度优化数据的<code>speed_data.h</code>库等。</p> <h5>trajectory_optimizer.h</h5> <p>这个头文件<code>trajectory_optimizer.h</code>定义了一个名为<code>TrajectoryOptimizer</code>的类，该类是Apollo自动驾驶系统中规划模块的一部分。</p> <p><code>TrajectoryOptimizer</code>类是<code>Task</code>类的派生类，表明它是一种可以执行的任务。该类有两个主要成员函数：</p> <ul> <li> <p><code>Execute(Frame *frame)</code>：该函数被设为override，表明它覆盖了从基类<code>Task</code>继承的<code>Execute</code>函数。</p> </li> <li> <p><code>Process()</code>：这是一个纯虚函数，子类需要对其进行实现。</p> </li> </ul> <p>这个文件还包含了一些包括谷歌协议缓冲区（protobufs）和Apollo专有类型在内的头文件，可能被该类中的方法使用。</p> <p>该文件的版权声明指出，该代码可以根据Apache 2.0许可进行使用并对其进行修改，但必须明确保留版权声明和许可声明。</p> <p>综上，<code>TrajectoryOptimizer</code>具有执行任务和处理输入的功能，可能会被用于Apollo系统中路径优化的部分。</p> <h5>lane_change_util</h5> <h6>lane_change_util.h</h6> <p>这个文件是一个C++头文件，它负责定义一组与车道改变相关的工具函数。它位于./planning_interface_base/task_base/common/lane_change_util路径中。从层级结构上看，这个文件似乎与车道变更有关的某些决策和实用功能相关。</p> <p>这个头文件定义了以下函数：</p> <ol> <li> <p><code>IsClearToChangeLane</code>：一个静态函数，检查给定的参考线是否安全进行车道更换，或者当前参考线是否可以安全的偏离并返回。</p> </li> <li> <p><code>IsPerceptionBlocked</code>：一个静态函数，通过束扫描来估计在ADV前面的某一范围内有障碍物是否阻塞了过多的空间感知。</p> </li> <li> <p><code>UpdatePreparationDistance</code> ：一个静态函数，用于更新变道准备距离。</p> </li> <li> <p><code>HysteresisFilter</code>: 一个静态函数，对障碍物距离进行滤波处理，输入包括障碍物距离、安全距离、距离缓冲和障碍物是否阻塞的标志。</p> </li> </ol> <p>这些函数可能会被用于更大的车道改变决策系统中的一种或多种用途，例如安全性检查、障碍物工，以及其他车道更换预处理任务。</p> <h5>path_util</h5> <h6>path_assessment_decider_util.h</h6> <p>这是一个C++头文件，它定义了一个名为<code>PathAssessmentDeciderUtil</code>的工具类，该类位于<code>apollo::planning</code>的命名空间里。此类主要用于评估和决定自动驾驶车辆的规划路径是否有效。</p> <p>它主要包含以下的静态函数：</p> <ol> <li><code>IsValidRegularPath</code>：检查生成的路径是否有效。</li> <li><code>IsGreatlyOffReferenceLine</code>：检查路径是否大幅度偏离参考线。</li> <li><code>IsGreatlyOffRoad</code>：检查路径是否大幅度偏离道路。</li> <li><code>IsCollidingWithStaticObstacles</code>：检查路径是否与静态障碍物发生碰撞。</li> <li><code>IsStopOnReverseNeighborLane</code>：检查是否在相反方向的相邻车道上停车。</li> <li><code>InitPathPointDecision</code>：初始化路径点的决策类型。</li> <li><code>TrimTailingOutLanePoints</code>：裁剪离车道过远的路径尾部点。</li> </ol> <p>此外，还定义了一种新的数据类型<code>PathPointDecision</code>，它是一个元组，包含了与路径点相关的决策信息：距离、路径点类型和离最近障碍物的距离。</p> <h6>path_bounds_decider_util.h</h6> <p>这个文件名为<code>path_bounds_decider_util.h</code>，是一个头文件，属于Apollo自动驾驶系统中，用于路径决策的部分。Apollo是一个开放的自动驾驶平台。</p> <p>该文件包含一个<code>PathBoundsDeciderUtil</code>类，这个类包含了一些静态函数用于决定自动驾驶车辆该如何在给定环境中规划其路径。大部分函数都涉及到了路径边界的设定和修改（<code>PathBoundary</code>）。</p> <p>例如，<code>InitPathBoundary</code>函数是用来初始化路径边界的，<code>GetBoundaryFromLanesAndADC</code>函数是基于车道信息和自动驾驶车辆（ADC）的定位精炼边界的。以及其他一些类似<code>UpdatePathBoundaryWithBuffer</code>, <code>TrimPathBounds</code>, <code>GetBoundaryFromStaticObstacles</code>等，都是在处理和修改路径边界。</p> <p>此外，有几个函数涉及到了具体的引用线信息(<code>ReferenceLineInfo</code>)，以及一些具体的障碍物处理，譬如<code>IsWithinPathDeciderScopeObstacle</code>函数。</p> <p>这个文件定义的函数主要被用于在Apollo自动驾驶系统中的路径规划和决策任务中。</p> <h6>path_optimizer_util.h</h6> <p>这个文件是Apollo自动驾驶系统中的一部分，定义了一个名为PathOptimizerUtil的类，这个类包含了一系列的静态方法，主要用于路径规划的优化操作。</p> <p>方法包括：</p> <ul> <li><code>ToPiecewiseJerkPath</code>：把原始数据转换为Frenet框架路径</li> <li><code>EstimateJerkBoundary</code>：基于车辆动力学模型，计算冲量边界</li> <li><code>ConvertPathPointRefFromFrontAxeToRearAxe</code>：把路径点从前轴坐标转化为后轴坐标</li> <li><code>CalculateVertexConstraints</code>：计算顶点约束</li> <li><code>FormulateExtraConstraints</code>：构建额外的约束</li> <li><code>OptimizePath</code>：进行路径优化</li> <li><code>UpdatePathRefWithBound</code>和<code>UpdatePathRefWithBoundInSidePassDirection</code>：在引用路径超过路径边界时，更新其值和权重</li> <li><code>CalculateAccBound</code>：通过引用线曲率和自动驾驶车辆横向加速来计算加速度边界</li> </ul> <p>这个文件还定义了一个SLState类型，是一个双元组，代表了一个向量的状态，包括位置、速度和加速度。</p> <p>文件中还包含了一些其他Apollo项目的头文件引用，这些头文件主要包含了一些类型定义和配置信息。</p> <h4>optimizers</h4> <h5>road_graph</h5> <h6>comparable_cost.h</h6> <p>这个文件名为&quot;comparable_cost.h&quot;的代码文件属于Apollo自动驾驶系统的一部分，它定义在&quot;apollo::planning&quot;命名空间中的类&quot;ComparableCost&quot;里。</p> <p>&quot;ComparableCost&quot;类主要用于比较和规划路径中的各方案的成本。它包含了几个成本因素，包括是否发生碰撞(has_collision)，是否超出边界(out_of_boundary)，和是否超出车道(out_of_lane)。此外，还有从障碍物或边界到车辆的距离(safety_cost)，以及车道中心、路径曲率等因素造成的成本(smoothness_cost)。</p> <p>类中定了一些方法，用于比较，求和，和比较各成本大小。例如CompareTo用于比较两个ComparableCost对象的大小，而operator+和operator+=用于合并两个成本。</p> <p>请注意，这是一个头文件(&quot;.h&quot;文件)，定义了&quot;ComparableCost&quot;的接口，实现代码在相应的&quot;.cpp&quot;文件中。</p> <h6>dp_road_graph.h</h6> <p>此文件名为<code>dp_road_graph.h</code>，这是一个C++头文件。其定义了一个名为<code>DpRoadGraph</code>的类，这是一个动态规划（Dynamic Programming）方式的路网图模型。在自动驾驶软件中，这样的路网图模型通常用于路径规划和决策。</p> <p><code>DpRoadGraph</code>类中定义了换构造函数和析构函数，一个名为<code>FindPathTunnel</code>的函数，以及一些私有方法和数据成员。它主要用于从给定的起始点、速度数据以及与障碍物进行查找路径。</p> <p>同时这个文件还定义了两个内部结构 <code>DpRoadGraphNode</code> 和 <code>RoadGraphMessage</code>。<code>DpRoadGraphNode</code> 结构用于动态规划算法，记录下各节点信息及其最低代价。<code>RoadGraphMessage</code> 结构用于记录路径查找过程中的一些参数信息。</p> <p>最后，这个文件包含了一些第三方库的头文件引用，这些文件大多都与自动驾驶有关，包括路径规划、障碍物、速度数据、轨迹等。以及与一些用于计算的库，如曲线，多项式等。</p> <h6>trajectory_cost.h</h6> <p>这个文件是Apollo自动驾驶项目的一部分，路径名“./planning_interface_base/task_base/optimizers/road_graph/trajectory_cost.h”表示了它在项目中的位置，这个文件主要在规划和路径优化过程中使用。</p> <p>它定义了一个名为“TrajectoryCost”的类，这是一个用于计算车辆行驶轨迹的代价的类。</p> <p>该类的主要公开方法是Calculate，输入一个五次多项式曲线代表的轨迹（QuinticPolynomialCurve1d），起始和终止的两个参数，以及两个级别，以ComparableCost（可比较的成本）的形式返回计算出的路线成本。</p> <p>TrajectoryCost 类中还有一些私有的成员方法，包括为路径计算成本、计算静态和动态障碍物的成本、两个ObsBoxes之间的成本等。</p> <p>类中包括的数据成员有车辆参数、初始点、自动驾驶车辆SL边界等各种与轨迹代价计算相关的信息。</p> <p>整体来看，这个文件的功能是基于路径，障碍物与道路等因素来评估一条给定轨迹的行驶成本。这个评价过程将大量用于决策制定、路径规划和优化等自动驾驶核心控制流程中。</p> <h6>waypoint_sampler.h</h6> <p>这是一个在Apollo自动驾驶系统中的头文件（.h)，定义了一个名为<code>WaypointSampler</code>的类，该类主要用于在给定的地图或路线上采样路径上的点 (waypoints)。</p> <p>文件的路径 <code>./planning_interface_base/task_base/optimizers/road_graph/waypoint_sampler.h</code> 同样揭示了该文件在整个项目中的位置，即它是在“规划”模块的“道路图”的“优化器”下的一个模块。</p> <p><code>WaypointSampler</code>类具有以下重要构造函数和方法：</p> <ul> <li>一个接收<code>WaypointSamplerConfig</code>类型参数的构造函数，用于初始化类。</li> <li><code>Init</code>初始化函数，用于设置参考线信息、初始的SLPoint和FrenetFramePoint。</li> <li><code>SetDebugLogger</code>函数，用于设置调试日志器。</li> <li><code>SamplePathWaypoints</code>函数，接收初始的轨迹点和一个points的vector，返回布尔值表示采样是否成功。</li> </ul> <p><code>WaypointSampler</code>类接收的参数和返回的类型大多来自于<code>modules</code>目录下的其他模块，如<code>ReferenceLineInfo</code>，<code>SLPoint</code>,<code>FrenetFramePoint</code>，<code>TrajectoryPoint</code>等。该类也定义了一些的保护型变量，如<code>config_</code>、<code>reference_line_info_</code>、<code>init_sl_point_</code>、<code>init_frenet_frame_point_</code>和<code>planning_debug_</code>等。</p> <h4>utils_</h4> <h5>st_gap_estimator.h</h5> <p>这个文件是Apollo自动驾驶系统的一部分，特定路径为“./planning_interface_base/task_base/utils/st_gap_estimator.h”。它定义了一个类型为&quot;StGapEstimator&quot;的类，该类处于&quot;apollo&quot;的&quot;planning&quot;命名空间下。</p> <p>&quot;StGapEstimator&quot;类中所有的成员函数都是静态函数，意味着这些函数可以不通过实例化类的对象来调用，直接通过类来调用。同时，注意这个类的默认构造函数和析构函数都被删除，所以它不能被实例化。</p> <p>&quot;StGapEstimator&quot;类提供的静态方法主要是为了计算自动驾驶车辆（ADC）与目标障碍物之间的安全距离。包含以下几个函数：</p> <ol> <li> <p><code>EstimateSafeOvertakingGap</code>: 计算安全超车距离。</p> </li> <li> <p><code>EstimateSafeFollowingGap</code>: 计算在给定目标障碍物的速度时，安全的跟随距离。</p> </li> <li> <p><code>EstimateSafeYieldingGap</code>: 计算安全让路距离。</p> </li> <li> <p><code>EstimateProperOvertakingGap</code>: 在Given目标障碍物和ADC的速度时，估计适当的超车距离。</p> </li> <li> <p><code>EstimateProperFollowingGap</code>: 在Given ADC的速度时，估计适当的跟随距离。</p> </li> <li> <p><code>EstimateProperYieldingGap</code>: 计算适当的让行距离。</p> </li> </ol> <h3>traffic_rules_base</h3> <h4>traffic_decider.h</h4> <p>这个文件是Apollo自动驾驶系统中的一部分，具体来说，它是计划模块的一部分。该文件定义了一个名为<code>TrafficDecider</code>的类，它是用于生成和处理与交通相关的决策。</p> <p><code>TrafficDecider</code>类具有以下关键功能：</p> <ul> <li><code>Init</code>函数，用于初始化对象。</li> <li><code>Execute</code>函数，该函数接受一帧（即在某一特定时刻捕获的所有相关数据）和一条参考线信息，在这些信息的基础上执行交通决策。</li> <li><code>BuildPlanningTarget</code>函数，用于在给定参考线信息的基础上构建计划目标。</li> </ul> <p>类中还包含了一些私有成员，如<code>init_</code>布尔标志以及一些与交通规则和交通规则管道有关的对象。</p> <p>请注意，虽然这个头文件定义了<code>TrafficDecider</code>类的方法，但是方法的具体实现在其他源文件中。</p> <h4>traffic_rule.h</h4> <p>这个文件是Apollo自动驾驶系统源代码的一部分。文件定义了一个基础的交通规则类（TrafficRule）。其功能是提供自动驾驶行驶规则的基础框架，包括初始化规则、应用规则、重置规则，并能获取规则名称。</p> <p>在这个基础类中，申明了几个关键的函数（都是虚函数）：</p> <ol> <li> <p>构造函数 <code>TrafficRule()</code>和虚析构函数 <code>virtual ~TrafficRule() = default</code>，它们分别用于创建和销毁交通规则对象。</p> </li> <li> <p><code>bool Init(const std::string&amp; name,const std::shared_ptr&lt;DependencyInjector&gt;&amp; injector)</code>: 是初始化函数，输入参数是规则名称和DependencyInjector对象，可能用于规则对象的初始化。</p> </li> <li> <p><code>common::Status ApplyRule(Frame* const frame, ReferenceLineInfo* const reference_line_info) = 0;</code>是一个纯虚函数，需要在派生类中实现，应用交通规则。</p> </li> <li> <p><code>void Reset() = 0</code> 是一个纯虐函数，需要在派生类中实现，重置交通规则。</p> </li> </ol> <p>文件同时还提供了名为LoadConfig的模板函数，用于从特定路径加载配置。</p> <p>采用这种方式允许自动驾驶系统有很高的灵活性，可以灵活地添加、改变或者移除交通规则。每条新的交通规则都会是这个基础类的子类，并且实现在基础类定义的纯虚函数。</p> <h2>planning_open_space</h2> <h3>coarse_trajectory_generator</h3> <h4>grid_search.h</h4> <p>这个文件是 Apollo 自动驾驶系统中的一部分，特别是在规划模块中。该模块负责规划车辆的路径。它包含一个主要类<code>GridSearch</code>和两个子类<code>Node2d</code>和<code>GridAStartResult</code>。</p> <p><code>Node2d</code>类主要用于存储和操作规划过程中的节点信息，包括节点的位置、路径成本、启发式成本（用于A*搜索）、距离障碍物的距离、前一个节点等。另外，它提供了一些方法，如获取位置信息、路径成本、启发式成本，和前一个节点等。</p> <p><code>GridAStartResult</code>类用于存储A*搜索的结果。包括路径点的X和Y坐标以及路径的总成本。</p> <p>主类<code>GridSearch</code>主要实现了基于网格的路径搜索功能。它包括初始化方法，生成A<em>路径和DP(动态规划)图方法，检查DP图的方法，以及一些私有方法如计算欧几里得距离，生成下一个节点，检查约束，加载A</em>结果等。其中，生成A*路径和生成DP图是规划过程的主要步骤，输入包括开始和结束的位置，XY边界，和障碍物的线段信息，结果包括路径点的坐标和总路径成本。</p> <h4>hybrid_a_star.h</h4> <p>该文件是Apollo自动驾驶平台开源项目中的一部分，提供了 <code>HybridAStar</code> 类所需的声明及成员函数。<code>HybridAStar</code> 被用于车辆路径规划模块，特别是开放空间的系统。</p> <p>这个 <code>HybridAStar</code> 类实现了混合A*算法，这是一种搜索算法用于寻找开放空间中最短的、无碰撞的路径。该文件还定义了一个结构 <code>HybridAStartResult</code> 来保存路径的结果如 x、y 坐标，以及方向、车速、油门、方向盘转角和累积路程等信息。</p> <p>类的公有和私有成员函数包括对路径的切分，节点扩展，有效性检查，没有冲突的速度和加速度生成等功能。</p> <p>类的私有成员变量包括了车辆参数、空间搜索配置信息、车辆动力学参数（如最大转向角、最大曲率等）、路径成本配置、obstacle和搜索节点信息等。</p> <p>此外，这个文件使用了一些来自<code>cyber</code>和<code>common</code>模块的工具函数和类，并提供了Python和C++双语言的接口。</p> <h4>node3d.h</h4> <p>这是一个源代码头文件，定义了Apollo自动驾驶系统中的一个名为<code>Node3d</code>的类。此类是在<code>.</code>目录下的<code>planning_open_space</code>子目录中的<code>coarse_trajectory_generator</code>子目录下建立的，主要用于路径规划的三维节点。</p> <p>该类提供了多个构造函数，创建一个三维节点对象,它存储着空间中的一个点的三维坐标（X，Y，phi）以及与之相关的属性，如该点的旅行成本、启发式成本、坐标网格位置等。另外，<code>Node3d</code>类还包括各种公共成员函数，用于获取和设置这些属性值。</p> <p>此外，这个类还定义了一系列与车辆运动和路径相关的成员变量，例如<code>traversed_x_</code>、<code>traversed_y_</code>和<code>traversed_phi_</code>等，分别代表沿着某个路径的所有X、Y和phi坐标。还有一个预节点的智能指针<code>pre_node_</code>，可以用来追踪到达当前节点的路径。</p> <p>这个类也有一些私有方法，例如计算字符串索引的方法<code>ComputeStringIndex</code>。</p> <p>在文件的末尾，这个类被封装在<code>planning</code>命名空间下的<code>apollo</code>命名空间内，这可能是为了避免与其他库或框架中的相同名称的类产生冲突。</p> <h4>reeds_shepp_path.h</h4> <p>这个文件是Apollo自动驾驶系统的一部分，位于./planning_open_space/coarse_trajectory_generator/目录下，名为reeds_shepp_path.h。它包含两个结构体（ReedSheppPath和RSPParam）和一个类（ReedShepp）。</p> <p>ReedSheppPath结构体定义了一条路径，包含各种信息如用于描述路径的向量（segs_lengths，segs_types），路径的总长度（total_length），路径的成本（cost），以及用于描述车辆状态的向量（x，y，phi，gear）以及半径。</p> <p>RSPParam结构体包括一个布尔标志和三个浮点数，可能用于保存某种特定参数的值。</p> <p>ReedShepp类实现了一种叫做Reed-Shepp path的算法，这种算法用于在机器人路径规划中生成在给定曲率限制条件下的最短路径。类中定义了一系列的成员函数，用于生成所有可能的Reed-Shepp控制路径组合并从中选择最短的一条，生成不同的Reed-Shepp路径，并且实现了这些路径的插值等一系列操作。</p> <h3>trajectory_smoother</h3> <h4>distance_approach_interface.h</h4> <p>文件./planning_open_space/trajectory_smoother/distance_approach_interface.h是一个接口定义文件，它的核心是一个多目标优化接口类&quot;DistanceApproachInterface&quot;。这个类继承自Ipopt包的TNLP类，其中Ipopt是一个用于大型优化问题的开源库。</p> <p>该类定义了一系列的抽象方法，都被设为了虚方法，代表这类的实例需要覆盖这些方法。这些方法在完成优化问题求解过程中都有涉及，例如获取问题的约束、目标函数、雅可比矩阵、初始点和赫西矩阵等等。</p> <p>此外，类中还定义了方法以获取优化后的结果，使得在实施了这个接口的优化问题可以获得一套统一的结果获取方式。</p> <p>此文件属于Apollo自动驾驶系统的一部分，本身并不包含业务逻辑代码，主要目的是定义了一个接口类。后续所有涉及到距离优化方法的计算都需要实施这个接口。</p> <h4>distance_approach_ipopt_cuda_interface.h</h4> <p>这是一个C++头文件，里面定义了一个名为<code>DistanceApproachIPOPTCUDAInterface</code>的类，该类是<code>DistanceApproachInterface</code>的子类。从名字可以推测，这个类提供了一种使用IPOPT(内点优化库)和CUDA (并行计算平台和程序模型库)的接口的方法来处理某种&quot;距离方法&quot;。</p> <p>在类的公开成员中，我们可以看到许多函数，它们主要用于获取优化问题的信息（例如获取问题的上下界，获取问题的起始点）、评估目标函数及其梯度、评估约束以及获取优化结果等。这些都是在实际应用优化算法时需要实现的操作。</p> <p>在类的私有成员中，我们可以看到包含了大量的数据成员。这些数据成员包含着各种参数，例如车辆中的一些物理参数、优化算法中的一些权重参数，以及用于存储计算结果的矩阵等。</p> <p>此外，该文件还包含了一些第三方库的头文件，这在实际操作中，会帮助我们使用这些库提供的功能，包括Eigen，IPOPT，ADOL-C等。</p> <p>此代码来自Apollo项目，其目标是提供一个开放、全面和可靠的自动驾驶平台供他人进行研究和开发。</p> <h4>distance_approach_ipopt_fixed_dual_interface.h</h4> <p>此代码文件是Apollo自动驾驶系统中一个名为“DistanceApproachIPOPTFixedDualInterface”的类的头文件。该类继承自DistanceApproachInterface，提供了一种基于IPOPT库的距离近似方法来平滑开放空间规划的轨迹。</p> <p>该类的主要方法包括：</p> <ul> <li>get_nlp_info、get_bounds_info、get_starting_point：适用于IPOPT的必需方法，提供优化问题的信息。</li> <li>eval_f、eval_grad_f、eval_g、eval_jac_g、eval_h：适用于IPOPT的必需方法，用于求解NLP问题的目标值、梯度、约束及其对应的雅可比矩阵和海森矩阵。</li> <li>finalize_solution：在算法完成后存储或写入解决方案。</li> <li>get_optimization_results：获取优化结果。</li> <li>eval_obj、eval_constraints 和 generate_tapes：用于利用ADOL-C库自动求导。</li> </ul> <p>此类的私有属性包括相关的车辆参数、轨迹规划参数和障碍物信息。此外，还有一些配置项，例如限制条件和目标函数的加权，这些都被用来求解优化问题。</p> <p>最后，还有一些与ADOL-C库相关的私有属性，这些属性用于存储自动求导过程中产生的中间结果。</p> <h4>distance_approach_ipopt_fixed_ts_interface.h</h4> <p>这是一个C++类的头文件，名为 DistanceApproachIPOPTFixedTsInterface，同时该类是 DistanceApproachInterface 的子类。该类是Apollo自动驾驶系统中路径规划模块的一个部分，特别是开放空间轨迹平滑子模块中的一部分。IPOPT是一个开源的优化算法库，可以进行大规模非线性优化，因此这个类可能包含在车辆在开放空间中进行轨迹规划时的优化算法的实现。</p> <p>类中定义了一系列的私有成员变量，这些变量通常是类的内部状态，包括车辆状态、障碍物的位置、路径优化的权重等信息。</p> <p>类的public接口主要包括交互的方法，用以获取非线性规划问题的信息，如获取非线性规划问题的约束、目标函数及其梯度、jacobian矩阵，hessian矩阵等信息，这些信息将被用于IPOPT进行优化。</p> <p>注意到类中有两个构造函数，一个包含了具有OpenSpaceConfig参数，一个包含了DistanceApproachConfig参数，表明该类可以基于多种配置进行实例化。</p> <p>此外，类中部分公共方法和私有数据成员处于 <code>//*************** start ADOL-C part ***********************************</code> 和 <code>//*************** end ADOL-C part ***********************************</code> 注释标记内部，表示这部分与ADOL-C库有关，ADOL-C是一个自动微分库，常用于优化问题中计算函数导数。这意味着这个类使用了自动微分技术进行梯度计算。</p> <p>总的来说，这个类是Apollo自动驾驶系统中用于求解开放空间轨迹平滑问题的优化求解接口。</p> <h4>distance_approach_ipopt_interface.h</h4> <p>这个是一个C++头文件，定义了一个名为<code>DistanceApproachIPOPTInterface</code>的类，它是一个路径规划模型的组件。这个类属于<code>apollo</code>命名空间下的<code>planning</code>子命名空间。</p> <p><code>DistanceApproachIPOPTInterface</code>类提供了以下功能:</p> <ul> <li>使用IPOPT（Interior Point Optimizer），一个开源的数值优化库，来解决非线性规划问题，这种问题在开放空间轨迹平滑中经常出现。</li> <li>这个类继承自<code>DistanceApproachInterface</code>，显然是<code>DistanceApproachInterface</code>接口的一个实现。</li> <li>类中的各对函数如<code>get_nlp_info()</code>, <code>get_bounds_info()</code>, <code>get_starting_point()</code>, <code>eval_f()</code>, <code>eval_grad_f()</code> , <code>eval_g()</code>, <code>eval_jac_g()</code> 和 <code>eval_h()</code>等，用于实现不同的IPOPT算法步骤，例如获取问题信息，获取问题边界，获取算法起点，评估目标函数和梯度，评估约束等。</li> <li><code>finalize_solution()</code>函数用于完成算法后的最终解决方案。</li> </ul> <p>此代码采用了Eigen库进行矩阵运算，使用adolc库来进行自动微分操作，并使用了coin库中的Ip类，称为Interior Point Method，也是用于规划优化问题的一种方法。</p> <p>此外，此类还定义了大量的私有成员变量，主要用于存储规划问题的参数和临时结果。例如<code>num_of_variables_</code>, <code>num_of_constraints_</code>, <code>horizon_</code>, <code>lambda_horizon_</code>, <code>miu_horizon_</code>, <code>ts_</code>, <code>ego_</code>, <code>xWS_</code> 等等。</p> <h4>distance_approach_ipopt_relax_end_interface.h</h4> <p>此头文件定义了一个名为 <code>DistanceApproachIPOPTRelaxEndInterface</code> 的类，该类继承自 <code>DistanceApproachInterface</code>。这个类属于 Apollo 自动驾驶系统的规划模块中，专门用于处理开放空间轨迹路径平滑的部分。</p> <p>该类用于处理“距离方法”优化问题，特别是在处理车辆末端车位的情况时，目标是通过调整车辆轨迹来实现更好的滑动效果。它使用 IPOPT（Interior Point OPTimizer，内点优化器）作为优化求解器，而且使用了 ADOL-C（Automatic Differentiation by OverLoading in C++，C++中的自动微分重载）库进行自动微分来计算目标及约束函数的梯度，以大大提高优化的效率。</p> <p>类中定义了一系列的函数，包括实现罚分方法（如 <code>eval_f</code>, <code>eval_grad_f</code> 等）、计算约束（如 <code>eval_g</code>,<code>check_g</code>, <code>eval_jac_g</code> 等）、计算目标函数（如 <code>eval_obj</code>)、获取优化结果（如 <code>get_optimization_results</code>）、中的未知数量（如 <code>get_bounds_info</code>, <code>get_nlp_info</code>等）、求解优化问题并存储解（<code>finalize_solution</code>）以及生成 ADOL-C 所需的 tape（<code>generate_tapes</code>）等。</p> <p>类的构造函数需要很多参数，包括时间范围、样本间隔、车辆状态、预测路径、预测速度、起始状态、终止状态、障碍物信息等，这些参数都是进行规划和优化时必要的信息。</p> <p>类还定义了众多私有变量，这些变量主要用于保存输入数据和优化结果，以及进行优化所需要的参数，比如时间间隔、车辆的尺寸、安全距离、车辆最大速度和加速度等。此外，还包括一些标记位，用于决定是否购买某些特性，如 <code>enable_jacobian_ad_</code> 用于决定是否启用 ADOL-C 计算雅可比矩阵。</p> <p>综上，<code>DistanceApproachIPOPTRelaxEndInterface</code> 是一个定义了如何进行开放空间轨迹的优化规划的类。</p> <h4>distance_approach_ipopt_relax_end_slack_interface.h</h4> <p>这个头文件是Apollo自动驾驶系统中，用于规划开放空间轨迹的程序。主要定义了一种距离方法接口类—<code>DistanceApproachIPOPTRelaxEndSlackInterface</code>，这个类是<code>DistanceApproachInterface</code>的子类，用以实现优化的轨迹平滑。</p> <p>该类中主要定义了一些函数和方法，涵盖了Ipopt优化过程的所有步骤，如获取优化问题的信息，获取参数的边界信息，获取初始点，求解目标函数的值及其梯度，求解约束函数，及在求解完成后返回解等。此外，还定义了一些用到的私有变量和参数，以及构造和析构函数。</p> <p>此文件涉及的库包括Eigen、ADOL-C（用于自动微分）、openMP(用于并行计算)、Coin-Ipopt等。这些库负责矩阵操作、自动微分、并行计算和数值优化等功能。</p> <p>所有的函数都被设计为可以用ADOL-C库的自动微分功能，这能提高数值优化的速度和精度。</p> <h4>distance_approach_problem.h</h4> <p>这个程序文件是一个C++头文件，属于Apollo自动驾驶系统中的规划模块的子模块，主要用于处理开放空间的轨迹平滑问题。</p> <p>文件定义了一个名为DistanceApproachProblem的类，该类似乎是为解决轨迹优化问题而设计的。该类包含两个构造函数，一个接受PlannerOpenSpaceConfig类型参数，另一个接受DistanceApproachConfig类型参数。</p> <p>文件中最主要的函数是Solve()，该函数可能被设计用于解决优化问题。该函数接收一系列输入参数，包括车辆当前的状态、目标状态、已经通过的控制信号、时间地平线、时间步长、自我车辆状态、世界状态、预暖状态以及障碍物相关的信息。函数最后将优化后的状态、控制信息和时间保存在指定的变量中。</p> <p>这个头文件还包含了一些其他模块和库，例如Eigen线性代数库，Ipopt优化库，gflags配置库，以及各种从Apollo自己的代码库中导入的文件。许多这些额外的包含文件似乎都与Ipopt优化方法有关。</p> <h4>dual_variable_warm_start_ipopt_interface.h</h4> <p>这是Apollo开源自动驾驶项目中的一部分，文件路径为<code>./planning_open_space/trajectory_smoother/dual_variable_warm_start_ipopt_interface.h</code>。它是封装了用于开放空间轨迹规划的IPOPT库的接口。IPOPT（Interior Point OPTimizer）是一个用于大规模非线性优化的库。</p> <p>此头文件中定义了<code>DualVariableWarmStartIPOPTInterface</code>类，继承自<code>Ipopt::TNLP</code>。它有构造函数、getter函数用于获取优化结果、override过的Ipopt库中的各种方法（如get_nlp_info、get_bounds_info等用于优化的函数）、private区域的一些变量以及一些执行ADOL-C部分的函数（Automatic Differentiation by OverLoading in C++）。</p> <p>关于该类的职责，根据类中定义的各种方法和数据成员，主要执行以下功能：定义优化问题（大小、约束、目标、初始点等）、计算目标和约束的梯度、结果的保存等。总之，这个类是用于在开放空间规划中应用IPOPT优化轨迹的工具类。</p> <h4>dual_variable_warm_start_ipopt_qp_interface.h</h4> <p>这是一个关于 Apollo 自动驾驶系统的源代码文件，这个文件主要是在实现一个名为 &quot;DualVariableWarmStartIPOPTQPInterface&quot; 的类。这个类负责在规划开放空间中进行路径拟合。</p> <p>文件是 C++编写的，并且end是 .h，这表示它是一个头文件，主要包含一些类的定义和函数的声明。</p> <p>此类主要使用 IPOPT（Interior Point OPTimizer, 内点优化器）库来解决优化问题。Ipopt 是一种开放源代码软件库，用于大规模求解连续优化问题。</p> <p>DualVariableWarmStartIPOPTQPInterface 类提供了多种方法，包括获取优化结果，检查解决方案，获取 NLP 信息，获取问题的边界值，获取算法的起点，计算目标函数，计算梯度，计算约束残差，评估雅可比矩阵和评估拉格朗日算子的黑塞矩阵，并在计算完成后保存/写入解决方案等。其中一些方法覆盖了 Ipopt::TNLP 类的虚拟函数。</p> <p>此类还含有一些私有的数据成员来存储关于问题的信息，比如约束数量，变量数量，权重，阻碍物的大小，边缘数等。</p> <p>这个文件的顶部还包含了一些其他常用库的头文件，比如对矩阵和向量运算有很好支持的 Eigen 库，和 Google 自己的 protobuf 库用于序列化结构化的数据。</p> <p>以上就是这份代码文件的大致内容。</p> <h4>dual_variable_warm_start_osqp_interface.h</h4> <p>这个程序文件名为&quot;dual_variable_warm_start_osqp_interface.h&quot;，是 Apollo 自动驾驶系统中的一部分，属于路径规划部分的开放空间轨迹平滑器模块。</p> <p>主要定义了一个名为&quot;DualVariableWarmStartOSQPInterface&quot;的类。这个类中定义了用于路径规划的方法和参数，主要用于优化轨迹规划的过程。</p> <p>OSQP（Operator Splitting Quadratic Program）是一个用于解决凸二次规划（quadratic programming, QP）问题的求解器，它在轨迹优化、机器人控制、机器学习等领域有着广泛的应用。</p> <p>&quot;DualVariableWarmStartOSQPInterface&quot;类中的主要方法包括:</p> <ul> <li>get_optimization_results()：获取优化的结果，包括l_warm_up 和 n_warm_up（两个优化参数）。</li> <li>optimize()：执行优化。</li> <li>assemble_P()，assemble_constraint() 和 assembleA()：用于组装优化问题的一些参数和约束条件。</li> <li>check_solution()：检查优化结果。</li> </ul> <p>&quot;DualVariableWarmStartOSQPInterface&quot;类中的数据成员包括路径/轨迹的信息（如ego_，l_warm<em>up</em>，n_warm<em>up</em>），优化参数（如osqp<em>config</em>，g_，check<em>mode</em>），初始状态（xWS<em>），车辆信息（如wheelbase</em>，w<em>ev</em>，l<em>ev</em>），环境障碍物（如obstacles_A, obstacles<em>b</em>），等。</p> <h4>dual_variable_warm_start_problem.h</h4> <p>这个头文件定义了一个名为&quot;DualVariableWarmStartProblem&quot;的类，它是Apollo自动驾驶软件在路径规划模块中使用的类。路径规划模块的目标是找到一条从A点到B点的安全、舒适、有效的路径。</p> <p>&quot;DualVariableWarmStartProblem&quot;类似乎主要用于创建和管理路径规划问题的初始解决方案。它有两种构造函数，一个接收&quot;PlannerOpenSpaceConfig&quot;参数，另一个接收&quot;DualVariableWarmStartConfig&quot;参数。</p> <p>这个类中有一个重要的公共方法名为&quot;Solve&quot;，其目的应该是求解优化问题并获得各个变量的初始热启动值。它接收了一系列参数包括时间, ego车辆状态,障碍物等信息，并返回一些矩阵作为优化问题的解。</p> <p>这个文件还包含了一些其他需要的头文件，例如&quot;Eigen/Dense&quot;用于线性代数计算，&quot;dual_variable_warm_start_ipopt_interface.h&quot;，&quot;dual_variable_warm_start_ipopt_qp_interface.h&quot;等头文件是用于定义与优化求解器Ipopt交互的接口等。</p> <p>此外，这个文件遵守Apache 2.0许可，这意味着我们可以自由使用和修改这个文件，但必须要遵守许可协议中提到的一些条件，如需要声明原作者等。</p> <h4>dual_variable_warm_start_slack_osqp_interface.h</h4> <p>这是Apollo项目的一部分,特别是与车辆规划和开放空间相关的部分。Apollo项目是一个开源的自动驾驶汽车系统。</p> <p>这个具体文件定义了一个名为 <code>DualVariableWarmStartSlackOSQPInterface</code> 的类，这个类主要是用来处理开放空间规划中的平滑路径问题和碰撞检测。这个类使用了OSQP（Open Source Quadratic Program solver）库来进行二次规划优化。</p> <p>该类有专门的方法用于组装和优化约束矩阵，并可以获取优化的结果。此外，还有一些判断解决方案和打印矩阵的方法。</p> <p>它使用一些私有变量来保存配置，优化变量的数目，约束的数目，时间间隔，障碍的信息等等。</p> <p>此文件根据Apache License 2.0进行授权，可以在遵循许可证规定的情况下进行修改和使用。</p> <h4>iterative_anchoring_smoother.h</h4> <p>这个文件是Apollo自动驾驶项目中的一部分，特定于路径平滑的开发。特别是，它是开放空间中迭代锚定平滑器的头文件。</p> <p>IterativeAnchoringSmoother类主要完成路径和速度曲线的平滑处理和碰撞检测。</p> <p>人员可以在特定的参数和变量框架下设置路径曲线的起始位置和方向，然后利用平滑器来调整和微调它们。</p> <p>此类拥有一系列public和private的方法，主要有：</p> <ol> <li>Smooth: 这是主要的公共函数，接受一系列参数，包括初始加速度，初始速度，以及障碍物列表，它将原始路径和软速进行平滑。</li> <li>AdjustStartEndHeading: 它可以根据给定的参数列表，对起始的路径和终点的路径进行调整。</li> <li>ReAnchoring：它将重新锚定和重新指定特定的路径点，主要进行曲线优化。</li> <li>CheckCollisionAvoidance: 它检查优化后的曲线是否与障碍物发生碰撞。</li> </ol> <p>此文件还包含一系列的私有变量，用来存放车辆参数，例如车辆长宽和车辆的位置偏移等。</p> <h4>planning_block.h</h4> <p>这是一个属于Apollo开源自动驾驶系统的源代码文件。主要是来自“planning_open_space”模块中的子模块“trajectory_smoother”的头文件，命名为“planning_block.h”。这个文件主要处理在NVIDIA和AMD GPU硬件平台之间的兼容性问题。</p> <p>在文件中，首先根据不同的GPU平台（NVIDIA或AMD）包含了不同的头文件，并定义了相应的宏来切换这两个平台的特定函数。主要是改变了如内存操作（比如设备与主机之间的数据传输）和设备属性获取等功能。</p> <p>接着，文件定义了一个名称空间&quot;apollo&quot;，其中含有另一个名称空间&quot;planning&quot;。在这两个名称空间里，定义了几个函数和宏。</p> <p>函数&#8217;fill_lower_left_gpu&#8217; 和 &#8216;fill_lower_left&#8217; 可能是用于填充某个数据结构的左下部分；函数 &#8216;data_transfer_gpu&#8217; 和 &#8216;data_transfer&#8217; 主要用于GPU和CPU之间的数据传输。为这些操作定义了错误处理宏 &#8216;CUDA_CHECK&#8217;，用于检查每个CUDA操作是否成功，若不成功则抛出错误信息。</p> <p>尾部则是对名称空间的封闭。总的来说，这份代码主要关注的是GPU的操作和处理，包括如何初始化GPU，如何在设备间传输数据，以及如何处理低水平的硬件错误。</p> <h3>utils__</h3> <h4>open_space_roi_util.h</h4> <p>文件 &quot;./planning_open_space/utils/open_space_roi_util.h&quot; 是 Apollo 自动驾驶系统中的一部分。它是一个头文件，定义了一个名为 &quot;OpenSpaceRoiUtil&quot; 的类。这个类封装了一系列与自动驾驶规划相关的静态方法，主要涉及到在开放空间中定义和处理 region of interest (ROI)，即车辆预计活动的区域的边界和方向。</p> <p>以下是类中定义的一些关键方法：</p> <ul> <li>FormulateBoundaryConstraints：构建开放空间规划所需的边界约束。</li> <li>GetRoiXYBoundary：提取ROI的XY边界。</li> <li>TransformByOriginPoint：根据原点和车头方向对ROI或点进行坐标变换。</li> <li>LoadObstacles：加载障碍物信息，并进行过滤和转换。</li> <li>FilterOutObstacle：判断障碍物是否需要过滤出。</li> <li>LoadObstacleInHyperplanes：将障碍物顶点表示转换为线性不等式表示，并加载到Hyperplane中。</li> <li>GetHyperPlanes：从障碍物顶点获取Hyperplane的参数向量。</li> <li>IsPolygonClockwise，AdjustPointsOrderToClockwise：检查和调整多边形顶点的顺序。</li> <li>UpdateParkingPointsOrder：更新停车点的顺序。</li> </ul> <p>这个类的方法大多数都是静态方法，说明这个类主要被用于提供一些工具函数，而不是去存储某些状态或者数据。</p> <h4>open_space_trajectory_optimizer_util.h</h4> <p>这是一个头文件，名称为<code>open_space_trajectory_optimizer_util.h</code>，是Apollo自动驾驶系统中<code>planning</code>模块的一部分。这个文件定义了一个名为<code>OpenSpaceTrajectoryOptimizerUtil</code>的类，这个类提供一系列静态方法，主要为处理和优化车辆在开放空间（比如停车场）的路径轨迹。</p> <p>具体来说，该类定义了以下功能：</p> <ol> <li> <p><code>BoxOverlapObstacles</code>：检查一个2D的矩形盒子（Box2D）是否与给定的障碍物冲突。障碍物由一系列的2D线段（LineSegment2d）表示。</p> </li> <li> <p><code>GeneratePointBox</code>：将一系列的2D线段（LineSegment2d）和一对浮点数转化为一系列的2D向量（Vec2d），这可以用于生成Vehicle Bounding Boxes。</p> </li> <li> <p><code>PathPointNormalizing</code>和<code>PathPointDeNormalizing</code>：这两个方法分别用于标准化和反标准化路径点，涉及的转换包括旋转和位移。</p> </li> </ol> <p>以上方法都是静态方法，可以直接通过类名来调用，而不需要创建类的实例。</p> <h2>pnc_map</h2> <h3>lane_follow_map</h3> <h4>lane_follow_map.h</h4> <p>这个文件名为&quot;lane_follow_map.h&quot;的头文件是属于从PncMapBase基类派生的LaneFollowMap类的声明。它是Apollo项目中planning模块关于路径跟踪地图的一部分。</p> <p>Header文件引入了一些所需的库和消息以供在其内部使用，这些包括列表、内存、字符串、哈希集和向量等STL库以及protobuf定义的消息。</p> <p>LaneFollowMap类定义了一系列的方法，包括：</p> <ul> <li>构造和析构函数；</li> <li>处理命令是否可能；</li> <li>更新命令选项；</li> <li>获取路径段；</li> <li>扩展路径段；</li> <li>获取未来路线的关键点；</li> <li>获取路线的终点；</li> <li>根据ID获取线路；</li> <li>获取最近的点；</li> <li>从路线点获取最近的索引号；</li> <li>转换路线点至车道点；</li> <li>转换路线段至车道段等等。</li> </ul> <p>此类对计划路径的生成、处理和扩展路段以及获取关键道路信息等关键功能提供了支持，它在自动驾驶系统的路径规划过程中发挥了重要作用。最后，注册这个类为cyber框架的插件。</p> <h2>scenarios</h2> <h3>bare_intersection_unprotected</h3> <h4>stage_intersection_cruise.h</h4> <p>这个文件是来自Apollo自动驾驶项目的一部分，具体地，该文件是用于处理无保护的空交叉口场景下的驾驶航段的相关定义。</p> <p>源代码是在Apollo命名空间中的Planning模块。该模块是进行自动驾驶系统路线规划的关键部分。</p> <p>文件主要定义了一个名为<code>BareIntersectionUnprotectedStageIntersectionCruise</code>的类，这个类从<code>BaseStageCruise</code>类派生（继承）。<code>BareIntersectionUnprotectedStageIntersectionCruise</code>类用于处理无人车在无信号灯控制的交叉口航行的特定阶段。</p> <p>在该类中，定义了两个公有方法和一个私有方法。其中，公有方法<code>Process()</code>是覆盖了基类中的同名方法，用于处理航段。私有方法<code>FinishStage()</code>可能用于当前阶段结束时的一些终止处理。然后有一个公有方法<code>GetTrafficSignOverlap()</code>可能用于获取当前航段中与交通标志重合的部分。</p> <p>最后，<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏将这个类注册为插件供使用。这可能是用于动态加载和卸载这个类的功能。</p> <p>从目录结构看，这个代码文件应该是Apollo自动驾驶系统中一部分，文件路径指示它可能是关于路线规划的一部分，特别是在无信号灯交叉口的情况下的航行。</p> <h4>stage_approach.h</h4> <p>这个源代码文件是Apollo自动驾驶系统项目的一部分，具体位于./scenarios/bare_intersection_unprotected目录下。文件名stage_approach.h表明，这是一个头文件，主要定义了一个名为BareIntersectionUnprotectedStageApproach的类。</p> <p>这个类继承自Stage基类，其主要功能应该是处理无保护措施的裸露交叉口的驶近阶段。在公开道路驾驶中，交叉口是比较复杂且危险的情境之一，这个类针对处理这个情况。</p> <p>方法包括：</p> <ol> <li>Process方法：可能是处理当前驶近交叉口的核心逻辑。</li> <li>CheckClear方法：检查某条参考线路是否清晰，可能是检查该路径中是否有阻碍物的逻辑。</li> <li>FinishStage方法：可能是完成裸露交叉口驶近阶段的操作。</li> </ol> <p>而类的私有成员包括一个ScenarioBareIntersectionUnprotectedConfig的实例，用于配置相关参数。还有一个名为counter_的整型变量，可能用于计数。</p> <h4>bare_intersection_unprotected_scenario.h</h4> <p>这个源代码文件是Apollo自动驾驶项目中的一个部分，具体来说，它属于规划模块中处理特定场景的代码部分。文件名中的&quot;bare_intersection_unprotected&quot;指出这个场景是非信号控制的十字路口。</p> <p>它定义了两个主要的类：</p> <ol> <li><code>BareIntersectionUnprotectedContext</code>：这个结构继承自<code>ScenarioContext</code>，保存了特定场景下需要的状态和配置信息，例如当前的路口id和配置数据。</li> <li><code>BareIntersectionUnprotectedScenario</code>：这个类继承自<code>Scenario</code>基类，它主要包含一系列的方法来处理场景。<code>Init</code>方法用来初始化场景，<code>GetContext</code>方法用来获取场景上下文，<code>IsTransferable</code>方法用来判断是否可以转换场景，<code>Enter</code>方法定义进入此场景时的行为。</li> </ol> <p>该文件还使用<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏进行插件的注册，该插件名为`Apollo::planning::BareIntersectionUnprotectedScenario，以让Cyber框架的插件管理器能够识别和加载这个场景。</p> <p>这个头文件中还包含了一些基础的引用，如内存、字符串、protobuf消息，以及 Apollo 特定的包，如规划相关的框架和工具。</p> <h3>emergency_pull_over</h3> <h4>emergency_pull_over_scenario.h</h4> <p>这是一个属于 Apollo 自动驾驶项目的源代码文件，具体位于 &quot;./scenarios/emergency_pull_over&quot;路径下。此文件定义了两个具体结构，分别为&quot;EmergencyPullOverContext&quot;和&quot;EmergencyPullOverScenario&quot;。</p> <p>EmergencyPullOverContext 结构继承自 ScenarioContext，其中有一些与应急停车相关的配置信息。</p> <p>EmergencyPullOverScenario 是一个类，继承自 Scenario。它覆盖了几个重要方法，包括初始方法(Init)，获取应急停车场景上下文方法(GetContext)，判断场景是否可以转换方法(IsTransferable)，框架进入和退出方法(Enter，Exit)。</p> <p>这个源文件很可能是系统用来处理紧急情况下车辆拉停的场景的部分代码。</p> <h4>stage<em>approach.h</em></h4> <p>这是一个名为&quot;stage_approach.h&quot;的C++头文件，它是一个源码项目中的一部分。这个头文件定义了一个名为&quot;EmergencyPullOverStageApproach&quot;的类，此类属于&quot;apollo::planning&quot;命名空间。</p> <p>&quot;EmergencyPullOverStageApproach&quot;类是&quot;Stage&quot;类的子类，即它从&quot;Stage&quot;类继承。它覆盖了基类中的&quot;Process&quot;函数，并定义了一个私有函数&quot;FinishStage&quot;。</p> <p>&quot;stage_approach.h&quot;是在模块&quot;./scenarios/emergency_pull_over&quot;下。从代码和路径名可以推断，这个文件可能是在一个汽车自动驾驶系统上用来描述紧急停车场景下的一种阶段或步骤：即靠近阶段（Approach stage）。</p> <p>此文件受Apache 2.0许可协议保护，具体的许可协议信息在文件的开始部分有详细说明。</p> <h4>stage_slow_down.h</h4> <p>这个文件是Apollo自动驾驶系统项目中的一部分，具体来说是关于紧急停车（Emergency Pull Over）场景中的“减速”阶段的实现。Apollo是一个开源的自动驾驶系统。</p> <p>文件中定义了一个名为 &quot;EmergencyPullOverStageSlowDown&quot;的类，它继承自&quot;Stage&quot;类。这个类主要处理紧急停车场景的&quot;减速&quot;阶段。该类定义了两个函数，一个是&quot;Process&quot;，用于处理当前的阶段；另一个是&quot;FinishStage&quot;，用于完成当前阶段的处理。</p> <p>文件还包含了一些宏定义操作，这些操作用来注册&quot;EmergencyPullOverStageSlowDown&quot;类。</p> <p>总体而言，这个文件是用C++编写的，且遵循Apache 2.0许可协议。</p> <h4>stage_standby.h</h4> <p>这是一个C++头文件，名为&quot;stage_standby.h&quot;，位于&quot;./scenarios/emergency_pull_over&quot;目录下，属于Apollo项目。Apollo是一个开源自驾车平台。</p> <p>这个文件定义了一个名为&quot;EmergencyPullOverStageStandby&quot;的类，这个类继承自&quot;Stage&quot;类。在该类中，定义了&quot;Process&quot;方法，该方法覆盖了基类中的同名方法，接收一个TrajectoryPoint和一个Frame类型的参数；以及一个&quot;FinishStage&quot;方法。此外，这个类还定义了一个名为&quot;scenario<em>config</em>&quot;的EmergencyPullOverConfig类型的变量。</p> <p>此外，这个类在Apollo的插件管理器中注册作为一个插件。</p> <p>所有的代码都在命名空间&quot;apollo::planning&quot;下，表示这个类是Apollo自动驾驶系统中计划模块的一部分。</p> <h3>emergency_stop</h3> <h4>emergency_stop_scenario.h</h4> <p>这个源代码文件是Apollo自动驾驶框架中的一部分，具体来说是在处理紧急停车（Emergency Stop）场景中使用的。文件定义了一个<code>EmergencyStopScenario</code>类，这个类继承自<code>Scenario</code>基类。</p> <p><code>EmergencyStopScenario</code>类包含了几个重要的公共成员函数：<code>Init()</code>，<code>GetContext()</code>，<code>IsTransferable()</code>，和<code>Process()</code>。这些函数分别对应紧急停车场景的初始化，获取上下文信息，检查是否可以从当前场景转换到其他场景，以及处理给定的当前车辆状态和环境帧的操作。</p> <p>此外，该类还包含一个私有变量<code>init_</code>，用来标识该类是否已经初始化，并且也有一个私有<code>EmergencyStopContext context_</code>为了储存场景相关的上下文信息。</p> <p>文件还定义了一个<code>EmergencyStopContext</code>的结构体，该结构体继承自<code>ScenarioContext</code>，用于存储紧急停车场景的配置信息。</p> <p>该文件的目的是提供紧急停车场景下车辆决策的处理框架。</p> <h4>stage_approach.h__</h4> <p>这是一个定义在Apollo自动驾驶系统中的头文件，具体来说，位于计划模块（planning module）的应急停车（emergency stop）场景下。</p> <p>这个头文件定义了一个名为&quot;EmergencyStopStageApproach&quot;的类，这个类继承自&quot;Stage&quot;类。&quot;Stage&quot;类是计划模块中控制车辆行为的关键部分，并提供了一个名为&quot;Process&quot;的方法，此方法需要在各个不同的子类中实现。</p> <p>&quot;EmergencyStopStageApproach&quot;类有一个私有方法&quot;FinishStage&quot;，并且持有一个&quot;ScenarioEmergencyStopConfig&quot;的实例。</p> <p>并且，这个类也被注册到了&quot;CYBER_PLUGIN_MANAGER&quot;中，这意味着Apollo运行时可以动态地加载和卸载这个&quot;Stage&quot;。</p> <h4>stage<em>standby.h</em></h4> <p>这是一个C++头文件，位于项目的<code>./scenarios/emergency_stop</code>目录下，名为<code>stage_standby.h</code>。它定义了一个名为<code>EmergencyStopStageStandby</code>的类，这个类是<code>Stage</code>类的子类。</p> <p><code>EmergencyStopStageStandby</code>类中定义了一个公开的方法<code>Process</code>，此方法接受一个<code>TrajectoryPoint</code>类型的常量引用和一个<code>Frame</code>类型的指针，然后返回<code>StageResult</code>类型的结果。此方法被标记为<code>override</code>，意味着它在子类中覆盖了父类的同名方法。</p> <p>此外，类中还定义了一个私有方法<code>FinishStage</code>，它返回一个<code>StageResult</code>类型的结果。</p> <p><code>EmergencyStopStageStandby</code>类还定义了一个私有的<code>ScenarioEmergencyStopConfig</code>类型的数据成员<code>scenario_config_</code>。</p> <p>文件的最后部分使用了<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏，用于向系统注册<code>EmergencyStopStageStandby</code>类作为<code>Stage</code>类型的插件，这意味着<code>EmergencyStopStageStandby</code>具有一些特定的功能，使其能够作为插件使用。</p> <h3>lane_follow</h3> <h4>lane_follow_scenario.h</h4> <p>这是Apollo自动驾驶框架的一部分，特别是其路径规划模块的部分。文件名为&quot;lane_follow_scenario.h&quot;，这表明它定义了一个名为&quot;LaneFollowScenario&quot;的类，这个类是车道跟随场景的实现。</p> <p>&quot;LaneFollowScenario&quot;类派生自&quot;Scenario&quot;类并重写了其中的两个方法：GetContext和IsTransferable。&quot;GetContext&quot;方法用于获取场景上下文，而&quot;IsTransferable&quot;方法用于判断当前场景是否可以转移至其他场景。</p> <p>此外，这个文件还包含很多包括 &quot;common_msgs&quot;，&quot;plugin_manager&quot;，&quot;status&quot;，&quot;util&quot;，&quot;planning_base&quot;等Apollo框架的其他模块的头文件。</p> <p>请注意，这个头文件的主要目标是声明&quot;LaneFollowScenario&quot;类及其方法，文件中并未给出具体实现。那将在对应的.cpp文件中完成。</p> <p>这个头文件还使用了&quot;Cyber&quot;中的&quot;PLUGIN_MANAGER_REGISTER_PLUGIN&quot;宏来注册&quot;LaneFollowScenario&quot;类作为Plugin，允许动态加载和卸载。</p> <h4>lane_follow_stage.h</h4> <p>此文件是 Apollo 自动驾驶系统中的一个头文件（.h文件），属于Planning模块的一个子模块 scenarios 的 lane_follow 子场景。</p> <p>主要定义了 LaneFollowStage 类，该类继承自 Stage 类。整个类定义都放在 apollo 和 planning 的命名空间中。该文件主要做路径规划，在车道跟随场景中使用。</p> <p>LaneFollowStage 类具有以下主要的成员函数：</p> <ul> <li>Process()：基于规划初始点和帧，处理跟随车道的场景。在后续实现文件中会进行具体实现。</li> <li>PlanOnReferenceLine()：基于规划起始点、帧以及参考线信息，在参考线上进行规划。</li> <li>PlanFallbackTrajectory()：当车道跟随失败时，规划出备用的路径。</li> <li>GetStopSL()：获取停车点的位置。</li> <li>RecordObstacleDebugInfo()：记录障碍物的调试信息。</li> </ul> <p>此外，还在 cyber namespace 下注册了 LaneFollowStage 类作为插件。</p> <p>以上都是在阐述代码主要关注的功能模块，具体的代码实现逻辑是在对应的 .cc （源文件）中完成的。</p> <h3>park_and_go</h3> <h4>tage_adjust.h</h4> <p>你所展示的源代码文件是一个C++头文件，属于Apollo开源自动驾驶项目的一部分。其中，定义了一个名为<code>ParkAndGoStageAdjust</code>的类，这个类是<code>Stage</code>类的派生类，是自动驾驶场景中的一类特定阶段（场景中的停车及跳过调整阶段）的表示。</p> <p><code>ParkAndGoStageAdjust</code>类中定义了两个公有方法和一个私有方法：</p> <ul> <li>公有方法<code>Process</code>，接受两个参数（初始轨迹点和帧），并返回一个<code>StageResult</code>类型的结果。它被标记为override，意味着它覆盖了基类中的同名方法。</li> <li>私有方法<code>FinishStage</code>和<code>ResetInitPosition</code>，可能用于在完成阶段后的清理和重置状态。</li> </ul> <p>该文件还显示了一个名为<code>ParkAndGoContext</code>的结构类型，但没有给出更多信息。</p> <p>另外该文件还通过<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏提供了Apollo插件管理系统用于注册<code>ParkAndGoStageAdjust</code>类的必要信息。</p> <p>以上这些信息提供了<code>ParkAndGoStageAdjust</code>类在系统中的基本展现结构和地位，但具体功能和工作原理还需要看到更多代码或者项目文档来了解。</p> <h4>stage_cruise.h</h4> <p>该文件是Apollo自动驾驶系统中的一个模块，名为&quot;ParkAndGoStageCruise&quot;，它是规划模块的一部分，特别是在&quot;Park and Go&quot;（停车和行驶）场景下的&quot;巡航&quot;阶段。</p> <p>该类继承自Stage类，并定义了一些公有和私有的成员方法。如&quot;Process&quot;方法是公有的，用于处理输入的轨迹点和帧；&quot;FinishStage&quot;和&quot;CheckADCParkAndGoCruiseCompleted&quot;则是私有的，分别用于结束当前阶段和检查自动驾驶汽车的&quot;停车和行驶&quot;巡航是否已完成。</p> <p>此外，这个类定义了一个名为&quot;ParkAndGoStatus&quot;的枚举，包含了五个可能的状态：CRUISING（巡航）、CRUISE_COMPLETE（巡航完成）、ADJUST（调整）、ADJUST_COMPLETE（调整完成）和FAIL（失败）。</p> <p>此文件也注册了&quot;ParkAndGoStageCruise&quot;这个插件到&quot;Cyber Plugin Manager&quot;中，将这个类作为一个可以使用的插件。</p> <h4>util.h_</h4> <p>这个源代码文件是Apollo自动驾驶系统项目中的一部分，特别是其规划模块中的“Park and Go”（停车和出发）场景相关的一部分。该文件中主要定义了三个检查函数：</p> <ol> <li> <p><code>CheckADCSurroundObstacles</code>：该函数用于检查自动驾驶汽车（Autonomous Driving Car, ADC）周围是否有障碍物。</p> </li> <li> <p><code>CheckADCHeading</code>：该函数用于检查ADC的航向是否正常。</p> </li> <li> <p><code>CheckADCReadyToCruise</code>：该函数用于检查ADC是否准备好巡航。</p> </li> </ol> <p>这三个函数分别接受不同的参数以实现各自的功能，包括ADC的位置，航向，车辆状态提供者，参考线信息等等。在文件的开头，它引用了其他需要的头文件，例如，ADC的位置是通过&quot;modules/common/math/vec2d.h&quot;文件提供的2D向量类来表示的。</p> <p>另外，此文件在Apollo开源软件许可（Apache License, Version 2.0）下对公众开放，著作权归Apollo所有。</p> <h4>stage_check.h</h4> <p>这个源代码文件是Apollo项目中的一部分，特别是这个项目的&quot;规划&quot;模块中的&quot;停车并前进&quot;场景。这个头文件定义了一个名为<code>ParkAndGoStageCheck</code>的类，该类继承自<code>Stage</code>基类。它主要有四个方法，分别是<code>Process</code>，<code>FinishStage</code>，<code>CheckObstacle</code>和<code>ADCInitStatus</code>。</p> <p><code>Process</code>方法是一个重写自基类的方法，需要提供一个轨迹点和一个框架作为输入。</p> <p><code>FinishStage</code>方法是一个私有方法，负责完成舞台，需要一个布尔参数来表示是否成功。</p> <p><code>CheckObstacle</code>检查参考线信息中的障碍物。</p> <p><code>ADCInitStatus</code> 用于初始化自动驾驶车辆的状态。</p> <p>此外，这个头文件还注册了一个将<code>ParkAndGoStageCheck</code>类添加到插件管理器的插件。</p> <h4>stage_pre_cruise.h</h4> <p>该文件名为&quot;stage_pre_cruise.h&quot;，它是Apollo自动驾驶系统中“停车并启动”（Park and Go）规划方案的一部分。这个阶段被定义为&quot;ParkAndGoStagePreCruise&quot;的类，是基于&quot;Stage&quot;的公共类。此类定义了一个名为&quot;Process&quot;的公共方法和一个名为&quot;FinishStage&quot;的私有方法。</p> <p>&quot;Process&quot;方法是一个覆写（override）的方法，它的功能需由具体实现来定义，该方法接收一个轨迹点和一个帧为输入。</p> <p>&quot;FinishStage&quot;方法是一个私有方法，它的功能也须由具体实现来定义。</p> <p>文件底部，&quot;CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN&quot;宏用于向Cyber插件管理器注册&quot;ParkAndGoStagePreCruise&quot;插件。</p> <p>此外，所有代码都被包含在&quot;apollo&quot;的命名空间，更具体地说是在它的&quot;planning&quot;（规划）子命名空间下。</p> <h4>context.h</h4> <p>该源代码文件，名为context.h，位于./scenarios/park_and_go的目录下。这是一个C++头文件，定义了一个结构体ParkAndGoContext，用于承载和处理Apollo自动驾驶系统在进行&quot;停车并前进&quot;(Park and Go)场景下的相关上下文信息。</p> <p>ParkAndGoContext结构体继承自ScenarioContext类，增加了一个成员变量：scenario_config，它的类型是ScenarioParkAndGoConfig，应该是来自在park_and_go.pb.h中定义的一个protobuf数据结构，用于存储这个场景的配置信息。</p> <p>总的来说，这个文件定义了一个上下文，特别适用于&quot;停车并前进&quot;的驾驶场景，在该 Apollo 自动驾驶场景中，这个上下文将举足轻重的作用。</p> <h4>park_and_go_scenario.h</h4> <p>这个文件是 Apollo 自动驾驶系统中的一个部分，它定义了一个名为 <code>ParkAndGoScenario</code> 的类。这个类是自动驾驶系统中处理&quot;停车并启动&quot;场景的核心部分，即车辆停车后再次启动的情况。这个类属于 Scenario(场景) 类的子类。</p> <p>它主要包含以下方法：</p> <ul> <li><code>Init</code>：这是一个初始化方法，用于在场景开始时进行启动和设置。</li> <li><code>GetContext</code>：这个方法返回当前场景的上下文，也就是 <code>ParkAndGoContext</code> 对象，这个对象包含了场景运行所需要的特定信息。</li> <li><code>IsTransferable</code>：这个方法检查当前场景是否可以切换到其他场景。</li> </ul> <p>这个文件还使用 <code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code> 宏将 <code>ParkAndGoScenario</code> 类注册为插件，使得该类可以被动态加载和卸载。</p> <p>前导部分是著作权和许可证声明，表明这个文件的代码使用 Apache 2.0 许可证授权，与公共域软件相似，但需保持原始著作权声明。</p> <h3>pull_over</h3> <h4>context.h_</h4> <p>这是一个C++程序的头文件，文件名为&quot;./scenarios/pull_over/context.h&quot;。这个文件属于Apollo自动驾驶系统的一部分，特别是该系统的规划模块中的“停车”场景。</p> <p>文件包含一份版权声明和关于文件的许可证信息，然后有@include &quot;./scenarios/pull_over/proto/pull_over.pb.h&quot; 和 @include &quot;./planning_interface_base/scenario_base/scenario.h&quot; 两个预处理命令。这两个header文件是Apollo规划模块中其他部分的头文件，它们被引入用于“停车”场景的定义。</p> <p>然后在apollo::planning命名空间下，定义了一个名为PullOverContext的结构体，继承自ScenarioContext。它只有一个成员，为ScenarioPullOverConfig对象，名称为scenario_config，这个对象是从pull_over.pb.h头文件中定义的Protocol Buffers消息类型。</p> <p>总的来说，这个头文件包含了定义PullOverContext对象所必要的信息，偏向于数据的组织和架构设计。</p> <h4>pull_over_scenario.h</h4> <p>这是一个名为&quot;pull_over_scenario.h&quot;的C++头文件，部分包含在Apollo自动驾驶项目的规划模块的&quot;pull_over&quot;场景中。</p> <p>文件中定义了一个名为&quot;PullOverScenario&quot;的类，继承自&quot;Scenario&quot;类。PullOverScenario类中有公有方法和私有数据成员。</p> <p>在公有方法中，主要包括构造函数、场景的初始化函数Init、获取场景上下文的函数GetContext，以及关于场景状态的Enter、IsTransferable和Exit函数。</p> <p>在私有数据成员中，有一个标记初始化状态的布尔变量init_以及一个名称为context_的PullOverContext对象。</p> <p>文件最后还注册了PullOverScenario插件，将其注册到Cyber Plugin Manager中。</p> <h4>stage_approach.h___</h4> <p>这是一个名为&quot;stage_approach.h&quot;的C++头文件，属于Apollo自动驾驶系统的源代码项目之一。文件路径表明，这份代码对应的是自动驾驶过程中&quot;停车&quot;场景的一部分。具体来说，它处理了停车过程的某个阶段 &#8211; &quot;接近&quot;阶段。</p> <p>该文件主要定义了一个名为&quot;PullOverStageApproach&quot;的类，该类继承自&quot;Stage&quot;类，所以它应该含有处理特定阶段的功能和行为。特别是，它有一个&quot;Process&quot;方法，这个方法接收一个轨迹点和一个框架对象作为输入，然后返回一个&quot;StageResult&quot;对象，表明阶段处理的结果。它还有一个&quot;FinishStage&quot;的私有方法。</p> <p>另外，这个文件还包含对CYBER_PLUGIN_MANAGER的使用，用于注册PullOverStageApproach类为一个插件。</p> <h4>stage_retry_approach_parking.h</h4> <p>该文件是一个C++头文件，定义了一个名为<code>PullOverStageRetryApproachParking</code>的类，它是<code>Stage</code>类的子类，并且属于<code>apollo::planning</code>这个命名空间。这个子类覆盖了<code>Process</code>方法，另外还定义了私有方法<code>FinishStage</code>和<code>CheckADCStop</code>。</p> <p>文件路径暗示该类属于<code>apollo</code>自动驾驶平台的规划模块中的“pull_over”（停靠）场景。具体到这个类，它可能是用于停车过程中如何通过重试方法重新接近目标停车位。</p> <p>在文件最后，<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏用于注册这个类作为一个插件，使得它可以在其它地方被使用。</p> <h4>stage_retry_parking.h</h4> <p>这个文件是Apollo自动驾驶框架中的一部分，位于模块计划的情境下拉过程中。 文件定义了一个名为PullOverStageRetryParking的类，该类是Stage类的一个子类。 主要功能是处理自动驾驶车辆在尝试停车过程中遇到的各种现象。</p> <p>PullOverStageRetryParking类中主要包括两个方法：</p> <ol> <li>Process()：这是一个公开方法，接受两个参数，一个是TrajectoryPoint（轨迹点），另一个是Frame。这个方法被设计用来处理车辆在移动过程中的信息。</li> <li>FinishStage()和CheckADCPullOverOpenSpace()：这两个是私有方法，被用于完成阶段或检查车的开放空间。</li> </ol> <p>此外，这个文件还注册了PullOverStageRetryParking类作为一个插件，以便将来扩展。</p> <h4>util.h__</h4> <p>这个源代码文件叫做<code>util.h</code>，位于<code>./scenarios/pull_over</code>目录下， 应该是Apollo开源项目的一部分。Apollo是一个自动驾驶汽车软件平台。</p> <p>这个头文件定义了一些PullOver（靠边停车）场景中用到的类和函数。</p> <p>核心内容包括：</p> <ol> <li>前置声明了一些类，包括<code>Vec2d</code>，<code>VehicleStateProvider</code>，<code>PathPoint</code>，<code>ScenarioPullOverConfig</code>，<code>PlanningContext</code> 和 <code>ReferenceLineInfo</code></li> <li>声明枚举类型<code>PullOverState</code>，包含了一系列拉车状态如：未知，接近，停车完成，停车失败，超过目标等</li> <li>定义了函数 <code>CheckADCPullOver</code> 和 <code>CheckADCPullOverPathPoint</code>.这两个函数主要用来检查自动驾驶汽车（Autonomous Driving Car，ADC）是否可以靠边停车</li> <li>定义了函数 <code>CheckPullOverPositionBySL</code>，这个函数主要用来在SL坐标系（以道路为基准的二维车辆坐标系）下检查靠边停车的位置是否合适。</li> </ol> <p>总的来说，这个文件主要提供了一些函数和类型，令其他人可以在自动驾驶车辆的规划部分去实现靠边停车的场景。</p> <h3>stop_sign_unprotected</h3> <h4>context.h__</h4> <p>该文件命名为context.h，是Apollo自动驾驶系统项目中./scenarios/stop_sign_unprotected目录下的头文件。</p> <p>它定义了一个命名空间为apollo::planning下的结构体StopSignUnprotectedContext，该结构体继承自ScenarioContext。结构体内包含了与非保护性停车标志的自动驾驶场景相关的状态和配置信息。</p> <p>这包括：</p> <ul> <li>场景配置，存储在ScenarioStopSignUnprotectedConfig对象中。</li> <li>当前需要停止的标志对象的重叠段ID，存储在字符串current_stop_sign_overlap_id中。</li> <li>开始停车的时间，存在变量stop_start_time中。</li> <li>开始缓慢运行的时间，存在变量creep_start_time中。</li> <li>要观察的车辆,存放在一个unordered_map中，键为道路ID,值为相应的感知障碍物IDs。</li> <li>与当前上下文关联的车道信息,存储在pair对象的vector中，pair元素包含车道指针和重叠信息指针。</li> </ul> <p>提供这个上下文信息将有助于在非保护性停车标志的场景下做出更合理的驾驶决策。</p> <h4>stage_creep.h</h4> <p>这个文件是Apollo自动驾驶系统的一部分，更具体的是，它属于规划(planning)模块中处理停车标志未保护情况的场景。这个头文件定义了一个<code>StopSignUnprotectedStageCreep</code>类，他是<code>BaseStageCreep</code>类的子类。它在满足某些条件下控制车辆的慢行。</p> <p>主要功能包括：</p> <ol> <li>初始化阶段的配置(<code>Init</code>函数)。</li> <li>处理阶段，即按照给定的情形计算出路径(<code>Process</code>函数)。</li> <li>获取阶段配置(<code>GetCreepStageConfig</code>函数)。</li> <li>获取停车线信息(<code>GetOverlapStopInfo</code>函数)。</li> <li>完成阶段(<code>FinishStage</code>函数)。</li> </ol> <p>此类是一个插件 (<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>)，可由其他部分调用。其中详细的行为模式的实现细节可能在相应的.cpp文件中。</p> <h4>stage_intersection<em>cruise.h</em></h4> <p>这个程序文件是Apollo自动驾驶系统中的一部分，尤其是规划模块中的子场景之一。文件名<code>stage_intersection_cruise.h</code>暗示了这是个在非保护的停车标志下的交叉路口巡航阶段。</p> <p>文件中定义了一个名为<code>StopSignUnprotectedStageIntersectionCruise</code>的类，它继承了<code>BaseStageCruise</code>基类。</p> <p><code>StopSignUnprotectedStageIntersectionCruise</code>类中定义了两个主要的公共方法- Process() 和 FinishStage()，以及一个私有的获取交通标志重叠的方法GetTrafficSignOverlap()。</p> <p>Process() 方法处理规划初始化点和帧；FinishStage() 方法用于结束阶段； GetTrafficSignOverlap()方法在当前的参考线信息和实时规划上下文中获取交通标志的重叠信息。</p> <p>最后这个<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏用于注册<code>StopSignUnprotectedStageIntersectionCruise</code>类为插件的一部分。</p> <h4>stage_pre_stop.h</h4> <p>文件名称为 &quot;stage_pre_stop.h&quot;，它是从 Apollo 项目中的一个头文件，它在过去的Apollo的自动驾驶计划中起作用。</p> <p>在头文件中，定义了一个名为 &quot;StopSignUnprotectedStagePreStop&quot; 的类，该类继承自 &quot;Stage&quot; 类。这个 &quot;StopSignUnprotectedStagePreStop&quot; 类是处理无人车未受保护的停车标志的预停阶段的一种场景。</p> <p>在 &quot;StopSignUnprotectedStagePreStop&quot; 类中定义了一些主要的成员函数，它们如下：</p> <ol> <li> <p>&quot;Process&quot; 函数：它是模拟当前阶段过程的函数，输入参数是航迹点和框架。</p> </li> <li> <p>&quot;AddWatchVehicle&quot; 函数：一个私有函数，用于添加观察的障碍物和相关车辆。</p> </li> <li> <p>&quot;CheckADCStop&quot; 函数：一个私有函数，用于检查无人车是否已经停止。</p> </li> <li> <p>&quot;FinishStage&quot; 函数：一个私有函数，用于结束当前阶段。</p> </li> </ol> <p>以上就是对该程序文件的基本概述。</p> <h4>stage_stop.h</h4> <p>该文件是Apollo自动驾驶系统中的一部分，特别是在其规划模块中。Apollo是一个适用于自动驾驶车辆的开源软件平台。</p> <p>文件名./scenarios/stop_sign_unprotected/stage_stop.h提示这个文件与处理未受保护的停车标志的场景关联。</p> <p>文件中定义了一个名为StopSignUnprotectedStageStop的类，该类是Stage类的子类。StopSignUnprotectedStageStop类实现了StopSignUnprotected场景下的停止阶段，主要处理如何根据初始的规划点和帧进行操作。</p> <p>StopSignUnprotectedStageStop类中有两个非公有方法，分别是RemoveWatchVehicle和FinishStage。 RemoveWatchVehicle 方法删除与给定路径决策相关的监视车辆，而FinishStage方法用于完成当前阶段。</p> <p>此外，文件中的代码指示此类已被注册为cyber框架的插件，允许其他部分的代码利用框架的功能轻松访问它。</p> <h4>stop_sign_unprotected_scenario.h</h4> <p>这个文件为 <code>stop_sign_unprotected_scenario.h</code>，它是 Apollo 驾驶系统中的一个模块，专门是为了处理无保护停车标志的场景。这个头文件定义了一个名为 <code>StopSignUnprotectedScenario</code> 的类，该类从 <code>Scenario</code> 类继承。</p> <p>下面是这个类的主要成员函数：</p> <ol> <li> <p><code>Init</code>：用于初始化类的函数，接收一个共享指针参数，指向依赖注入器，以及一个字符串参数作为名字。</p> </li> <li> <p><code>GetContext</code>：获取当前的上下文环境，返回类型是 <code>StopSignUnprotectedContext</code> 的指针。</p> </li> <li> <p><code>IsTransferable</code>：检查该场景是否可以过渡，接收两个参数分别为指向其他场景的常量指针和一个 <code>Frame</code> 类型的引用。</p> </li> <li> <p><code>Exit</code>：退出当前场景，接收一个 <code>Frame</code> 类型的指针。</p> </li> <li> <p><code>Enter</code>：进入当前场景，接收一个 <code>Frame</code> 类型的指针。</p> </li> <li> <p><code>GetAssociatedLanes</code>：获取与停车标志信息相关联的道路线。</p> </li> </ol> <p>此外，这个头文件还声明了一个 <code>StopSignUnprotectedContext</code> 类型的私有成员变量 <code>context_</code>。最后，CYBER 插件管理器注册了这个 <code>StopSignUnprotectedScenario</code> 插件。</p> <h3>traffic_light_protected</h3> <h4>stage_intersection_cruise.h__</h4> <p>这个文件是Apollo自动驾驶系统中的一个部分，特别是与交通信号灯驾驶场景有关。这段代码定义了一个类，名为TrafficLightProtectedStageIntersectionCruise，该类继承自BaseStageTrafficLightCruise基类。其中定义了一个公有成员函数Process，接收两个参数，并覆盖了基类中的同名函数。代码中还定义了一个私有成员函数FinishStage。</p> <p>代码最后一部分使用了Apollo的插件管理器进行插件注册，将TrafficLightProtectedStageIntersectionCruise类作为一个Stage插件进行注册。这通常是为了提高代码的模块化和复用性，方便在别的地方调用此部分功能。</p> <h4>stage_approach.h____</h4> <p>这个文件是Apollo自动驾驶系统中的一部分，更具体地说，是其规划模块的一部分。文件定义了一个名为TrafficLightProtectedStageApproach的类，它继承自基础类Stage。这个类主要处理交通灯保护阶段的驾驶情景。</p> <p>在TrafficLightProtectedStageApproach类中，定义了两个方法：Process和FinishStage。Process方法接受两个参数，一个是planning_init_point（初始路径点），另一个是frame（当前驾驶框架），并返回StageResult类型的结果。FinishStage私有方法也返回StageResult类型的结果。</p> <p>还可以看到，TrafficLightProtectedStageApproach类被注册为了一个插件。</p> <h4>traffic_light_protected_scenario.h</h4> <p>该文件是一个头文件，其名为&quot;traffic_light_protected_scenario.h&quot;，是一个组件里包含的模块，该模块是由一个名为Apollo的开源汽车软件平台所提供。</p> <p>该模块定义了一个名为TrafficLightProtectedScenario的类，该类继承自Scenario类。这个类是在处理交通灯保护场景时使用的。它包含一些方法，如Init、GetContext、IsTransferable、Exit和Enter。</p> <p>在类中，这个模块定义了一个叫做context_的TrafficLightProtectedContext类型的私有成员，以及一个名为init_的bool类型的私有成员。</p> <p>文件中还包括了几个库文件，包括内存、字符串、向量、阿波罗计划库和阿波罗网络库。</p> <h4>context.h___</h4> <p>该文件是Apollo自动驾驶系统中的一部分，更具体地说，是其规划模块中的一个子模块。这个文件定义了一个名为TrafficLightProtectedContext的结构，该结构是场景环境的子类，用于处理受交通灯保护的场景。此环境包含一个ScenarioTrafficLightProtectedConfig类型的对象（用于存储场景的配置信息）和一个std::vector（用于存储当前交通灯的重叠ID）。</p> <h3>traffic_light_unprotected_left_turn</h3> <h4>context.h____</h4> <p>该文件（context.h）是一个头文件，位于Apollo项目的<code>./scenarios/traffic_light_unprotected_left_turn</code>目录下。项目所属于无人驾驶技术领域，显然是为了无人车的交通规划部分。</p> <p>从代码的内容上来看，该头文件定义了一个结构体TrafficLightUnprotectedLeftTurnContext，继承自ScenarioContext基类。在这个结构体中，包含了以下成员：</p> <ul> <li>一个ScenarioTrafficLightUnprotectedLeftTurnConfig类型的对象scenario_config，可能是用于保存无保护左转交通灯的配置。</li> <li>一个std::vector<std::string>类型的对象current_traffic_light_overlap_ids，可能是用来储存当前交通灯对应的ID</li> <li>一个double类型的creep_start_time，很可能代表某个行为或事件的开始时间。</li> </ul> <p>此文件的版权归2019年的Apollo作者所有，并已根据2.0版Apache许可证授权。</p> <h4>stage<em>approach.h____</em></h4> <p>这是一个名为 &quot;TrafficLightUnprotectedLeftTurnStageApproach&quot; 的 C++ 头文件，属于 Apollo（一个自动驾驶软件平台）项目的代码库的一部分。这个文件定义了一个名为 TrafficLightUnprotectedLeftTurnStageApproach 的类，该类继承自 Stage 类，分别提供了 Process 和 FinishStage 方法，主要用于处理未受保护的左转交通灯的情况。同样，这个类被注册为一个插件供 Apollo 使用。</p> <p>该文件位于模块 &quot;planning&quot; 的子模块 &quot;scenarios&quot; 的子模块 &quot;traffic_light_unprotected_left_turn&quot; 中，这显然表明它在 Apollo 项目中的自动驾驶规划环节尤其是处理特殊场景中的角色。</p> <p>具体来说，这个类可能决定在未受保护的左转交通信号灯的场景下，自动驾驶汽车的行为。方法 &quot;Process&quot; 可能负责从初始点开始生成轨迹，&quot;FinishStage&quot; 可能在执行完毕或遇到特定条件时被调用以结束场景。</p> <h4>stage<em>creep.h</em></h4> <p>这是一个属于 Apollo 自动驾驶系统的源代码文件，其中包含一个名为 TrafficLightUnprotectedLeftTurnStageCreep 的类。这个类继承自 BaseStageTrafficLightCreep 类，并需要实现一些特定的方法。</p> <p>这个类主要处理自动驾驶车辆在面对红绿灯进行无保护左转时的行为。它有以下主要方法：</p> <ul> <li>Init 方法：用于初始化对象，并对其进行配置。</li> <li>Process方法：在车辆进行未受保护的左转时处理一帧数据。</li> <li>GetCreepStageConfig 方法：获取 Creep 阶段的配置信息。</li> <li>FinishStage 方法：完成当前阶段。</li> </ul> <p>这个文件是按照 Apache 2.0 许可证开源的。还利用了CYBER插件管理器，使得该插件可以被Apollo系统进行注册和使用。</p> <h4>stage_intersection_cruise.h___</h4> <p>这是一个C++源代码文件，属于Apollo自动驾驶系统的一部分，具体来说是规划模块中的一个子模块。该文件定义了一个名为<code>TrafficLightUnprotectedLeftTurnStageIntersectionCruise</code>的类，这个类是基类<code>BaseStageTrafficLightCruise</code>的派生类。</p> <p><code>TrafficLightUnprotectedLeftTurnStageIntersectionCruise</code>类主要用于处理无保护左转交通信号灯情况下的交叉口巡航场景。 它包含两个方法：<code>Process</code>和<code>FinishStage</code>。<code>Process</code>方法接收规划初始点和帧作为输入，并可能在执行过程中改变帧的状态。</p> <p>此外，此文件还利用了<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏定义来注册<code>TrafficLightUnprotectedLeftTurnStageIntersectionCruise</code>插件，使得Apollo系统可以动态地加载和使用这个插件。</p> <h4>traffic_light_unprotected_left_turn_scenario.h</h4> <p>这个源代码文件是Apollo自动驾驶框架中的一个部分，主要功能是管理交通灯未保护左转场景。它是一个C++头文件，定义了一个名为<code>TrafficLightUnprotectedLeftTurnScenario</code>的类，继承自<code>Scenario</code>基类。</p> <p>此类具有以下重要的公开方法：</p> <ul> <li><code>Init</code>函数进行类的初始化，接受一个<code>DependencyInjector</code>智能指针和一个名称参数。</li> <li><code>GetContext</code>函数返回当前场景的上下文，即与当前场景关联的各种信息。</li> <li><code>IsTransferable</code>函数判断是否可以从当前场景转移到其他场景，接受一个指向<code>Scenario</code>的常量指针和一个<code>Frame</code> 参数。</li> <li><code>Enter</code>函数和<code>Exit</code>函数分别在进入和离开当前场景时被调用。</li> </ul> <p>类中还定义了一个私有的布尔变量<code>init_</code>用来标记类是否已初始化，并有一个<code>TrafficLightUnprotectedLeftTurnContext</code>对象<code>context_</code>用以保存当前场景的上下文。</p> <p>最后一行代码是将<code>TrafficLightUnprotectedLeftTurnScenario</code>插件注册到Apollo Plugin Manager中。</p> <h3>traffic_light_unprotected_right_turn</h3> <h4>context.h_____</h4> <p>这个程序文件是一个头文件，它定义了一个名为TrafficLightUnprotectedRightTurnContext的结构体，此结构体在Apollo的自动驾驶车辆规划模块中是一个特定场景下的上下文信息。</p> <p>它包含的数据字段有：</p> <ol> <li> <p>scenario_config：这是一个场景配置，用于配置不受保护的红绿灯右转行为。其数据类型为ScenarioTrafficLightUnprotectedRightTurnConfig，来自于先前包含的protobuf文件。</p> </li> <li> <p>current_traffic_light_overlap_ids：一个字符串向量，存储当前与行驶车辆有交叠的交通信号灯ID。</p> </li> <li> <p>stop_start_time：一个浮点数，代表的是停车开始时间。</p> </li> <li> <p>creep_start_time：一个浮点数，代表的是爬行开始时间。</p> </li> </ol> <p>此文件被用于管理未受保护的交通信号灯右转场景下的相关数据。</p> <h4>stage_creep.h__</h4> <p>这个文件是Apollo自动驾驶系统项目中的一部分，专门处理未保护右转交通灯情景（traffic light unprotected right turn scenario）中的&quot;Creep&quot;阶段。</p> <p><code>TrafficLightUnprotectedRightTurnStageCreep</code>类继承自<code>BaseStageTrafficLightCreep</code>，并重写了两个方法：<code>Init</code>和<code>Process</code>。</p> <p><code>Init</code>方法用于初始化类，使用四个参数，包括配置、依赖注入器、配置目录和上下文，返回一个bool值表示是否初始化成功。</p> <p><code>Process</code>方法用于处理来自规划模块的传入轨迹点，它接受一个轨迹点和一帧作为参数，并返回阶段结果。</p> <p>在私有方法中，有<code>GetCreepStageConfig</code>方法，它从ScenarioContext获取&quot;Creep&quot;阶段的配置，并可以被子类重写。另一个方法是<code>FinishStage</code>，返回阶段结果，它可能被用于结束这个阶段。</p> <p>最后一行是将<code>TrafficLightUnprotectedRightTurnStageCreep</code>类在cyber框架中注册为插件。</p> <h4>stage_intersection_cruise.h____</h4> <p>这个文件是Apollo自动驾驶项目中的一部分，具体来说，它是处理无保护右转交通灯场景中的某个阶段的代码。文件位于./scenarios/traffic_light_unprotected_right_turn/路径下，说明它是处理交通灯和无保护右转场景的相关程序。</p> <p>在名为&quot;TrafficLightUnprotectedRightTurnStageIntersectionCruise&quot;的类中，继承了&quot;BaseStageTrafficLightCruise&quot;基类，并重写了&quot;Process&quot;方法。&#8217;TrafficLightUnprotectedRightTurnStageIntersectionCruise&#8217;类是处理无保护右转交通灯的特定阶段的逻辑，尤其是在交通路口巡航阶段。</p> <p>&#8216;Process&#8217;方法用于处理这个阶段，接受TrajectoryPoint和Frame作为参数，返回StageResult。还有一个私有成员函数&#8217;FinishStage&#8217;，可能在某个阶段结束时被调用。</p> <p>最后，定义了一个宏，将TrafficLightUnprotectedRightTurnStageIntersectionCruise类注册到了plugin manager中，使得它可以在运行时被动态加载和卸载。</p> <h4>stage<em>stop.h</em></h4> <p>这个文件是&quot;TrafficLightUnprotectedRightTurnStageStop&quot;类的头文件，这个类继承自&quot;Stage&quot;类，定义在apollo计划的命名空间里。项目路径./scenarios/traffic_light_unprotected_right_turn/stage_stop.h显示该类可能与自动驾驶过程中非保护右转的场景有关。</p> <p>&quot;TrafficLightUnprotectedRightTurnStageStop&quot;类有一个公有的&quot;Process&quot;函数，接收一个常规轨迹点和一个&quot;Frame&quot;类的指针，返回一个&quot;StageResult&quot;。&quot;Process&quot;函数可能用来处理这个场景。</p> <p>类中还有两个私有方法。&quot;CheckTrafficLightNoRightTurnOnRed&quot;是检查获得的交通灯ID是否表示禁止红灯右转。&quot;FinishStage&quot;方法可能用来结束这个阶段，它取一个名为&quot;protected_mode&quot;的bool参数，返回一个&quot;StageResult&quot;。</p> <p>此外，&quot;TrafficLightUnprotectedRightTurnStageStop&quot;已在&quot;CYBER_PLUGIN_MANAGER&quot;中注册为插件。这种插件化的设计使得程序拥有较好的扩展性和易于添加新功能。</p> <h4>traffic_light_unprotected_right_turn_scenario.h</h4> <p>这个文件是Apollo自动驾驶系统中的一部分。它定义了一个名为TrafficLightUnprotectedRightTurnScenario的类，这个类是应对交通灯无保护右转场景的特定方案。这个类继承自基类Scenario，包含以下主要方法：</p> <ul> <li>Init：初始化方法，是否初始化成功由返回的布尔值表示。</li> <li>GetContext：取得当前场景的上下文，返回 TrafficLightUnprotectedRightTurnContext 类型指针。</li> <li>IsTransferable：检查当前场景是否可以转换为其他场景。</li> <li>Enter：在进入该场景时会被调用。</li> <li>Exit：在退出该场景时会被调用。</li> </ul> <p>此外，还定义了一个context_成员，用于存储当前场景的上下文信息。</p> <p>在文件的末尾，利用CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏，将TrafficLightUnprotectedRightTurnScenario类注册到Apollo的插件管理器中，使得其他部分的代码可以动态地使用这个类。</p> <h3>valet_parking</h3> <h4>stage_approaching_parking_spot.h</h4> <p>这个文件是Apollo自动驾驶项目的一部分，关于自动代客泊车的场景。文件名称为 &quot;stage_approaching_parking_spot.h&quot; ，它是一个头文件，主要定义了一个名为 &quot;StageApproachingParkingSpot&quot; 的类。</p> <p>这个类是 &quot;Stage&quot; 类的公开派生。&quot;Stage&quot; 类可能是用于描述各种驾驶阶段的基类。&quot;StageApproachingParkingSpot&quot; 类描述了汽车接近停车位的场景。</p> <p>它的主要成员函数包含 &quot;Init&quot; 和 &quot;Process&quot;。&quot;Init&quot; 函数可能用于初始化这个阶段，包括配置信息，依赖注入，配置目录以及上下文。&quot;Process&quot; 函数处理规划初始点，可能涵盖路径规划、持续时间和其他相关的驾驶细节。</p> <p>还有一个私有函数 &quot;CheckADCStop&quot;，猜测它可能是用于检查无人驾驶车辆是否停止。</p> <p>另外该类中还包含一个 &quot;ScenarioValetParkingConfig&quot; 类型的成员 &#8216;scenario<em>config</em>&#8216;，可能是该阶段所需的场景配置数据。</p> <p>文件尾部的宏 &quot;CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN&quot; 可能是将 &quot;StageApproachingParkingSpot&quot; 类注册为插件，以在规划阶段加载和使用。</p> <h4>stage_parking.h</h4> <p>该文件是Apollo自动驾驶项目中的一部分，特别是它关心的是Valet Parking（代客泊车）的情景。文件中定义了一个名为&quot;StageParking&quot;的类，这个类是&quot;Stage&quot;的子类，它处理特定于泊车阶段的行为。主要有两个公有方法：“Process”对泊车的初始化进行处理，&quot;FinishStage&quot;负责完成泊车阶段的处理。</p> <p>&quot;StageParking&quot;类注册为一个插件，通过Apollo的Cyber框架插件管理器进行管理。这个源码文件便于Apollo的自动驾驶系统在需要时可以方便地添加，关闭或切换这个特定的泊车模块。</p> <p>此外，这个文件也遵循Apache 2.0许可，这说明了它可以在符合许可证规定的情况下被免费使用，修改和共享。</p> <h4>valet_parking_scenario.h</h4> <p>这是一个C++头文件，定义了一个关于泊车场景的类&quot;ValetParkingScenario&quot;，这个类依赖于Apollo软件平台的planning模块。这个头文件的主要目标是处理自动驾驶汽车在代客泊车场景下的各种情况。</p> <p>ValetParkingScenario类继承自Scenario基类，并提供了一些特定的成员函数以支持场景操作，这些成员函数包括Init（用于初始化场景），GetContext（用于获取场景上下文），IsTransferable（用于检查在给定的情况下，是否可以从其他场景转移到代客泊车场景）。此外，还定义了一些静态函数，如SearchTargetParkingSpotOnPath和CheckDistanceToParkingSpot，以完成特定任务。</p> <p>另外，在这个头文件中还定义了一个结构体&quot;ValetParkingContext&quot;，这个结构体继承自ScenarioContext，主要用于在泊车场景中传递和处理有关泊车的详细信息，包括目标停车位的ID，预停车的标志等。</p> <p>最后，这个头文件还注册了ValetParkingScenario插件到插件管理器CYBER_PLUGIN_MANAGER。</p> <h3>yield_sign</h3> <h4>stage_approach.h<strong>__</strong></h4> <p>这是一个名为&quot;stage_approach.h&quot;的头文件，属于Apollo项目的一部分。该项目是一个开源的自动驾驶项目。从程序文件目录结构来看，这个头文件位于模块规划的子目录&quot;scenarios/yield_sign&quot;下面。在该文件中，定义了一个名为YieldSignStageApproach的类，该类是Stage类的子类。</p> <p>YieldSignStageApproach类中，定义了一个公共方法Process，并且覆盖了基类的这个同名方法。此外，还定义了一个私有方法FinishStage。这个类还包含一个私有数据成员scenario<em>config</em>，类型为ScenarioYieldSignConfig。</p> <p>此外，该文件还在apollo::planning命名空间下声明了一个YieldSignContext结构体，并使用插件管理器注册了YieldSignStageApproach类，以便在其他地方方便地使用这个类。</p> <p>整个文件的功能看似是处理和管理自动驾驶车辆在路口需要让行的相关情景和策略。</p> <h4>stage_creep.h___</h4> <p>这个代码文件是Apollo自动驾驶系统的一部分，具体是其规划模块中下属于&quot;yield sign&quot;（让行标志）场景的&quot;creep&quot;阶段（Creeping，或者称作&quot;慢行&quot;）。在这个阶段，车辆将视需要在让行标志处慢行。</p> <p>具体言之，文件定义了一个名为<code>YieldSignStageCreep</code>的类，这个类是<code>BaseStageCreep</code>的派生类，它在车辆需要慢行时具有特殊的行为。以下是这个文件中一些主要的函数：</p> <ul> <li><code>Init</code>函数被用来初始化实例，这个函数接收配置、依赖注入器、配置目录和上下文作为参数。</li> <li><code>Process</code>函数则是用来执行该阶段的处理工作。</li> <li><code>GetCreepStageConfig</code>函数用于从ScenarioContext中获取慢行阶段的配置，这个功能可以被子类重写。</li> <li><code>GetOverlapStopInfo</code>函数则用于获取重叠区域停车信息。</li> <li><code>FinishStage</code>函数用于在慢行阶段结束后的处理.&quot;&quot;&quot;</li> </ul> <p>这个类也在文件末尾被注册到了插件管理器中。</p> <h4>yield_sign_scenario.h</h4> <p>这个文件是Apollo自动驾驶框架中的一部分，位于./scenarios/yield_sign/路径下，名为yield_sign_scenario.h。这个文件定义了<code>YieldSignScenario</code>类，这个类主要处理与让行标志相关的驾驶场景。</p> <p>根据源代码，该类主要包括了以下几个部分：</p> <ol> <li> <p><code>YieldSignContext</code>结构体：它用以储存让行标志的场景配置和当前让行标志的ID。</p> </li> <li> <p><code>YieldSignScenario</code>类：主要包括了对让行标志场景的初始化（<code>Init</code>），情境获取（<code>GetContext</code>），场景切换（<code>IsTransferable</code>），进入（<code>Enter</code>）和退出（<code>Exit</code>）等操作。</p> </li> <li> <p>同时，APOLLO还使用了插件管理器<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>，用于把该类注册为一个插件，可以方便地在别的地方调用。</p> </li> </ol> <p>总的来说，这个文件是定义让行标志驾驶场景的相关操作。</p> <h2>tasks</h2> <h3>fallback_path</h3> <h3>fallback_path.h</h3> <p>这个文件是Apollo自动驾驶项目的一部分，特别是计划系统的一部分。它定义了名为 FallbackPath 的类。这个类继承自 PathGeneration 类，并对其进行扩展。</p> <p>FallbackPath类是用来在应急情况下生成候选路径的。它定义了如何初始化类（Init），如何处理帧和参考线信息（Process），如何决定路径界限（DecidePathBounds），如何优化每个路径界限的路径（OptimizePath），以及如何选择最佳路径（AssessPath）。</p> <p>此外，类定义还包括一个私有变量config_，它意味着这个类可能有一些可配置的参数。</p> <p>最后，它在乌镇的插件管理器中注册自己，这意味着它可能作为插件使用，使得整个系统更加模块化。</p> <h3>lane_borrow_path</h3> <h4>lane_borrow_path.h</h4> <p>文件 <code>./tasks/lane_borrow_path/lane_borrow_path.h</code> 是一个 C++ 头文件，其定义了一个名为 <code>LaneBorrowPath</code> 的类，该类似乎是自动驾驶策略的一部分，用于为车辆计划辅助道路路径。</p> <p><code>LaneBorrowPath</code> 类从 <code>PathGeneration</code> 类继承，实现了一系列的路径生成方法，包括 <code>Init()</code>, <code>Process()</code>, <code>DecidePathBounds()</code>, <code>OptimizePath()</code>, <code>AssessPath()</code>, <code>GetBoundaryFromNeighborLane()</code> 等等，这些方法似乎都用于在路网中规划和优化路径。</p> <p>定义还包括一些私有成员函数和数据成员，供类方法内部使用，以提高路径规划的效率和准确性。</p> <p>此外，文件还定义了一些辅助函数，如 <code>ContainsOutOnReverseLane()</code>, <code>GetBackToInLaneIndex()</code>, 和 <code>ComparePathData()</code>。</p> <p>文件的代码是在 apollo 的命名空间下实现的，说明它可能是 Apollo 自动驾驶系统的一部分。该系统采用模块化设计，每个模块负责完成特定功能。</p> <h3>lane_change_path</h3> <h4>lane_change_path.h</h4> <p>这个代码文件是一个属于<code>./tasks/lane_change_path</code>路径的头文件，名称是<code>lane_change_path.h</code>。它是自动驾驶开源项目Apollo中的一部分。</p> <p>让我们分析一下这个文件的主要内容：</p> <ol> <li> <p><strong>版权声明</strong>：文件开头的注释包含版权声明和Apache许可证的授权。</p> </li> <li> <p><strong>引入的依赖</strong>：文件包含一些标准库和自定义库（比如protobuf消息）的引用，这在准备实现功能时很有用。</p> </li> <li> <p><strong>定义的类</strong>：<code>LaneChangePath</code>类从<code>PathGeneration</code>类中继承。这个类通过Path Planning模块来规划车道变换路径。这个类包含了一系列公共和私有方法，用于初始化、处理数据、计算路径边界、优化路径、评估路径等。</p> </li> <li> <p><strong>功能及注释</strong>：每一个功能和方法都配有详细的注释说明，包括输入参数和输出结果等。</p> </li> </ol> <p>此外，这个头文件定义了一个枚举类型 <code>SidePassDirection</code>，包括左借道（LEFT_BORROW）和右借道（RIGHT_BORROW）。</p> <p>类成员变量中包含一系列变量和配置用于存储路径信息、车道更改状态和开始位置等。</p> <p>文件的末尾还包含了一个 <code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code> 宏，用于在Cyber框架的插件管理器中注册 <code>LaneChangePath</code> 类，设为紧急任务。</p> <h3>lane_follow_path</h3> <h4>lane_follow_path.h</h4> <p>这是一个C++的头文件，定义了一个名为<code>LaneFollowPath</code>的类，它是<code>PathGeneration</code>类的子类，并且拥有一套路径生成、优化和评估模型。这个类是用于自动驾驶项目 &#8211; Apollo的源代码中。</p> <p>在<code>LaneFollowPath</code>类中，定义了以下方法：</p> <ol> <li><code>Init</code>：初始化函数，接收配置路径、名称和依赖注入器参数。</li> <li><code>Process</code>：处理一帧数据和相应的参考线信息。</li> <li><code>DecidePathBounds</code>：计算所有路径边界。</li> <li><code>OptimizePath</code>：针对每个路径边界优化路径。</li> <li><code>AssessPath</code>：评估每条路径的可行性并选出最优路径。</li> </ol> <p>此外，文件还包括<code>LaneFollowPathConfig</code>类的一个实例<code>config_</code>，用于管理类的配置。</p> <p>最后一行代码注册这个类为一个插件，使得该类可以作为一个独立的模块被其他代码调用。</p> <p>整体来说, 这个类是负责在车道跟踪任务中，计算、优化和评估车辆路径的功能模块。</p> <h3>open_space_fallback_decider</h3> <h4>open_space_fallback_decider.h</h4> <p>这个文件是一个C++的头文件，定义了&quot;OpenSpaceFallbackDecider&quot;类，该类是Apollo自动驾驶系统中的一部分，属于其规划模块的任务部分。Apollo是一个开源的自动驾驶系统。</p> <p>&quot;OpenSpaceFallbackDecider&quot;类是从&quot;Decider&quot;类继承的，&quot;Decider&quot;可以看作是一个决策器的基类。&quot;OpenSpaceFallbackDecider&quot;类主要用于在开放空间环境下的规划决策。</p> <p>在这个类中，有一些主要的成员函数，如&quot;Init&quot;、&quot;Process&quot;等。比如，&quot;Process&quot;的功能是处理规划过程中的一帧数据。类中还有检查给定轨迹是否存在冲突、构建预测环境等等的方法。</p> <p>此外，该代码文件引用了多个自定义的protobuf消息，比如车辆配置、开放空间后备决策器配置等，这些用于消息通信和参数配置。</p> <p>&quot;CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN&quot;宏是注册这个类作为一个插件，由Cyber模块的插件管理器来进行管理。</p> <p>总的来说，这个类是实现后备轨迹在开放空间是否无冲突的决策逻辑的地方。</p> <h3>open_space_pre_stop_decider</h3> <h4>open_space_pre_stop_decider.h</h4> <p>这个文件是一个头文件（.h），名为&quot;OpenSpacePreStopDecider&quot;，位于模块的&quot;planning/tasks/open_space_pre_stop_decider&quot;路径下。它是Apollo自动驾驶系统中的一部分。</p> <p>OpenSpacePreStopDecider类继承自Decider类，作用是用来决定自动驾驶车辆在开放空间环境中的预停靠策略。这个类包含了初始化(Init)方法，处理(Process)方法，检查停车位预停靠(CheckParkingSpotPreStop)和设置停靠位围栏(SetParkingSpotStopFence)的方法等。这些方法共同决定了车辆何时以及如何在开放空间里停车。</p> <p>此类中还定义了一个私有变量OpenSpacePreStopDeciderConfig config_，用于存储关于预停靠策略的配置信息。</p> <p>最后，CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏将OpenSpacePreStopDecider类注册为一个插件，使得其他的模块可以使用这个类实现的功能。</p> <p>所引用的头文件包括Apollo自研的Cyber RT的宏定义、插件管理器以及其他在“planning_base”和“task_base”路径下的一些共享组件，如Frame，ReferenceLineInfo，Decider等。还引用了一个名为&quot;open_space_pre_stop_decider.pb.h&quot;的protobuf头文件，用于在Apollo的模块之间进行信息传输。</p> <h3>open_space_roi_decider</h3> <h4>open_space_roi_decider.h</h4> <p>这是Apollo自动驾驶系统中“Open Space Roi Decider（开放空间感兴趣区域决定器）”的头文件。此类的主要作用是处理帧数据并生成开放空间的感兴趣区域。</p> <p>这个类是Apollo中的一个&quot;Decider&quot;，需要初始化并处理一帧数据。在处理过程中，它按照车辆的位置生成路径并确定目标停车位置。它还设定了车辆的起点，根据这个起点来获取道路边界，并从地图对象获取道路边界。它会获取停车边界，搜索目标停车位，并制定边界约束。此类还会处理障碍物，并将其转换为线性不等式（超平面）。</p> <p>此Header文件包括大量的成员函数，大部分是私有的，用来执行具体的操作，如组成边界约束、载入障碍物信息等。在公共成员函数中，有Init和Process两个主要函数，前者是用于初始化此类，后者则是进行主要的处理操作。</p> <p>此类的代码十分复杂，涉及到的代码计算量较大，依赖多个其他模块和类。它的功能是在自动驾驶系统特定的场景（如停车）中，生成行车路径的关键区域，并处理这些区域中的障碍物。</p> <h3>open_space_trajectory_partition</h3> <h4>open_space_trajectory_partition.h</h4> <p>这个文件是Apollo自动驾驶系统中的一部分，具体来说，它是一个名为&quot;OpenSpaceTrajectoryPartition&quot;的类的头文件, 这个类属于规划模块中的开放空间轨迹分区任务。类的实例对象具有进行轨迹优化等操作的能力。</p> <p>此类继承了&quot;TrajectoryOptimizer&quot;基类，并且重写了其中的一些方法，如初始化、状态处理等。同时，它也有一些私有方法，如插值轨迹、更新车辆信息、检查轨迹、分区轨迹等，这些都是对轨迹的各种处理行为。</p> <p>此文件还包含了一些私有的数据成员来保存车辆参数和状态信息，如车辆的长度、宽度、车轮基底，以及车辆的位置、速度、方向等信息。有了这些数据，在后续的计算和处理中可以直接使用，大大提高了代码的复用性和执行效率。</p> <p>这个文件还定义了大量的成员变量，用于保存和控制系统状态。</p> <p>总的来说，这个头文件是Apollo开放空间轨迹分区任务的关键组成部分，负责定义相关的数据结构和方法，使得可以对车辆在开放空间中的行驶轨迹进行处理和优化。</p> <h3>open_space_trajectory_provider</h3> <h4>open_space_trajectory_optimizer.h</h4> <p>这个源代码文件定义了一个名为 &quot;OpenSpaceTrajectoryOptimizer&quot; 的类，该类是容器Apollo自动驾驶平台中规划模块的一部分。在处于开放空间环境（例如，一个停车场或发动机舱）的自动驾驶车辆的路径规划中，该类负责优化轨迹。</p> <p>该类有下面的几个主要成员函数：</p> <ol> <li> <p>&quot;Plan&quot; ：根据传入的一些参数（例如当前车辆轨迹，目标位置，旋转角度等）来制定规划路线。</p> </li> <li> <p>&quot;GetStitchingTrajectory&quot; 和 &quot;GetOptimizedTrajectory&quot; ：这两个函数返回优化后的轨迹和拼接轨迹。</p> </li> <li> <p>&quot;RecordDebugInfo&quot; 和 &quot;UpdateDebugInfo&quot; ：这两个函数用于记录和更新关于自动驾驶车辆在空白空间中的轨迹优化の调试信息。</p> </li> </ol> <p>该类还包含一些私有成员函数，这些函数主要对轨迹进行了一些基本的数学操作，例如规范化路径点，反规范化路径点，路径点的加载，等等。此外，此类还使用了一些特殊的优化算法，例如Hybrid A-star，Distance Approach和Dual Variable Warm Start等进行轨迹优化。</p> <p>该文件还包含了一些私有成员变量，包括优化轨迹的配置，用于生成初始解的热启动类实例，以及路径规划的结果等。</p> <h3>open_space_trajectory<em>provider</em></h3> <h4>open_space_trajectory_provider.h</h4> <p>这个C++文件是Apollo自动驾驶框架的一部分。Apollo是一个开源的自动驾驶框架，它包含了自动驾驶汽车所需的几乎所有模块，例如定位、感知、规划、控制等。</p> <p>这个文件的名字是&quot;open_space_trajectory_provider.h&quot;，从文件名和代码内容可以看出，这个文件主要的功能是在一个开放的空间内提供车辆的轨迹。</p> <p>其中 <code>OpenSpaceTrajectoryProvider</code> 类继承自 <code>TrajectoryOptimizer</code>，代表它是一个轨迹优化器。它有许多私有的数据成员，例如 <code>straight_trajectory_length_</code>、 <code>thread_init_flag_</code>、<code>open_space_trajectory_optimizer_</code> 等。其中部分变量如 <code>trajectory_updated_</code>、<code>data_ready_</code>、<code>trajectory_error_</code>、<code>trajectory_skipped_</code> 是原子变量类型(std::atomic)，用于确保多线程操作的安全。</p> <p>此外就是一些公有的和私有的成员函数，例如 <code>Init</code>、<code>Stop</code>、<code>Restart</code>、<code>GenerateTrajectoryThread</code>等。这些函数分别用于初始化，停止，重启轨迹优化器，以及生成轨迹线等功能。</p> <p>整个文件主要是Apollo自动驾驶系统的规划模块下，开放空间轨迹提供者的实现，用于在开放空间的场景下为汽车提供行驶轨迹。</p> <h3>path_decider</h3> <h4>path_decider.h</h4> <p>这个文件是Apollo开源自动驾驶项目的一部分，位于./tasks/path_decider路径下，文件名为path_decider.h。从代码中可以看出，这是一个C++的头文件，定义了一个名为PathDecider的类。这个类继承自Task基类，并复写了Init和Execute方法。它主要包含以下5个private方法：Process、MakeObjectDecision、MakeStaticObstacleDecision、IgnoreBackwardObstacle和GenerateObjectStopDecision。</p> <p>一般来说，PathDecider类可能是用于决定车辆行驶的优化路径和对可能阻碍车辆路径的障碍物进行决策。在这里面，它使用了许多任务处理以及路径决策相关的算法，具体的实现细节可能在对应的.cpp文件中。文件的最后一行是将PathDecider类注册到CYBER的插件管理器中，这样其他模块可以更方便地使用这个类。</p> <p>值得注意的是，这个文件在开始部分声明了版权信息，表明其在Apache 2.0许可下分发，并对该许可下的各种权益进行了详细的说明。</p> <h3>path_reference_decider</h3> <h4>path_reference_decider.h</h4> <p>这个头文件定义了一个名为PathReferenceDecider的类，它是汽车导航的一部分并处于Apollo自动驾驶系统中。PathReferenceDecider是一个任务类(Task)，它提供了路径决策的基础设施。</p> <p>类包含公共方法（例如：<code>Init</code>用于初始化任务，<code>Execute</code>用于执行任务）和私有方法（例如<code>Process</code>用于处理帧和参考线信息等）。</p> <p>此类有一些特别的函数如<code>IsValidPathReference</code>，用于检查学习模型的输出是否在路径范围内。还有<code>PathBoundToLineSegments</code>用于将离散路径边界转换为线段。</p> <p>还包含一些用于调试的函数如：<code>RecordDebugInfo</code> 记录调试信息。</p> <p>这个类还有一些静态整型的私有成员变量， 如用于记录有效路径引用计数的 <code>valid_path_reference_counter_</code> 和用于记录总路径计数的 <code>total_path_counter_</code>。</p> <p>这个头文件还包含了类的原型，使得其他文件可以使用这个类，而无需知道类的详细实现。</p> <h3>path_time_heuristic</h3> <h4>dp_st_cost.h</h4> <p>这是Apollo自动驾驶系统的一部分，位于./tasks/path_time_heuristic目录下的DpStCost头文件中。DpStCost类是速度优化器的成本计算部分。类中主要定义了多个成本计算的方法，包括障碍物成本、空间潜在成本、速度成本，及运动状态的加速成本和急转弯成本等。原始速度、当前速度、加速度以及指向障碍物的指针被用作这些方法的输入参数。</p> <p>此类也包含一些私有方法以及数据成员，如计算加速成本和急转弯成本的方法，存储配置信息、障碍物信息、可驾驶边界等数据成员。另外，还有用于存储区域内的边界成本和清除范围等数据结构。最后，类中有私有方法，用于添加与保持障碍物清除范围相关的数据，并合并和排序范围。</p> <p>这个类的目的是为了在给定车辆路径和时间的情况下，使用动态规划法计算出可能的最优速度剖面，从而实现对车辆的速度优化。</p> <h4>gridded_path_time_graph.h</h4> <p>该文件是Apollo自动驾驶项目的一部分，位于./tasks/path_time_heuristic目录下，名为gridded_path_time_graph.h。此文件定义了GriddedPathTimeGraph类，该类主要为Apollo自动驾驶系统进行路径和时间规划。</p> <p>GriddedPathTimeGraph类的目的是通过考虑许多因素（如车辆参数、障碍物等）来生成和优化车辆行驶的速度数据。主要公共方法是Search，它搜寻出一种满足约束的速度分布，该分布能尽可能避免与障碍碰撞且尽可能接近期望速度。</p> <p>为了实现这一目标，该类中使用了如下几种私有方法：</p> <ul> <li>InitCostTable: 初始化代价表，</li> <li>InitSpeedLimitLookUp: 初始化速度限制表，</li> <li>RetrieveSpeedProfile: 获取速度分布，</li> <li>CalculateTotalCost: 计算总代价。</li> </ul> <p>此外，该类还定义了一些私有数据成员，例如车辆参数、初始化点、速度限制、时间和距离等变量，以及代价、阻力和障碍物等那些需要查询和更新的数据结构。</p> <h4>path_time_heuristic_optimizer.h</h4> <p>这个文件是Apollo自动驾驶系统项目的一部分。</p> <p>&quot;./tasks/path_time_heuristic/path_time_heuristic_optimizer.h&quot; 是一个C++头文件，定义了一个名为 <code>PathTimeHeuristicOptimizer</code> 的类，它是 <code>SpeedOptimizer</code> 的派生类。</p> <p>这个类的主要目标是使用动态编程算法进行ST图速度规划。这个类包含了一些主要成员函数，包括<code>Init</code>函数，用于初始化类的配置，以及<code>Process</code>函数用于处理路径数据，它还包含了一个私有成员函数<code>SearchPathTimeGraph</code>用于搜寻路径时间图。</p> <p>此外，类定义了一些私有数据成员，如初始点 <code>init_point_</code>, 自动驾驶车辆的SL边界 <code>adc_sl_boundary_</code> 和配置类 <code>config_</code>。</p> <p>最后，这个类被注册为一个插件，在Apollo系统的其他部分可以调用和使用。</p> <h4>st_graph_point.h</h4> <p>该源代码文件名为&quot;st_graph_point.h&quot;，是Apollo自动驾驶系统规划模块路径时间启发式任务中的一个头文件。它定义了一个叫做 &quot;StGraphPoint&quot; 的类，是空间-时间（S-T）图的一部分，该图被用于规划车辆的行驶路径。</p> <p>在这个类中，包含了一些私有属性如单点的空间-时间坐标(STPoint)，前一个点的引用 (pre<em>point</em>)，在S-T图中的索引位置(index<em>s</em> and index<em>t</em>)，车辆的最优速度(optimal<em>speed</em>)等。这个类还定义了一些成员函数，用于初始化对象，获取和设置上述属性。</p> <p>它还用来记录与该点关联的不同成本如参考成本，障碍物成本，空间潜在成本，和总成本。这些成本被用于计算最优的路径。</p> <p>最后，本文件是根据Apache License 2.0发布的，这是一个允许用户自由使用、复制和修改代码，同时也要求用户在复制或再发行时附带版权声明和免责声明的开源许可证。</p> <h3>piecewise_jerk_speed</h3> <h4>piecewise_jerk_speed_optimizer.h</h4> <p>这是一个头文件，定义了一个名为PiecewiseJerkSpeedOptimizer的类，它是SpeedOptimizer类的派生类。此类是Apollo自动驾驶系统中计划模块任务的一部分，用于进行速度优化。</p> <ul> <li><code>Init</code>方法是类的初始化方法。</li> <li><code>Process</code>方法用于处理路径数据，initial point和速度数据，它是SpeedOptimizer类中的虚拟方法，已在此处重写。</li> <li><code>AdjustInitStatus</code>方法是用于调整初始状态的方法。</li> </ul> <p>此文件还包含一个CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏，用于在Apollo&#8217;s Cyber RT框架的插件管理器中注册PiecewiseJerkSpeedOptimizer类，使得整个系统可以实例化并使用这个类。</p> <p>总的来说，这个类主要是通过&quot;piecewise jerk minimum&quot;方法对车辆的速度进行优化。</p> <h3>piecewise_jerk_speed_nonlinear</h3> <h4>piecewise_jerk_speed_nonlinear_ipopt_interface.h</h4> <p>这是 Apollo 自动驾驶系统中的一部分。Apollo 是一个开源的自动驾驶系统，由百度公司主导开发。</p> <p>文件路径是 <code>./tasks/piecewise_jerk_speed_nonlinear/piecewise_jerk_speed_nonlinear_ipopt_interface.h</code>，这意味着它是 Apollo 系统中的 <code>planning</code> 模块的一部分，处理一个特定的任务：<code>piecewise_jerk_speed_nonlinear</code>。</p> <p>这个头文件定义了一个名称为 <code>PiecewiseJerkSpeedNonlinearIpoptInterface</code> 的类，该类的功能是用于处理插值加速度（jerk）非线性优化问题的接口。这种情况常见于速度规划中，被用来平滑地改变车辆的速度。</p> <p>该类从 Ipopt（开源非线性优化软件包）的 <code>TNLP</code> 类继承而来。<code>TNLP</code> 为 Nonlinear Programming (非线性规划问题) 提供了定义的接口。</p> <p><code>PiecewiseJerkSpeedNonlinearIpoptInterface</code> 类包含许多方法，用于设置和获取优化问题的各种参数，如初始状态、参考速度、优化结果等。同时，类还覆盖了 <code>TNLP</code> 中的一些方法，用于定义非线性规划问题的结构，如目标函数、约束条件、雅可比矩阵和黑塞矩阵等。</p> <p>从这个头文件中，我们可以看出，这个类用于解决具有 jerk 最小化约束的非线性速度规划问题。根据这个类的方法，采用 piecewise（分段）方法来处理加速度和速度的限制，同时考虑到路径曲率等因素在内的约束条件。</p> <h4>piecewise_jerk_speed_nonlinear_optimizer.h</h4> <p>该文件是一个头文件（.h文件），名为piecewise_jerk_speed_nonlinear_optimizer，属于Apollo自动驾驶系统的planning模块的一个子任务。</p> <p>在该头文件中定义了一个名为PiecewiseJerkSpeedNonlinearOptimizer的类，该类继承自SpeedOptimizer类。它主要执行速度优化任务，关注具有连续加速度特征的速度优化。</p> <p>该类中包含了许多私有成员变量，主要用于存储速度优化的相关参数，如时间间隔、总长度、总时间、初始值、动态可行边界条件等。除了数值类型的变量外，还包含了一些复杂对象如PiecewiseJerkTrajectory1d smoothed_speed_limit_来存储平滑后的速度限制，以及一些用于处理速度优化任务的方法。</p> <p>在公有成员函数部分，初始化方法Init、处理方法Process以及析构函数都被宣布为override，意味着它们在基类SpeedOptimizer中有定义，并在这里被重新定义。</p> <p>该类还包括一些私有方法，包括处理速度限制可行性、平滑速度限制、路径曲率、优化速度等操作。</p> <p>文件最后的CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN代码是对该类的插件注册，这说明PiecewiseJerkSpeedNonlinearOptimizer类会作为一个插件被Cyber框架动态加载和卸载。</p> <h3>pull_over_path</h3> <h4>pull_over_path.h</h4> <p>这是一个名为PullOverPath的C++程序模块，它属于Apollo自动驾驶项目中planning模块的一个子任务。</p> <p>该模块继承自PathGeneration基类，实现了一种特殊的路径规划，为自动驾驶车辆 Pull Over（停靠）操作制定路径。</p> <p>文件包含以下核心函数：</p> <ul> <li><code>Init()</code>：初始化函数，接受配置目录、名称和依赖注入器作为参数。</li> <li><code>Process()</code>：处理函数，接受帧和参考线信息作为参数，这是一个重写的函数，用来处理帧信息和引用线信息。</li> <li><code>DecidePathBounds()</code>：决定路径边界的函数。</li> <li><code>OptimizePath()</code>：优化路径的函数，针对每个路径边界进行优化。</li> <li><code>AssessPath()</code>：评估路径的函数，评估每个路径的可行性并选择最优路径。</li> <li><code>GetBoundaryFromRoads()</code>: 从路线获取边界的函数。</li> <li><code>UpdatePullOverBoundaryByLaneBoundary()</code>: 用当前车道边界更新左或右路径边界的函数。</li> <li><code>SearchPullOverPosition()</code>: 搜索可行的拉过位置的函数。</li> <li><code>FindNearestPullOverS()</code>: 根据车辆动力学模型计算最近的拉过位置的函数。</li> <li><code>FindDestinationPullOverS()</code>: 通过路线结束位置计算拉过位置的函数。</li> </ul> <p>该PullOverPath模块注重捕捉合适的停靠点和路径优化，对车辆的停靠行为进行了深度设计和优化。</p> <h3>reuse_path</h3> <h4>reuse_path.h</h4> <p>这个文件是Apollo自动驾驶项目的一部分，特别是在规划模块中的任务子模块。这个文件定义了一个名为ReusePath的类，这个类从PathGeneration基类继承。</p> <p>这个ReusePath类主要负责是否可以重用之前生成的路径。它包括了一些私有方法来完成这个工作，比如检查路径是否可重用，获取当前的停车位置，获取历史的停车位置，获取ADC（AutonomousDrivingCar）的位置，检查是否有阻挡的障碍物，判断是否忽略阻挡的障碍物，检查路径是否是碰撞自由，检查路径长度等。</p> <p>这个类的公有方法只有一个Init方法，用于初始化类的状态。</p> <p>在文件的最后，该类被注册到Cyber的插件管理器中，使得其可以被Cyber框架动态加载和使用。</p> <h3>rss_decider</h3> <h4>rss_decider.h</h4> <p>这是一个名为 &quot;RssDecider&quot; 的C++头文件（rss_decider.h），它是模块/planning/tasks/rss_decider内的一部分。这个文件定义了名为 &quot;RssDecider&quot; 的C++类，该类主要负责在自动驾驶系统中作出决策。该类是&quot;Task&quot;类的派生类，它具有几个重要的方法：</p> <ol> <li>&quot;Init&quot;: 用来初始化&#8217;RssDecider&#8217;的特定配置.</li> <li>&quot;Execute&quot;: 主要执行任务，通过处理给定的Frame和ReferenceLineInfo.</li> <li>&quot;Process&quot;: 在执行过程中调用，来处理Frame和ReferenceLineInfo.</li> <li>&quot;rss_config_default_dynamics&quot;, &quot;rss_create_ego_object&quot;, &quot;rss_create_other_object&quot;, &quot;rss_dump_world_info&quot; 这些是工具函数，用于帮助类方法处理地理定位和移动对象数据。</li> </ol> <p>该文件还定义了名为&quot;rss_world_model_struct&quot;的结构体，它包含了一系列的变量，主要是关于行驶环境的信息。</p> <p>此外，这个文件使用&#8217;CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN&#8217;宏，是为了将 &#8216;RssDecider&#8217;类注册为插件，以便在运行时动态地加载和卸载。</p> <h3>rule_based_stop_decider</h3> <h4>rule_based_stop_decider.h</h4> <p>这个C++的头文件定义了一个类，名为&quot;RuleBasedStopDecider&quot;，它归属于Apollo项目下的&quot;planning&quot;命名空间。这个类看起来是用来实现自动驾驶汽车的某种规则基础的停车决策逻辑。</p> <p>&quot;RuleBasedStopDecider&quot;类继承自&quot;Decider&quot;类，并且重写了&#8217;Init&#8217;和&#8217;Process&#8217;两个方法。&#8217;Init&#8217;方法用以初始化该类，而&#8217;Process&#8217;方法则负责处理停车决策。</p> <p>此外，该类还定义了一些方法，包括&#8217;AddPathEndStop&#8217;，&#8217;CheckLaneChangeUrgency&#8217;，&#8217;StopOnSidePass&#8217;，&#8217;CheckSidePassStop&#8217;，&#8217;BuildSidePassStopFence&#8217;，&#8217;CheckADCStop&#8217;和&#8217;CheckClearDone&#8217;等，这些方法表明该类是在考虑一系列的路况和规则进行停车决策，如紧急车道改变，路径结束，侧道超车等。</p> <p>此类还定义了一些私有成员变量，包括一个config_，以及几个布尔类型的变量，用于跟踪车道更改和规划的状态。</p> <p>文件还使用了CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏来注册RuleBasedStopDecider类为插件。</p> <h3>speed_bounds_decider</h3> <h4>speed_bounds_decider.h</h4> <p>这个文件是一个头文件（header file），文件名为 <code>speed_bounds_decider.h</code>。它属于一个名为 <code>./tasks/speed_bounds_decider</code> 的目录中。该头文件定义了一个名为 <code>SpeedBoundsDecider</code> 的类。</p> <p><code>SpeedBoundsDecider</code> 类是 <code>Decider</code> 类的子类，并覆盖了 <code>Init</code> 和 <code>Process</code> 方法。除此之外，还自定义了 <code>SetSpeedFallbackDistance</code> 和 <code>RecordSTGraphDebug</code> 私有方法。</p> <p>头文件还包含对其他头文件的引用，例如 <code>&lt;memory&gt;</code>, <code>&lt;string&gt;</code>，以及该项目中的一些头文件，如 <code>speed_bounds_decider.pb.h</code>， <code>plugin_manager.h</code>， <code>frame.h</code>， <code>st_graph_data.h</code> 和 <code>decider.h</code>。</p> <p><code>SpeedBoundsDecider</code> 类可能用于决定计划轨迹或动作条件下的速度边界。这在自动驾驶领域是非常重要的一部分，因为合理的速度控制可以保证车辆的平稳驾驶和乘客的舒适度。</p> <p>注意，这段代码受 Apache License 2.0 许可证保护。</p> <h4>speed_limit_decider.h</h4> <p>这是一个C++头文件，定义了一个名为SpeedLimitDecider的类，这个类属于Apollo自动驾驶系统中的planning模块。该类的主要作用可能是基于给定参数来决定车辆的速度限制。</p> <p>SpeedLimitDecider类主要包含以下部分：</p> <ul> <li> <p>构造函数：初始化SpeedLimitDecider类。输入参数包括SpeedBoundsDeciderConfig、ReferenceLine和PathData。</p> </li> <li> <p>析构函数：声明为虚函数并默认实现。</p> </li> <li> <p>GetSpeedLimits：这是一个公开的、返回common::Status的虚函数，用于计算速度限制。它接收一组障碍物和一个指向&#8217;速度限制数据&#8217;的指针(将结果填充到其中)。</p> </li> <li> <p>GetCentricAccLimit和GetAvgKappa：这两个是私有函数，被用于内部计算。</p> </li> <li> <p>类变量：包括速度范围限制、参照线、路径数据和车辆参数等。</p> </li> </ul> <p>此文件也包括一系列C++头文件和protobuf文件的引用，这些都是进行计算和操作所需要的定义和工具。</p> <p>请注意这个头文件没有完整的函数实现，这些可能在对应的.cpp文件中。</p> <h4>st_boundary_mapper.h</h4> <p>这是一份名为&quot;st_boundary_mapper.h&quot;的C++头文件，出自Apollo开源自动驾驶系统的planning模块中的speed_bounds_decider任务中。这个文件定义了一个名为STBoundaryMapper的类，它的主要作用是计算和映射时空(Spatial Temporal, ST)边界。</p> <p>此类用于将实际的障碍物和车辆决策映射到ST边界上，辅助车辆进行决策。ST图是一个将障碍物的位置和时间信息结合在一起的图像表示，帮助车辆规划在一个安全的时空窗口内行驶，避免与障碍物相撞。</p> <p>在STBoundaryMapper中，定义了多个方法，包括：</p> <ol> <li>计算单个障碍物的ST边界。</li> <li>将障碍物映射到ST图上的点，并判断是否与自动驾驶车辆发生了重叠。</li> <li>将关于停车决策映射到ST图上。</li> </ol> <p>此类进行的所有操作都依赖于多个输入之间的因果关系，例如车辆配置、参考线、路径数据、计划距离和时间等。</p> <h3>speed_decider</h3> <h4>speed_decider.h</h4> <p>这个文件是Apollo项目中的一部分，这个项目是一个开源的自动驾驶系统。具体到这个文件，它定义了一个名为SpeedDecider的类，这个类是决定车辆速度的一部分。</p> <p>这个文件位于./tasks/speed_decider文件夹下，说明它属于planning模块的一部分，用于进行速度决策任务。</p> <p>SpeedDecider类继承自Task类，表明它是任务合集中的一项。这个类主要有两个公有方法，分别为Init和Execute。其中Init方法用于初始化，并接受配置目录、名称、以及一个可选的依赖注入器作为参数。Execute方法用于执行任务，接受一个Frame对象和一个ReferenceLineInfo对象作为参数。</p> <p>这个类的私有方法主要关注如何满足行驶规定、判断是否需要避让并决策避让方式、阐明如何处理行人和其他障碍物等细节。例如，CheckKeepClearCrossable和CheckKeepClearBlocked用于检查是否通行通过，CreateStopDecision、CreateFollowDecision、CreateYieldDecision、CreateOvertakeDecision等方法分别创建“停车”、“跟随”、“让行”和“超车”的决策等。</p> <p>文件的最后，使用CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏来注册SpeedDecider插件。这是一种插件化的设计方式，让代码的扩展性更强，维护性更好。</p> <h3>st_bounds_decider</h3> <h4>st_bounds_decider.h</h4> <p>这个文件是“STBoundsDecider.h”，它定义的是一个名为“STBoundsDecider”的类。这个类是一个Apollo自动驾驶系统中的任务，主要用于决定速度和时间（ST）边界。它继承自&quot;Decider&quot;基类，并添加了一些私有函数以实现特定功能。</p> <p>文件开始部分默认定义了ST边界的解析度和可穿越阈值。然后，类的主体开始。其中定义了几个主要方法：<code>Init</code>、<code>Process</code>、<code>InitSTBoundsDecider</code>、<code>GenerateFallbackSTBound</code>、<code>GenerateRegularSTBound</code>、<code>RemoveInvalidDecisions</code>、<code>RankDecisions</code>、<code>BackwardFlatten</code>和<code>RecordSTGraphDebug</code>。每一个都有特定的作用，比如初始化ST边界，处理帧或参考线信息，生成后备或常规的ST边界，排列决定等。</p> <p>此文件还包含对其他类的引用，如<code>Frame</code>、<code>ReferenceLineInfo</code>、<code>STGuideLine</code>、<code>STDrivingLimits</code>和<code>STObstaclesProcessor</code>等。这表明该类在执行其任务时将会与这些类相关联和互动。</p> <p>此类在尾部被注册为一个插件，使用机器人操作系统（ROS）的<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>宏进行注册。</p> <p>总的来说，文件是关于定义一个关键决策任务方法的类，主要目的是为了处理自动驾驶汽车在给定时间和速度的限制下如何行驶。</p> <h4>st_driving_limits.h</h4> <p>这个文件名为&quot;st_driving_limits.h&quot;的头文件，是Apollo自动驾驶项目中的一部分，更具体地说，它是planning模块中一个称为STDrivingLimits的类的声明。这个类主要决定了汽车的动态限制，如最大速度、最大加速和最大减速等。</p> <p>在STDrivingLimits类中，主要包含有如下几个函数：</p> <ul> <li>初始化函数，用于初始化决定汽车动态的变量。</li> <li>GetVehicleDynamicsLimits函数，用于根据时间计算因车辆动力学导致的行驶限制。</li> <li>UpdateBlockingInfo函数，用于更新车辆动力学限制的锚定，例如，当ADC（自动驾驶汽车）被某些障碍物阻挡时，其最大可行驶的范围、最大速度等也相应受到限制。</li> </ul> <p>除此之外，这个类还包含有一些私有变量，用于计算车辆动态限制，如最大加速度(max<em>acc</em>)、最大减速度(max<em>dec</em>)和最大速度(max<em>v</em>)，而lower<em>t0</em>，lower<em>s0</em>，lower_v0_和upper<em>t0</em>，upper<em>s0</em>，upper_v0_则是与最大和最小驾驶范围有关的变量。</p> <p>还有一些私有变量是用于表示v(速度)与s(曲率)之间关系的限制，这包括了三个部分：由曲率导致的路径段的速度限制，交通限制导致的速度限制（如减速带等)，以及为了安全考虑，当附近有其他障碍物时的速度限制。这些所有的限制都储存在对应的<code>std::vector&lt;std::tuple&lt;double, double, double&gt;&gt;</code>变量中。</p> <h4>st_guide_line.h</h4> <p>这是一个名为&quot;STGuideLine&quot;的C++头文件，属于Apollo项目（一个开源自动驾驶平台）的模块之一。这个文件主要定义了一个&quot;STGuideLine&quot;类，该类是处理导向线信息的核心部分，主要包含车辆期望速度、轨迹点和堵塞信息等参数。</p> <p>通过这个类，可以初始化期望速度，初始化期望速度和速度参照，获取来自时间参数的导向线S，更新堵塞信息等。</p> <p>文件还引用了一系列的protobuf消息和其他模块，包括基础消息，车辆配置消息，规划相关的一些基础数据等。</p> <p>在类的实现部分有一些TODO标记，表示开发者希望将其从一个恒定速度模型升级为一个恒定加速度模型。</p> <h4>st_obstacles_processor.h</h4> <p>文件名为 &quot;st_obstacles_processor.h&quot;，这是一个头文件，其中定义了一个名为 &quot;STObstaclesProcessor&quot; 的类，该类主要用于处理和管理在s-t(距离-时间)图中的障碍。这个类是 Apollo 自动驾驶系统中的路径规划部分的一部分，具体来说，是处理决策过程中如何考虑到速度、距离、时间和障碍等因素的一部分。</p> <p>类 &quot;STObstaclesProcessor&quot; 提供了一系列方法供调用，这些方法包括：</p> <ul> <li>初始化方法 &quot;Init&quot;，用于初始化内部的一些变量。</li> <li>&quot;MapObstaclesToSTBoundaries&quot;，用于将障碍物映射到 S-T 边界上，用于后续的路径决策。</li> <li>&quot;GetAllSTBoundaries&quot; 用于获取所有的 S-T 边界。</li> <li>&quot;GetSBoundsFromDecisions&quot; 和 &quot;GetLimitingSpeedInfo&quot;，分别用于从已经作出的决策中获取 S-边界和限制速度信息。</li> <li>&quot;SetObstacleDecision&quot;，用于为一个或多个障碍物设置决策。</li> </ul> <p>此外，&quot;STObstaclesProcessor&quot; 类还定义了许多私有成员函数，这些函数在内部实现，为上述公开方法提供支持。</p> <h2>traffic_rules</h2> <h3>backside_vehicle</h3> <h4>backside_vehicle.h</h4> <p>这是一个属于Apollo自动驾驶系统项目的一部分的C++源代码文件。文件名暗示该类主要处理与车辆后面的交通规则相关的逻辑。</p> <p>具体来说，它定义了一个名为&quot;BacksideVehicle&quot;的类，这是一个从&quot;TrafficRule&quot;基类继承的特殊类型的交通规则类。根据这个规则，系统在识别到无车道更改的情况下会为后方车辆使用车道保持策略。此类定义了一些方法，包括初始化（init），应用规则（applyrule）和重置（reset）等。其中，使用到的配置信息通过&quot;BacksideVehicleConfig&quot;进行保存。至于具体的车道保持障碍决策，通过&quot;MakeLaneKeepingObstacleDecision&quot;方法进行实现。</p> <p>此外，在这个类中提供了一个名为&quot;PredictionLineOverlapEgo&quot;的方法，用来判断预测线是否与自车有重叠。</p> <p>在文件的结尾，&quot;BacksideVehicle&quot;类是作为一个插件注册到总的插件管理器中。</p> <h3>crosswalk</h3> <h4>crosswalk.h</h4> <p>这个文件是一个C++头文件，名为&quot;crosswalk.h&quot;。文件位于./traffic_rules/crosswalk目录下，表示它可能是关于交通规则模块中的人行横道功能部分的定义。</p> <p>文件中实现了一个名为Crosswalk的类，该类继承自TrafficRule类，提供了一些公共和私有的函数。它的一些主要功能包括：</p> <ol> <li>Init函数：对Crosswalk对象进行初始化。</li> <li>ApplyRule函数：应用交通规则。</li> <li>Reset函数：重置对应的人行横道重叠区域数据。</li> <li>MakeDecisions函数：对形参中的帧数据和参考线信息做出决策，具体实现未在代码中给出。</li> <li>FindCrosswalks函数：找出所需的人行横道，具体实现未在代码中给出。</li> <li>CheckStopForObstacle函数：检查是否因障碍物停车，具体实现未在代码中给出。</li> </ol> <p>还用到了一些私有字段，如CrosswalkConfig对象config_，常量字符指针CROSSWALK_VO_ID_PREFIX和PathOverlap类型的向量crosswalk<em>overlaps</em>。</p> <p>这个头文件还对CYBER(一个Apollo项目的底层框架)进行了插件注册，将Crosswalk类作为TrafficRule的一个插件进行了注册。</p> <h3>destination</h3> <h4>destination.h</h4> <p>这段代码是Apollo自动驾驶系统的一部分，主要位于路径./traffic_rules/destination/下的destination.h头文件中。这个类的目标是决定是否应该在目的地停车。</p> <p>这个类名叫做&quot;Destination&quot;，并且他是个&quot;TrafficRule&quot;的子类。它有四个主要的方法：初始化函数&quot;Init&quot;，析构函数(&quot;~Destination&quot;)，&quot;ApplyRule&quot;和&quot;Reset&quot;方法。其中，&quot;ApplyRule&quot;似乎是用来应用相关规则的主要函数，&quot;Reset&quot;用于重置状态。</p> <p>在私有变量中，有一个<code>DestinationConfig config_</code>实例，它可能是用来保存与该类相关的配置信息的。它还有一个<code>MakeDecisions</code>方法，这个函数可能是在给定的上下文中制定决策。</p> <p>需要注意的是，根据文件头中的注释，这个文件似乎是在 Apache License 2.0 下发布的。</p> <h3>keepclear</h3> <h4>keep_clear.h</h4> <p>这个文件是 Apollo 自动驾驶系统中的一部分，具体位置在模块planning的traffic_rules的一个子模块keepclear中。该部分是一个名为 <code>KeepClear</code> 的类的声明文件，从代码中可以看到它是从 <code>TrafficRule</code> 基类继承来的。</p> <p>根据文件中的注释，这个类的主要功能是为每一个清晰区域创建一个虚拟障碍。</p> <p>在这个 <code>KeepClear</code> 类中，我们可以看到以下几种主要方法：</p> <ul> <li><code>Init</code> 方法用于初始化该类的一个对象，它接受一个名字和一个 DependencyInjector 类型的共享指针。</li> <li><code>ApplyRule</code> 存在用于应用某种交通规则，接受一个指向Frame的指针和一个指向ReferenceLineInfo的指针。</li> <li><code>Reset</code> 一种重置该类对象的方法，具体实现在本文件中并没有给出，可能在对应的 <code>.cpp</code> 文件中。</li> </ul> <p>此外，还有两个私有方法 <code>IsCreeping</code> 和 <code>BuildKeepClearObstacle</code>，他们可能是内部使用的辅助方法。</p> <h3>reference_line_end</h3> <h4>reference_line_end.h</h4> <p>这个文件被命名为reference_line_end.h，属于Apollo自动驾驶系统的代码库中的一部分。这个文件里定义了一个名为ReferenceLineEnd的类，它是TrafficRule类的派生类。文件路径表明它是Planning模块内部一个用于处理交通规则的模块。</p> <p>ReferenceLineEnd类的主要职责是根据交通情况决定是否发送重路由请求。这个类中有一个Init方法进行初始化，ApplyRule方法来应用规则，并计算框架和参考线信息。此外还有一个Reset方法进行重置，但此方法在这里并未做实际操作。</p> <p>此类中定义了一个私有配置类对象config_，驱动ID前缀为“REF<em>END</em>”。</p> <p>最后，类ReferenceLineEnd已经被注册为插件，可以通过Cyber插件管理器来使用。</p> <p>注意，整个代码都在apollo命名空间的planning命名空间中。</p> <h3>rerouting</h3> <h4>rerouting.h</h4> <p>这是一个C++头文件，位于&quot;./traffic_rules/rerouting&quot;目录下。它属于Apollo项目（一个开源的自动驾驶项目），许可证为Apache 2.0。</p> <p>这个头文件定义了一个名为&quot;Rerouting&quot;的类，该类继承自&quot;TrafficRule&quot;接口类。根据类注释，它的主要职责是基于交通状况决定是否应该发送重新路由请求。</p> <p>这个类中有若干方法，其中包括&quot;Init&quot;、&quot;ApplyRule&quot;、&quot;Reset&quot;以及私有方法&quot;ChangeLaneFailRerouting&quot;。另外包括两个私有成员：一个&quot;ReroutingConfig&quot;类型的&quot;config_&quot;，以及&quot;ReferenceLineInfo&quot;和&quot;Frame&quot;类型的指针。</p> <p>在文件的底部，通过CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏注册了Rerouting类，使得它作为插件能被加载和使用。</p> <h3>stop_sign</h3> <h4>stop_sign.h</h4> <p>这个文件是一个C++头文件，位于项目的<code>./traffic_rules/stop_sign</code>目录下，名为<code>stop_sign.h</code>。这个文件定义了一个名为<code>StopSign</code>的类，该类是<code>TrafficRule</code>类的子类，用来处理与路口停车标志相关的交通规则。</p> <p><code>StopSign</code>类中包含以下几个方法:</p> <ul> <li><code>Init</code>: 初始化方法</li> <li><code>ApplyRule</code>: 应用规则方法，这个方法可能会在某个具体的场景下使用</li> <li><code>Reset</code>: 重置方法，当前未被实现</li> <li><code>MakeDecisions</code>: 这是一个私有方法，它可能被用来做具体的决策建议。</li> </ul> <p>该文件还包含一个私有成员<code>StopSignConfig config_</code>， 用于配置停车标志行为的参数。</p> <p>文件中还定义了一个静态常量字符串<code>MARKDOWN_HASHea624d56d41763492c73b9c8fc422e16MARKDOWN<em>HASH</code>，值为&quot;SS</em>&quot;，可能用于给停车标志识别标签添加前缀。</p> <p>最后，使用宏<code>CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN</code>注册了<code>StopSign</code>插件。</p> <h3>traffic_light</h3> <h4>traffic_light.h</h4> <p>文件路径./traffic_rules/traffic_light/traffic_light.h表示这是位于模块计划中的交通规则所固有的交通灯规则子模块的头文件。</p> <p>此文件是 C++ 的头文件，声明了一个交通灯(TrafficLight)类，该类继承自TrafficRule类。这个类主要用于处理与交通灯有关的规则和决策。</p> <p>TrafficLight类声明了以下主要的公共方法:</p> <ul> <li>Init: 初始化方法，重写自基类</li> <li>ApplyRule: 应用交通灯规则</li> <li>Reset: 重置方法，重写自基类</li> </ul> <p>还声明了一个私有配置变量，以及私有的决策函数MakeDecisions。此外，类定义中包含一个静态的字符串常量，可能用于交通灯的标识。</p> <p>最后，用CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN宏向插件管理器注册了这个TrafficLight类。</p> <p>其中交通规则基类和交通灯的配置类都在其他头文件中定义，这个文件中主要是用它们来完成交通灯的特殊规则。</p> <p>整个文件都在apollo::planning命名空间中，这可能表示它是阿波罗开源自动驾驶系统的一部分。</p> <p>以上就是这个头文件的总体说明。要获取更准确的信息，需要查看相关的源文件以及其他类的具体定义。</p> <h3>yield<em>sign</em></h3> <h4>yield_sign.h</h4> <p>这个源代码文件属于一个更大的项目结构中的一部分，可能是一个自动驾驶系统的一部分。它位于<code>./traffic_rules/yield_sign</code>目录下，并命名为<code>yield_sign.h</code>。文件看起来是C++编写的。</p> <p>在内容上，这是一个头文件，定义了名为<code>YieldSign</code>的类，该类是<code>TrafficRule</code>的子类。这个子类包含了一些方法，包括<code>Init</code>、<code>ApplyRule</code>、<code>Reset</code>以及<code>MakeDecisions</code>。特别的是，<code>ApplyRule</code>和<code>MakeDecisions</code>的实现并未在此处给出，可能在相应的源文件（cpp文件）中定义。</p> <p>同时该文件还包含了类<code>YieldSign</code>的配置信息和一些私有数据。</p> <p>从其包含的protobuf头文件可以看出，这个规划模块使用了protobuf进行信息的序列化和反序列化，可能是为了跨语言、跨平台的通信，或者是为了高效地存储和读取数据。</p> <p>注释中包含Apollos的版权信息和许可证明，表明这是一个遵守Apache 2.0许可证的开源项目。</p> <p>最后一行代码注册了<code>YieldSign</code>类作为<code>TrafficRule</code>的插件，可能是项目的一种插件架构设计，不同的交通规则（如让行标志<code>YieldSign</code>、停止标志等）作为不同的插件，可以动态地加载和卸载。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planners/lattice/lattice_planner.h, ./planners/lattice/behavior/collision_checker.h, ./planners/lattice/behavior/feasible_region.h, ./planners/lattice/behavior/path_time_graph.h, ./planners/lattice/behavior/prediction_querier.h, ./planners/lattice/trajectory_generation/backup_trajectory_generator.h, ./planners/lattice/trajectory_generation/end_condition_sampler.h, ./planners/lattice/trajectory_generation/lateral_osqp_optimizer.h, ./planners/lattice/trajectory_generation/lateral_qp_optimizer.h, ./planners/lattice/trajectory_generation/lattice_trajectory1d.h, ./planners/lattice/trajectory_generation/piecewise_braking_trajectory_generator.h, ./planners/lattice/trajectory_generation/trajectory1d_generator.h, ./planners/lattice/trajectory_generation/trajectory_combiner.h, ./planners/lattice/trajectory_generation/trajectory_evaluator.h, ./planners/navi/navi_planner.h, ./planners/navi/decider/navi_obstacle_decider.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>lattice_planner.h</td> <td>定义了一个用于自动驾驶车辆规划行驶轨迹的LatticePlanner类</td> </tr> <tr> <td>collision_checker.h</td> <td>定义了CollisionChecker类，进行自动驾驶车辆的轨迹碰撞检查</td> </tr> <tr> <td>feasible_region.h</td> <td>定义了FeasibleRegion类，处理与规划路径上的可行区域相关的计算</td> </tr> <tr> <td>path_time_graph.h</td> <td>定义了PathTimeGraph类，用于确定车辆在给定时间和路径条件下的最优行为</td> </tr> <tr> <td>prediction_querier.h</td> <td>定义了PredictionQuerier类，查询预测的障碍物信息</td> </tr> <tr> <td>backup_trajectory_generator.h</td> <td>定义了BackupTrajectoryGenerator类，生成相对于参考路径点的轨迹</td> </tr> <tr> <td>end_condition_sampler.h</td> <td>定义了EndConditionSampler类，用于采样不同的末状态条件</td> </tr> <tr> <td>lateral_osqp_optimizer.h</td> <td>定义了LateralOSQPOptimizer类，用于优化车辈的横向运动轨迹</td> </tr> <tr> <td>lateral_qp_optimizer.h</td> <td>定义了LateralQPOptimizer类，决定了车辆在驶入障碍物、在行驶或者在停车时的最优行为</td> </tr> <tr> <td>lattice_trajectory1d.h</td> <td>定义了LatticeTrajectory1d类，处理1维轨迹生成的类</td> </tr> <tr> <td>piecewise_braking_trajectory_generator.h</td> <td>定义了PiecewiseBrakingTrajectoryGenerator类，用于生成在特定情况下的刹车轨迹</td> </tr> <tr> <td>trajectory1d_generator.h</td> <td>定义了Trajectory1dGenerator类， 处理1维轨迹生成的类</td> </tr> <tr> <td>trajectory_combiner.h</td> <td>定义了一个TrajectoryCombiner类，负责将单条1-D轨迹组合成3-D轨迹</td> </tr> <tr> <td>trajectory_evaluator.h</td> <td>定义了一个TrajectoryEvaluator类，负责评估和选择最优轨迹</td> </tr> <tr> <td>navi_planner.h</td> <td>定义了一个NaviPlanner类，基于实时相对地图的规划器</td> </tr> <tr> <td>navi_obstacle_decider.h</td> <td>定义了NaviObstacleDecider类，为车辆周围的障碍物做出适当的决策</td> </tr> </tbody> </table> <p>以上的每个文件都是自动驾驶规划系统子模块的一部分，主要负责处理和解决自动驾驶车辆在道路上行驶时的路径规划，预测，决策和轨迹生成等关键问题，以实现车辆的自动导航。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planners/navi/decider/navi_path_decider.h, ./planners/navi/decider/navi_speed_decider.h, ./planners/navi/decider/navi_speed_ts_graph.h, ./planners/navi/decider/navi_task.h, ./planners/public_road/public_road_planner.h, ./planners/public_road/scenario_manager.h, ./planners/rtk/rtk_replay_planner.h, ./planning_base/common/sl_polygon.h, ./planning_base/common/dependency_injector.h, ./planning_base/common/path_decision.h, ./planning_base/common/obstacle.h, ./planning_base/common/open_space_info.h, ./planning_base/common/history.h, ./planning_base/common/indexed_queue.h, ./planning_base/common/feature_output.h, ./planning_base/common/ego_info.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th style=\"text-align: left;\">文件名</th> <th style=\"text-align: right;\">功能描述</th> </tr> </thead> <tbody> <tr> <td style=\"text-align: left;\">navi_path_decider.h</td> <td style=\"text-align: right;\">负责在导航模式下生成车辆驾驶路径。</td> </tr> <tr> <td style=\"text-align: left;\">navi_speed_decider.h</td> <td style=\"text-align: right;\">负责在导航模式下生成车辆运行速度曲线。</td> </tr> <tr> <td style=\"text-align: left;\">navi_speed_ts_graph.h</td> <td style=\"text-align: right;\">用于生成具有一些限制和偏好的t-s（时间-速度）图。</td> </tr> <tr> <td style=\"text-align: left;\">navi_task.h</td> <td style=\"text-align: right;\">定义了用于完成导航模块某具体任务的NaviTask类。</td> </tr> <tr> <td style=\"text-align: left;\">public_road_planner.h</td> <td style=\"text-align: right;\">用于公路规划，生成适当的车辆路径。</td> </tr> <tr> <td style=\"text-align: left;\">scenario_manager.h</td> <td style=\"text-align: right;\">管理公共道路规划的各种驾驶情境。</td> </tr> <tr> <td style=\"text-align: left;\">rtk_replay_planner.h</td> <td style=\"text-align: right;\">从轨迹文件中读取预先记录的车辆轨迹，并根据车辆当前位置输出轨迹的适当部分。</td> </tr> <tr> <td style=\"text-align: left;\">sl_polygon.h</td> <td style=\"text-align: right;\">定义和操作一个在s和l坐标系中的多边形（可能用于车辆的路径规划）。</td> </tr> <tr> <td style=\"text-align: left;\">dependency_injector.h</td> <td style=\"text-align: right;\">用作依赖注入以实现系统组件保持松散耦合，同时保持高度模块化。</td> </tr> <tr> <td style=\"text-align: left;\">path_decision.h</td> <td style=\"text-align: right;\">为路径决策提供支持，例如研究障碍物和创建路径决策。</td> </tr> <tr> <td style=\"text-align: left;\">obstacle.h</td> <td style=\"text-align: right;\">包含关于障碍物的决策功能的类。</td> </tr> <tr> <td style=\"text-align: left;\">open_space_info.h</td> <td style=\"text-align: right;\">存储和管理关于自动驾驶车辆在开放空间中运行所需的信息。</td> </tr> <tr> <td style=\"text-align: left;\">history.h</td> <td style=\"text-align: right;\">管理车辆的历史驾驶行为和决策以供将来参考。</td> </tr> <tr> <td style=\"text-align: left;\">indexed_queue.h</td> <td style=\"text-align: right;\">创建一个带有索引的队列数据结构，拥有常见的查找、添加、清除等操作。</td> </tr> <tr> <td style=\"text-align: left;\">feature_output.h</td> <td style=\"text-align: right;\">用来处理学习数据的输出。</td> </tr> <tr> <td style=\"text-align: left;\">ego_info.h</td> <td style=\"text-align: right;\">处理关于自车的信息。</td> </tr> </tbody> </table> <p>根据分析，该程序的整体功能是：实现自动驾驶系统中车辆的行驶路线规划，对道路、障碍物和车辆状态的实时感知和决策，处理复杂情境，以确保车辆的自主、安全和高效导航。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/common/local_view.h, ./planning_base/common/planning_context.h, ./planning_base/common/trajectory_stitcher.h, ./planning_base/common/indexed_list.h, ./planning_base/common/speed_profile_generator.h, ./planning_base/common/frame.h, ./planning_base/common/learning_based_data.h, ./planning_base/common/st_graph_data.h, ./planning_base/common/obstacle_blocking_analyzer.h, ./planning_base/common/path_boundary.h, ./planning_base/common/reference_line_info.h, ./planning_base/common/decision_data.h, ./planning_base/common/message_process.h, ./planning_base/common/trajectory_evaluator.h, ./planning_base/common/nudge_info.h, ./planning_base/common/speed_limit.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>local_view.h</td> <td>提供计划模块的输入数据，包括车辆和环境的本地视图信息</td> </tr> <tr> <td>planning_context.h</td> <td>存储管理规划模块的运行时上下文信息</td> </tr> <tr> <td>trajectory_stitcher.h</td> <td>提供路径拼接相关计算的功能</td> </tr> <tr> <td>indexed_list.h</td> <td>提供非线程安全和线程安全的数据存储和操作</td> </tr> <tr> <td>speed_profile_generator.h</td> <td>提供速度路径规划的相关功能</td> </tr> <tr> <td>frame.h</td> <td>提供规划周期中的数据集合</td> </tr> <tr> <td>learning_based_data.h</td> <td>提供处理学习相关数据的功能</td> </tr> <tr> <td>st_graph_data.h</td> <td>提供处理速度-时间图的信息，如障碍物信息、地图信息</td> </tr> <tr> <td>obstacle_blocking_analyzer.h</td> <td>分析确定阻挡障碍，帮助规划更安全的路径</td> </tr> <tr> <td>path_boundary.h</td> <td>提供路径边界信息的处理功能</td> </tr> <tr> <td>reference_line_info.h</td> <td>保存并处理有关参考线的所有数据</td> </tr> <tr> <td>decision_data.h</td> <td>提供路线中遇到的障碍物信息处理的功能</td> </tr> <tr> <td>message_process.h</td> <td>提供消息处理机制，包括初始化、发布和接受消息</td> </tr> <tr> <td>trajectory_evaluator.h</td> <td>评估预期轨迹和当前轨迹的相关功能</td> </tr> <tr> <td>nudge_info.h</td> <td>提供微调障碍物骁勇相关的功能</td> </tr> <tr> <td>speed_limit.h</td> <td>提供速度限制的处理功能</td> </tr> </tbody> </table> <p>从以上分析来看，程序的整体功能是为了完成自动驾驶车辆的路线规划、决策和导航，涵盖了路径、速度、障碍物等多个要素的处理，并有针对性地进行学习和优化。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/common/path/discretized_path.h, ./planning_base/common/path/frenet_frame_path.h, ./planning_base/common/path/path_data.h, ./planning_base/common/smoothers/smoother.h, ./planning_base/common/speed/st_point.h, ./planning_base/common/speed/st_boundary.h, ./planning_base/common/speed/speed_data.h, ./planning_base/common/trajectory/discretized_trajectory.h, ./planning_base/common/trajectory/publishable_trajectory.h, ./planning_base/common/trajectory1d/piecewise_jerk_trajectory1d.h, ./planning_base/common/trajectory1d/standing_still_trajectory1d.h, ./planning_base/common/trajectory1d/constant_deceleration_trajectory1d.h, ./planning_base/common/trajectory1d/piecewise_acceleration_trajectory1d.h, ./planning_base/common/trajectory1d/piecewise_trajectory1d.h, ./planning_base/common/trajectory1d/constant_jerk_trajectory1d.h, ./planning_base/common/util/print_debug_info.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td>discretized_path.h</td> <td>处理离散路径的类</td> </tr> <tr> <td>frenet_frame_path.h</td> <td>处理Frenet坐标系中的路径的类</td> </tr> <tr> <td>path_data.h</td> <td>处理路径数据和路径决策的类</td> </tr> <tr> <td>smoother.h</td> <td>平滑轨迹的类</td> </tr> <tr> <td>st_point.h</td> <td>用于表示在ST坐标系中的点的类</td> </tr> <tr> <td>st_boundary.h</td> <td>用于表示在ST坐标系中的边界的类</td> </tr> <tr> <td>speed_data.h</td> <td>用于处理车辆速度数据的类</td> </tr> <tr> <td>discretized_trajectory.h</td> <td>用于处理离散轨迹的类</td> </tr> <tr> <td>publishable_trajectory.h</td> <td>用于处理可发布轨迹的类</td> </tr> <tr> <td>piecewise_jerk_trajectory1d.h</td> <td>用于处理一维分段恒加速度路径的类</td> </tr> <tr> <td>standing_still_trajectory1d.h</td> <td>用于处于静止状态的一维路径的类</td> </tr> <tr> <td>constant_deceleration_trajectory1d.h</td> <td>用于处理一维恒定减速运动轨迹的类</td> </tr> <tr> <td>piecewise_acceleration_trajectory1d.h</td> <td>用于处理一维分段加速度运动轨迹的类</td> </tr> <tr> <td>piecewise_trajectory1d.h</td> <td>用于处理一维分段轨迹的类</td> </tr> <tr> <td>constant_jerk_trajectory1d.h</td> <td>用于处理一维恒定加速度运动轨迹的类</td> </tr> <tr> <td>print_debug_info.h</td> <td>提供了用于打印调试信息的一系列函数</td> </tr> </tbody> </table> <p>概括: 以上分析的文件主要是支持自动驾驶系统中的规划模块，该模块对路径规划，速度规划，位置判断等功能进行操作和实现，为自动驾驶系统的稳定，安全，精确运行提供了支持。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/common/util/util.h, ./planning_base/common/util/config_util.h, ./planning_base/common/util/math_util.h, ./planning_base/common/util/evaluator_logger.h, ./planning_base/common/util/common.h, ./planning_base/gflags/planning_gflags.h, ./planning_base/learning_based/img_feature_renderer/birdview_img_feature_renderer.h, ./planning_base/learning_based/model_inference/trajectory_imitation_libtorch_inference.h, ./planning_base/learning_based/model_inference/model_inference.h, ./planning_base/learning_based/pipeline/evaluator.h, ./planning_base/learning_based/tuning/autotuning_feature_builder.h, ./planning_base/learning_based/tuning/autotuning_raw_feature_generator.h, ./planning_base/learning_based/tuning/autotuning_base_model.h, ./planning_base/learning_based/tuning/autotuning_mlp_net_model.h, ./planning_base/learning_based/tuning/speed_model/autotuning_speed_mlp_model.h, ./planning_base/learning_based/tuning/speed_model/autotuning_speed_feature_builder.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>util.h</td> <td>定义了一些实用函数，支持自动驾驶系统的规划环节。</td> </tr> <tr> <td>config_util.h</td> <td>定义了一个处理planning模块配置的类。</td> </tr> <tr> <td>math_util.h</td> <td>定义了一些数学计算相关的函数。</td> </tr> <tr> <td>evaluator_logger.h</td> <td>定义了一个类用于将评估信息记录到日志中。</td> </tr> <tr> <td>common.h</td> <td>包含了一些常用函数和数据结构的定义。</td> </tr> <tr> <td>planning_gflags.h</td> <td>定义了一些全局标志，用于控制不同模块参数。</td> </tr> <tr> <td>birdview_img_feature_renderer.h</td> <td>定义了一个类，用于构建机器学习项目中的图像特征。</td> </tr> <tr> <td>trajectory_imitation_libtorch_inference.h</td> <td>定义了一个类，用于加载和推断基于学习的轨迹模型。</td> </tr> <tr> <td>model_inference.h</td> <td>定义了一个基于学习的模型推断的基类。</td> </tr> <tr> <td>evaluator.h</td> <td>定义了评估器类，用于评估学习结果。</td> </tr> <tr> <td>autotuning_feature_builder.h</td> <td>定义了一个类，从原始特征生成器构建模型相关的输入特征。</td> </tr> <tr> <td>autotuning_raw_feature_generator.h</td> <td>定义了一个类，用于生成自动调优的原始特征。</td> </tr> <tr> <td>autotuning_base_model.h</td> <td>提供了一个用于自动调优的基本模型。</td> </tr> <tr> <td>autotuning_mlp_net_model.h</td> <td>定义了多层感知机神经网络模型进行自动调整的实现。</td> </tr> <tr> <td>autotuning_speed_mlp_model.h</td> <td>提供了车辆规划过程中用作速度模型微调（autotuning）的多层感知机。</td> </tr> <tr> <td>autotuning_speed_feature_builder.h</td> <td>它定义了一个类，该类用于构建车辆规划模型的速度特征。</td> </tr> </tbody> </table> <p>总体来说，这是一个志在构建自动驾驶系统的规划系统的项目，通过一系列的模型推断、自动调优以及特征生成和处理，实现了车辆在各种复杂条件下的精确和高效的路径规划。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/math/discrete_points_math.h, ./planning_base/math/curve_math.h, ./planning_base/math/polynomial_xd.h, ./planning_base/math/constraint_checker/constraint_checker.h, ./planning_base/math/constraint_checker/constraint_checker1d.h, ./planning_base/math/curve1d/quartic_polynomial_curve1d.h, ./planning_base/math/curve1d/curve1d.h, ./planning_base/math/curve1d/polynomial_curve1d.h, ./planning_base/math/curve1d/cubic_polynomial_curve1d.h, ./planning_base/math/curve1d/quintic_spiral_path_with_derivation.h, ./planning_base/math/curve1d/quintic_spiral_path.h, ./planning_base/math/curve1d/quintic_polynomial_curve1d.h, ./planning_base/math/curve1d/piecewise_quintic_spiral_path.h, ./planning_base/math/discretized_points_smoothing/fem_pos_deviation_sqp_osqp_interface.h, ./planning_base/math/discretized_points_smoothing/cos_theta_smoother.h, ./planning_base/math/discretized_points_smoothing/fem_pos_deviation_osqp_interface.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>文件功能</th> </tr> </thead> <tbody> <tr> <td>discrete_points_math.h</td> <td>处理离散的点，例如计算路径剖面</td> </tr> <tr> <td>curve_math.h</td> <td>处理曲线的数学计算，例如计算曲率和曲率导数</td> </tr> <tr> <td>polynomial_xd.h</td> <td>定义一个处理多项式的类，例如用于数学表达式的解析和运算</td> </tr> <tr> <td>constraint_checker.h</td> <td>检查轨迹的约束条件，例如限制速度和加速度</td> </tr> <tr> <td>constraint_checker1d.h</td> <td>检查一维轨迹的约束条件，例如避免碰撞</td> </tr> <tr> <td>quartic_polynomial_curve1d.h</td> <td>定义四次多项式的曲线类，例如用于路径规划</td> </tr> <tr> <td>curve1d.h</td> <td>定义一维曲线及其操作，例如计算曲线的长度和曲率</td> </tr> <tr> <td>polynomial_curve1d.h</td> <td>定义一维多项式曲线及其操作，例如估算函数值和曲率</td> </tr> <tr> <td>cubic_polynomial_curve1d.h</td> <td>描述三次多项式1D曲线，常用于路径规划</td> </tr> <tr> <td>quintic_spiral_path_with_derivation.h</td> <td>计算五次多项式定义的螺旋路径及其导数</td> </tr> <tr> <td>quintic_spiral_path.h</td> <td>描述并支持计算五次螺旋路径功能，应用于车辆导航</td> </tr> <tr> <td>quintic_polynomial_curve1d.h</td> <td>描述五次多项式1D曲线，常用于高精度路径规划</td> </tr> <tr> <td>piecewise_quintic_spiral_path.h</td> <td>描述用五次螺旋曲线创建的分段路径，用于路径规划</td> </tr> <tr> <td>fem_pos_deviation_sqp_osqp_interface.h</td> <td>提供与OSQP优化库的接口，为位置偏差问题的求解提供接口</td> </tr> <tr> <td>cos_theta_smoother.h</td> <td>平滑处理一系列点，保证车辆平稳行驶</td> </tr> <tr> <td>fem_pos_deviation_osqp_interface.h</td> <td>利用有限元法求解轨道偏差问题，用于确保车辆正确地行驶在目标路径上</td> </tr> </tbody> </table> <p>整体来看，这套代码通过一系列的数值分析、多项式处理、曲线抽象、约束检查和优化方法，实现了自动驾驶的路径规划，以保证车辆在各种情况下能行驶在最优和最安全的轨道上。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/math/discretized_points_smoothing/cos_theta_ipopt_interface.h, ./planning_base/math/discretized_points_smoothing/fem_pos_deviation_smoother.h, ./planning_base/math/discretized_points_smoothing/fem_pos_deviation_ipopt_interface.h, ./planning_base/math/piecewise_jerk/piecewise_jerk_problem.h, ./planning_base/math/piecewise_jerk/piecewise_jerk_path_problem.h, ./planning_base/math/piecewise_jerk/piecewise_jerk_speed_problem.h, ./planning_base/math/smoothing_spline/osqp_spline_1d_solver.h, ./planning_base/math/smoothing_spline/spline_2d_constraint.h, ./planning_base/math/smoothing_spline/affine_constraint.h, ./planning_base/math/smoothing_spline/spline_seg_kernel.h, ./planning_base/math/smoothing_spline/osqp_spline_2d_solver.h, ./planning_base/math/smoothing_spline/spline_2d.h, ./planning_base/math/smoothing_spline/spline_1d_kernel.h, ./planning_base/math/smoothing_spline/spline_1d_constraint.h, ./planning_base/math/smoothing_spline/spline_1d.h, ./planning_base/math/smoothing_spline/spline_1d_seg.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>cos_theta_ipopt_interface.h</td> <td>提供了将道路变窄和宽度变化等因素纳入优化对象的功能</td> </tr> <tr> <td>fem_pos_deviation_smoother.h</td> <td>提供了将道路位置偏差整合到规划框架中的功能</td> </tr> <tr> <td>fem_pos_deviation_ipopt_interface.h</td> <td>提供了封装到Ipopt优化器的接口功能</td> </tr> <tr> <td>piecewise_jerk_problem.h</td> <td>描述了一种平滑控制问题，保证其输出的路径在相邻节点间保持连续</td> </tr> <tr> <td>piecewise_jerk_path_problem.h</td> <td>描述了一种让自动驾驶车辆尽量平滑行驶的方法</td> </tr> <tr> <td>piecewise_jerk_speed_problem.h</td> <td>提供了控制自动驾驶汽车速度的平滑变化的策略</td> </tr> <tr> <td>osqp_spline_1d_solver.h</td> <td>提供了一个求解一维样条曲线优化问题的求解器</td> </tr> <tr> <td>spline_2d_constraint.h</td> <td>提供了二维插值样条的约束条件</td> </tr> <tr> <td>affine_constraint.h</td> <td>提供了放射约束的定义</td> </tr> <tr> <td>spline_seg_kernel.h</td> <td>提供了生成样条积分核心的功能</td> </tr> <tr> <td>osqp_spline_2d_solver.h</td> <td>提供了一个求解二维样条曲线优化问题的求解器</td> </tr> <tr> <td>spline_2d.h</td> <td>提供了二维路径中融合的样条曲线优化和计算服务</td> </tr> <tr> <td>spline_1d_kernel.h</td> <td>提供了一维平滑样条的积分核心计算服务</td> </tr> <tr> <td>spline_1d_constraint.h</td> <td>提供了一维平滑样条的约束条件</td> </tr> <tr> <td>spline_1d.h</td> <td>提供了一维样条曲线优化和计算服务</td> </tr> <tr> <td>spline_1d_seg.h</td> <td>提供了一维平滑样条的相关计算服务</td> </tr> </tbody> </table> <p>整体功能概括：这个项目是一个高级的自动驾驶路径规划和优化系统，使用了样条插值、最优化技术、一维和二维空间的约束条件等方法，可以被自动驾驶汽车用于寻找和生成理想的驾驶路线。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_base/math/smoothing_spline/spline_2d_kernel.h, ./planning_base/math/smoothing_spline/spline_2d_seg.h, ./planning_base/math/smoothing_spline/spline_2d_solver.h, ./planning_base/math/smoothing_spline/spline_1d_solver.h, ./planning_base/reference_line/qp_spline_reference_line_smoother.h, ./planning_base/reference_line/reference_line_provider.h, ./planning_base/reference_line/discrete_points_reference_line_smoother.h, ./planning_base/reference_line/reference_line.h, ./planning_base/reference_line/reference_line_smoother.h, ./planning_base/reference_line/spiral_reference_line_smoother.h, ./planning_base/reference_line/reference_point.h, ./planning_base/reference_line/spiral_problem_interface.h, ./planning_component/on_lane_planning.h, ./planning_component/navi_planning.h, ./planning_component/planning_base.h, ./planning_component/planning_component.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>spline_2d_kernel.h</td> <td>提供生成二次样条曲线参数</td> </tr> <tr> <td>spline_2d_seg.h</td> <td>实现2D样条分段</td> </tr> <tr> <td>spline_2d_solver.h</td> <td>解决二维平滑样条插值问题</td> </tr> <tr> <td>spline_1d_solver.h</td> <td>解决1维平滑样条问题</td> </tr> <tr> <td>qp_spline_reference_line_smoother.h</td> <td>平滑参考线</td> </tr> <tr> <td>reference_line_provider.h</td> <td>提供参考线</td> </tr> <tr> <td>discrete_points_reference_line_smoother.h</td> <td>平滑离散点参考线</td> </tr> <tr> <td>reference_line.h</td> <td>提供对参考线的操作</td> </tr> <tr> <td>reference_line_smoother.h</td> <td>平滑参考线</td> </tr> <tr> <td>spiral_reference_line_smoother.h</td> <td>平滑螺旋参考线</td> </tr> <tr> <td>reference_point.h</td> <td>描述路径的参考点</td> </tr> <tr> <td>spiral_problem_interface.h</td> <td>处理螺旋形参考线问题</td> </tr> <tr> <td>on_lane_planning.h</td> <td>提供车道内规划</td> </tr> <tr> <td>navi_planning.h</td> <td>提供导航规划</td> </tr> <tr> <td>planning_base.h</td> <td>提供规划模块的基础类</td> </tr> <tr> <td>planning_component.h</td> <td>实现规划组件</td> </tr> </tbody> </table> <p>以上的源代码构成了一个自动驾驶系统的规划模块，其功能是在给定环境约束的前提下，生成车辆的优化路径和速度的决策。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_component/integration_tests/planning_test_base.h, ./planning_interface_base/planner_base/planner.h, ./planning_interface_base/scenario_base/base_stage_creep.h, ./planning_interface_base/scenario_base/base_stage_cruise.h, ./planning_interface_base/scenario_base/process_result.h, ./planning_interface_base/scenario_base/scenario.h, ./planning_interface_base/scenario_base/stage.h, ./planning_interface_base/scenario_base/traffic_light_base/base_stage_traffic_light_creep.h, ./planning_interface_base/scenario_base/traffic_light_base/base_stage_traffic_light_cruise.h, ./planning_interface_base/task_base/task.h, ./planning_interface_base/task_base/trajectory_fallback_task.h, ./planning_interface_base/task_base/common/decider.h, ./planning_interface_base/task_base/common/path_generation.h, ./planning_interface_base/task_base/common/speed_optimizer.h, ./planning_interface_base/task_base/common/trajectory_optimizer.h, ./planning_interface_base/task_base/common/lane_change_util/lane_change_util.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件路径</th> <th>功能描述</th> </tr> </thead> <tbody> <tr> <td>./planning_component/integration_tests/planning_test_base.h</td> <td>定义了进行规划模块的测试的基类</td> </tr> <tr> <td>./planning_interface_base/planner_base/planner.h</td> <td>定义了所有具体规划器的基类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/base_stage_creep.h</td> <td>定义了车辆的蠕动阶段的基类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/base_stage_cruise.h</td> <td>定义了驾驶规划的巡航阶段的基类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/process_result.h</td> <td>定义了Stage和Scenario执行结果的类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/scenario.h</td> <td>对自动驾驶的不同场景进行封装和管理</td> </tr> <tr> <td>./planning_interface_base/scenario_base/stage.h</td> <td>定义了作为不同的规划阶段的基类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/traffic_light_base/base_stage_traffic_light_creep.h</td> <td>处理交通灯和车辆缓慢驶过交通灯场景的类</td> </tr> <tr> <td>./planning_interface_base/scenario_base/traffic_light_base/base_stage_traffic_light_cruise.h</td> <td>处理进入交通灯交叉口后的巡航阶段的类</td> </tr> <tr> <td>./planning_interface_base/task_base/task.h</td> <td>定义了执行任务的基类</td> </tr> <tr> <td>./planning_interface_base/task_base/trajectory_fallback_task.h</td> <td>处理无法生成预期驾驶轨迹时，生成退回的轨迹的任务</td> </tr> <tr> <td>./planning_interface_base/task_base/common/decider.h</td> <td>处理各类决策任务的类</td> </tr> <tr> <td>./planning_interface_base/task_base/common/path_generation.h</td> <td>处理路径生成的类</td> </tr> <tr> <td>./planning_interface_base/task_base/common/speed_optimizer.h</td> <td>处理速度优化任务的类</td> </tr> <tr> <td>./planning_interface_base/task_base/common/trajectory_optimizer.h</td> <td>处理轨迹优化任务的类</td> </tr> <tr> <td>./planning_interface_base/task_base/common/lane_change_util/lane_change_util.h</td> <td>提供一组与车道改变相关的工具函数</td> </tr> </tbody> </table> <p>根据以上信息，可以概括该程序的整体功能是：实现了一个自动驾驶系统的路径规划和优化模块，包括多种场景和任务的处理，如交通灯识别、车速优化、车道切换及退回轨迹等。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_interface_base/task_base/common/path_util/path_assessment_decider_util.h, ./planning_interface_base/task_base/common/path_util/path_bounds_decider_util.h, ./planning_interface_base/task_base/common/path_util/path_optimizer_util.h, ./planning_interface_base/task_base/optimizers/road_graph/comparable_cost.h, ./planning_interface_base/task_base/optimizers/road_graph/dp_road_graph.h, ./planning_interface_base/task_base/optimizers/road_graph/trajectory_cost.h, ./planning_interface_base/task_base/optimizers/road_graph/waypoint_sampler.h, ./planning_interface_base/task_base/utils/st_gap_estimator.h, ./planning_interface_base/traffic_rules_base/traffic_decider.h, ./planning_interface_base/traffic_rules_base/traffic_rule.h, ./planning_open_space/coarse_trajectory_generator/grid_search.h, ./planning_open_space/coarse_trajectory_generator/hybrid_a_star.h, ./planning_open_space/coarse_trajectory_generator/node3d.h, ./planning_open_space/coarse_trajectory_generator/reeds_shepp_path.h, ./planning_open_space/trajectory_smoother/distance_approach_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_ipopt_cuda_interface.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>path_assessment_decider_util.h</td> <td>评估和决定自动驾驶车辆的规划路径的效用性。</td> </tr> <tr> <td>path_bounds_decider_util.h</td> <td>决定自动驾驶车辆在给定环境中的道路边界。</td> </tr> <tr> <td>path_optimizer_util.h</td> <td>提供路径规划的优化操作所需的工具方法。</td> </tr> <tr> <td>comparable_cost.h</td> <td>比较和规划路径中的各方案的成本。</td> </tr> <tr> <td>dp_road_graph.h</td> <td>动态规划的路网图模型，用于路径规划和决策。</td> </tr> <tr> <td>trajectory_cost.h</td> <td>计算车辆行驶轨迹的代价。</td> </tr> <tr> <td>waypoint_sampler.h</td> <td>在给定的地图或路线上采样路径上的点。</td> </tr> <tr> <td>st_gap_estimator.h</td> <td>估算障碍物和自动驾驶车辆之间的距离。</td> </tr> <tr> <td>traffic_decider.h</td> <td>生成和处理与交通有关的决定。</td> </tr> <tr> <td>traffic_rule.h</td> <td>提供一个处理交通规则的基础框架。</td> </tr> <tr> <td>grid_search.h</td> <td>在开放空间中找寻最优路径。</td> </tr> <tr> <td>hybrid_a_star.h</td> <td>实现混合A*搜索算法，找寻开放空间中的最优路径</td> </tr> <tr> <td>node3d.h</td> <td>用于存储在开放空间路径规划中使用的三维节点。</td> </tr> <tr> <td>reeds_shepp_path.h</td> <td>使用Reeds-Shepp曲线来规划车辆在给定的空间中的路径。</td> </tr> <tr> <td>distance_approach_interface.h</td> <td>多目标优化接口类，被用于大型优化问题的开源库Ipopt中</td> </tr> <tr> <td>distance_approach_ipopt_cuda_interface.h</td> <td>使用IPOPT (内点优化库) 和 CUDA (并行计算库)来处理某种&quot;距离法&quot;。</td> </tr> </tbody> </table> <p>整体功能：该项目是一个自动驾驶系统的源代码，主要功能是对不同的道路场景进行驾驶任务的处理和优化以生成安全、平滑、优化的驾驶轨迹，包括路线规划，轨迹代价计算，交通规则决策以及对应的优化操作等。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./planning_open_space/trajectory_smoother/distance_approach_ipopt_fixed_dual_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_ipopt_fixed_ts_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_ipopt_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_ipopt_relax_end_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_ipopt_relax_end_slack_interface.h, ./planning_open_space/trajectory_smoother/distance_approach_problem.h, ./planning_open_space/trajectory_smoother/dual_variable_warm_start_ipopt_interface.h, ./planning_open_space/trajectory_smoother/dual_variable_warm_start_ipopt_qp_interface.h, ./planning_open_space/trajectory_smoother/dual_variable_warm_start_osqp_interface.h, ./planning_open_space/trajectory_smoother/dual_variable_warm_start_problem.h, ./planning_open_space/trajectory_smoother/dual_variable_warm_start_slack_osqp_interface.h, ./planning_open_space/trajectory_smoother/iterative_anchoring_smoother.h, ./planning_open_space/trajectory_smoother/planning_block.h, ./planning_open_space/utils/open_space_roi_util.h, ./planning_open_space/utils/open_space_trajectory_optimizer_util.h, ./pnc_map/lane_follow_map/lane_follow_map.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td><code>distance_approach_ipopt_fixed_dual_interface.h</code></td> <td>实现基于IPOPT的固定双接口距离方法平滑轨迹</td> </tr> <tr> <td><code>distance_approach_ipopt_fixed_ts_interface.h</code></td> <td>实现基于IPOPT的固定时间步的距离方法平滑轨迹</td> </tr> <tr> <td><code>distance_approach_ipopt_interface.h</code></td> <td>提供基于IPOPT的距离法接口</td> </tr> <tr> <td><code>distance_approach_ipopt_relax_end_interface.h</code></td> <td>处理轨迹的尾端部分，使用IPOPT实现轨迹近似的轨迹平滑</td> </tr> <tr> <td><code>distance_approach_ipopt_relax_end_slack_interface.h</code></td> <td>实现具有滑动末端的IPOPT距离法平滑轨迹</td> </tr> <tr> <td><code>distance_approach_problem.h</code></td> <td>实现用于求解距离逼近问题的类</td> </tr> <tr> <td><code>dual_variable_warm_start_ipopt_interface.h</code></td> <td>定义用于优化轨迹的类</td> </tr> <tr> <td><code>dual_variable_warm_start_ipopt_qp_interface.h</code></td> <td>用于处理开放空间路径拟合以及实现最初的变量热启动</td> </tr> <tr> <td><code>dual_variable_warm_start_osqp_interface.h</code></td> <td>利用OSQP求解软件包优化轨迹平滑问题</td> </tr> <tr> <td><code>dual_variable_warm_start_problem.h</code></td> <td>实现处理轨迹的初始问题</td> </tr> <tr> <td><code>dual_variable_warm_start_slack_osqp_interface.h</code></td> <td>处理带有懈怠的问题的双变量热启动的OSQP接口</td> </tr> <tr> <td><code>iterative_anchoring_smoother.h</code></td> <td>定义迭代锚定平滑器用于生成终端位置和方向</td> </tr> <tr> <td><code>planning_block.h</code></td> <td>在NVIDIA和AMD两种GPU环境中处理兼容性问题</td> </tr> <tr> <td><code>open_space_roi_util.h</code></td> <td>定义和处理ROI</td> </tr> <tr> <td><code>open_space_trajectory_optimizer_util.h</code></td> <td>提供优化函数用于开放空间的路径规划</td> </tr> <tr> <td><code>lane_follow_map.h</code></td> <td>处理路径跟踪的地图问题</td> </tr> </tbody> </table> <p>整个程序的整体功能是: 处理自动驾驶系统中的路径规划问题，包括对开放空间的控制、路径的平滑处理、以及对路径的优化规划等，以生成一个对自动驾驶车辆友好、符合交通规则、安全有效的行驶路径。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./scenarios/bare_intersection_unprotected/stage_intersection_cruise.h, ./scenarios/bare_intersection_unprotected/stage_approach.h, ./scenarios/bare_intersection_unprotected/bare_intersection_unprotected_scenario.h, ./scenarios/emergency_pull_over/emergency_pull_over_scenario.h, ./scenarios/emergency_pull_over/stage_approach.h, ./scenarios/emergency_pull_over/stage_slow_down.h, ./scenarios/emergency_pull_over/stage_standby.h, ./scenarios/emergency_stop/emergency_stop_scenario.h, ./scenarios/emergency_stop/stage_approach.h, ./scenarios/emergency_stop/stage_standby.h, ./scenarios/lane_follow/lane_follow_scenario.h, ./scenarios/lane_follow/lane_follow_stage.h, ./scenarios/park_and_go/stage_adjust.h, ./scenarios/park_and_go/stage_cruise.h, ./scenarios/park_and_go/util.h, ./scenarios/park_and_go/stage_check.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名称</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>stage_intersection_cruise.h</td> <td>处理裸露交叉口场景中的行驶阶段</td> </tr> <tr> <td>stage_approach.h</td> <td>处理裸露交叉口场景中的驶近阶段</td> </tr> <tr> <td>bare_intersection_unprotected_scenario.h</td> <td>处理涉及非保护(无交通灯或路标)裸露交叉口的场景</td> </tr> <tr> <td>emergency_pull_over_scenario.h</td> <td>定义应急停车场景</td> </tr> <tr> <td>stage_approach.h (emergency pull over)</td> <td>维护并处理紧急停车场景的驶近阶段</td> </tr> <tr> <td>stage_slow_down.h</td> <td>处理紧急停车场景的慢行阶段</td> </tr> <tr> <td>stage_standby.h(emergency pull over)</td> <td>处理紧急停车场景的待命阶段</td> </tr> <tr> <td>emergency_stop_scenario.h</td> <td>处理紧急停止情景</td> </tr> <tr> <td>stage_approach.h(emergency stop)</td> <td>处理紧急停止情景的驶近阶段</td> </tr> <tr> <td>stage_standby.h(emergency stop)</td> <td>处理紧急停止情景的待命阶段</td> </tr> <tr> <td>lane_follow_scenario.h</td> <td>处理车道跟随场景</td> </tr> <tr> <td>lane_follow_stage.h</td> <td>负责车道保持阶段</td> </tr> <tr> <td>stage_adjust.h</td> <td>处理停车并前进场景的调整阶段</td> </tr> <tr> <td>stage_cruise.h</td> <td>处理停车并前进场景的巡航阶段</td> </tr> <tr> <td>util.h (park and go)</td> <td>提供一组实用程序函数，以检查周围障碍物，ADC的方向和位置等</td> </tr> <tr> <td>stage_check.h</td> <td>处理停车并行驶场景的检查阶段</td> </tr> </tbody> </table> <p>总结：整个程序的主要功能是为自动驾驶车辆进行路径规划，包括处理各种道路场景如非保护的交叉口、紧急停车和停车起步等，以生成安全有效的行驶路径。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./scenarios/park_and_go/stage_pre_cruise.h, ./scenarios/park_and_go/context.h, ./scenarios/park_and_go/park_and_go_scenario.h, ./scenarios/pull_over/context.h, ./scenarios/pull_over/pull_over_scenario.h, ./scenarios/pull_over/stage_approach.h, ./scenarios/pull_over/stage_retry_approach_parking.h, ./scenarios/pull_over/stage_retry_parking.h, ./scenarios/pull_over/util.h, ./scenarios/stop_sign_unprotected/context.h, ./scenarios/stop_sign_unprotected/stage_creep.h, ./scenarios/stop_sign_unprotected/stage_intersection_cruise.h, ./scenarios/stop_sign_unprotected/stage_pre_stop.h, ./scenarios/stop_sign_unprotected/stage_stop.h, ./scenarios/stop_sign_unprotected/stop_sign_unprotected_scenario.h, ./scenarios/traffic_light_protected/stage_intersection_cruise.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>stage_pre_cruise.h (ParkAndGo)</td> <td>处理停车并启动过程中的“预充电”阶段</td> </tr> <tr> <td>context.h (ParkAndGo)</td> <td>存储和处理停车并启动过程中的相关上下文信息</td> </tr> <tr> <td>park_and_go_scenario.h (ParkAndGo)</td> <td>处理停车并启动的主场景</td> </tr> <tr> <td>context.h (PullOver)</td> <td>存储和处理拉倒过程中的相关上下文信息</td> </tr> <tr> <td>pull_over_scenario.h (PullOver)</td> <td>处理拉倒的主场景</td> </tr> <tr> <td>stage_approach.h (PullOver)</td> <td>处理拉倒过程中的“接近”阶段</td> </tr> <tr> <td>stage_retry_approach_parking.h (PullOver)</td> <td>处理拉倒过程中的“重试停车”阶段</td> </tr> <tr> <td>stage_retry_parking.h (PullOver)</td> <td>处理拉倒过程中的“重试停车”阶段</td> </tr> <tr> <td>util.h (PullOver)</td> <td>提供拉倒过程中的辅助函数和类</td> </tr> <tr> <td>context.h (StopSignUnprotected)</td> <td>存储和处理非保护停车标志主场景的上下文信息</td> </tr> <tr> <td>stage_creep.h (StopSignUnprotected)</td> <td>处理非保护停车标志主场景中的“潜行”阶段</td> </tr> <tr> <td>stage_intersection_cruise.h (StopSignUnprotected)</td> <td>处理非保护停车标志主场景中的交叉口巡航阶段</td> </tr> <tr> <td>stage_pre_stop.h (StopSignUnprotected)</td> <td>处理非保护停车标志主场景中的“预停”阶段</td> </tr> <tr> <td>stage_stop.h (StopSignUnprotected)</td> <td>处理非保护停车标志主场景中的“停止”阶段</td> </tr> <tr> <td>stop_sign_unprotected_scenario.h (StopSignUnprotected</td> <td>整体处理非保护停车标志主场景</td> </tr> <tr> <td>stage_intersection_cruise.h (TrafficLightProtected)</td> <td>处理有交通信号灯保护的交叉口巡航阶段</td> </tr> </tbody> </table> <p>根据以上分析，这个程序的整体功能是支持自动驾驶系统处理各种复杂的驾驶场景，包括但不限于停车并启动、拉倒、无保护的停车标志和交通信号灯保护。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./scenarios/traffic_light_protected/stage_approach.h, ./scenarios/traffic_light_protected/traffic_light_protected_scenario.h, ./scenarios/traffic_light_protected/context.h, ./scenarios/traffic_light_unprotected_left_turn/context.h, ./scenarios/traffic_light_unprotected_left_turn/stage_approach.h, ./scenarios/traffic_light_unprotected_left_turn/stage_creep.h, ./scenarios/traffic_light_unprotected_left_turn/stage_intersection_cruise.h, ./scenarios/traffic_light_unprotected_left_turn/traffic_light_unprotected_left_turn_scenario.h, ./scenarios/traffic_light_unprotected_right_turn/context.h, ./scenarios/traffic_light_unprotected_right_turn/stage_creep.h, ./scenarios/traffic_light_unprotected_right_turn/stage_intersection_cruise.h, ./scenarios/traffic_light_unprotected_right_turn/stage_stop.h, ./scenarios/traffic_light_unprotected_right_turn/traffic_light_unprotected_right_turn_scenario.h, ./scenarios/valet_parking/stage_approaching_parking_spot.h, ./scenarios/valet_parking/stage_parking.h, ./scenarios/valet_parking/valet_parking_scenario.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>stage_approach.h</td> <td>处理保护交通灯阶段的驾驶情景</td> </tr> <tr> <td>traffic_light_protected_scenario.h</td> <td>管理交通灯保护场景</td> </tr> <tr> <td>context.h</td> <td>提供受交通灯保护的场景上下文信息</td> </tr> <tr> <td>context.h (unprotected_left_turn)</td> <td>提供未受交通灯保护的左转场景上下文信息</td> </tr> <tr> <td>stage_approach.h (unprotected_left_turn)</td> <td>处理未受交通灯保护的左转场景</td> </tr> <tr> <td>stage_creep.h</td> <td>处理未受交通灯保护的左转阶段的行为</td> </tr> <tr> <td>stage_intersection_cruise.h</td> <td>处理未受交通灯保护的右转驶过交叉口阶段的行为</td> </tr> <tr> <td>traffic_light_unprotected_left_turn_scenario.h</td> <td>管理交通灯未保护左转场景</td> </tr> <tr> <td>context.h (unprotected_right_turn)</td> <td>提供未受交通灯保护的右转场景上下文信息</td> </tr> <tr> <td>stage_creep.h (unprotected_right_turn)</td> <td>处理非保护右转红绿灯阶段的行为</td> </tr> <tr> <td>stage_intersection_cruise.h (unprotected_right_turn)</td> <td>处理非保护右转红绿灯过交叉口阶段的行为</td> </tr> <tr> <td>stage_stop.h</td> <td>处理未受交通灯保护的右转停车阶段的行为</td> </tr> <tr> <td>traffic_light_unprotected_right_turn_scenario.h</td> <td>管理交通灯未保护右转场景</td> </tr> <tr> <td>stage_approaching_parking_spot.h</td> <td>处理代客泊车阶段的行为</td> </tr> <tr> <td>stage_parking.h</td> <td>处理代客泊车停车阶段的行为</td> </tr> <tr> <td>valet_parking_scenario.h</td> <td>管理代客泊车场景</td> </tr> </tbody> </table> <p>概括：这套程序的整体功能是让自动驾驶系统能够在各种交通场景下，包括受保护和未保护的交通灯情况以及代客泊车情况，进行正确的行驶和泊车操作。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./scenarios/yield_sign/stage_approach.h, ./scenarios/yield_sign/stage_creep.h, ./scenarios/yield_sign/yield_sign_scenario.h, ./tasks/fallback_path/fallback_path.h, ./tasks/lane_borrow_path/lane_borrow_path.h, ./tasks/lane_change_path/lane_change_path.h, ./tasks/lane_follow_path/lane_follow_path.h, ./tasks/open_space_fallback_decider/open_space_fallback_decider.h, ./tasks/open_space_pre_stop_decider/open_space_pre_stop_decider.h, ./tasks/open_space_roi_decider/open_space_roi_decider.h, ./tasks/open_space_trajectory_partition/open_space_trajectory_partition.h, ./tasks/open_space_trajectory_provider/open_space_trajectory_optimizer.h, ./tasks/open_space_trajectory_provider/open_space_trajectory_provider.h, ./tasks/path_decider/path_decider.h, ./tasks/path_reference_decider/path_reference_decider.h, ./tasks/path_time_heuristic/dp_st_cost.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>stage_approach.h</td> <td>处理&quot;模拟让步标志&quot;情境中的接近阶段</td> </tr> <tr> <td>stage_creep.h</td> <td>处理&quot;模拟让步&quot;场景中的Creep阶段</td> </tr> <tr> <td>yield_sign_scenario.h</td> <td>处理与让行标志相关的驾驶场景</td> </tr> <tr> <td>fallback_path.h</td> <td>为应急情况下生成候选路径</td> </tr> <tr> <td>lane_borrow_path.h</td> <td>规划辅助道路路径</td> </tr> <tr> <td>lane_change_path.h</td> <td>处理车道变换路径</td> </tr> <tr> <td>lane_follow_path.h</td> <td>处理车道跟随路径</td> </tr> <tr> <td>open_space_fallback_decider.h</td> <td>处理开放空间环境下的回退决策</td> </tr> <tr> <td>open_space_pre_stop_decider.h</td> <td>处理开放空间环境下的预停止决策</td> </tr> <tr> <td>open_space_roi_decider.h</td> <td>生成开放空间的感兴趣区域</td> </tr> <tr> <td>open_space_trajectory_partition.h</td> <td>在开放空间中处理轨迹的划分</td> </tr> <tr> <td>open_space_trajectory_optimizer.h</td> <td>优化开放空间轨道</td> </tr> <tr> <td>open_space_trajectory_provider.h</td> <td>提供开放空间中车辆的轨迹</td> </tr> <tr> <td>path_decider.h</td> <td>决定自驾车的路线</td> </tr> <tr> <td>path_reference_decider.h</td> <td>为车辆导航提供路径决策</td> </tr> <tr> <td>dp_st_cost.h</td> <td>计算速度优化的成本</td> </tr> </tbody> </table> <p>整体来看，这些源代码共同构成了一个全面的自动驾驶规划系统，处理从基本的车道跟随，到高级的开放空间轨迹优化和决策等各种驾驶任务的规划，以实现自动驾驶车辆在各种路况和环境下的安全、高效驾驶。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./tasks/path_time_heuristic/gridded_path_time_graph.h, ./tasks/path_time_heuristic/path_time_heuristic_optimizer.h, ./tasks/path_time_heuristic/st_graph_point.h, ./tasks/piecewise_jerk_speed/piecewise_jerk_speed_optimizer.h, ./tasks/piecewise_jerk_speed_nonlinear/piecewise_jerk_speed_nonlinear_ipopt_interface.h, ./tasks/piecewise_jerk_speed_nonlinear/piecewise_jerk_speed_nonlinear_optimizer.h, ./tasks/pull_over_path/pull_over_path.h, ./tasks/reuse_path/reuse_path.h, ./tasks/rss_decider/rss_decider.h, ./tasks/rule_based_stop_decider/rule_based_stop_decider.h, ./tasks/speed_bounds_decider/speed_bounds_decider.h, ./tasks/speed_bounds_decider/speed_limit_decider.h, ./tasks/speed_bounds_decider/st_boundary_mapper.h, ./tasks/speed_decider/speed_decider.h, ./tasks/st_bounds_decider/st_bounds_decider.h, ./tasks/st_bounds_decider/st_driving_limits.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>gridded_path_time_graph.h</td> <td>通过管理时间和路径规划来指导车辆运动</td> </tr> <tr> <td>path_time_heuristic_optimizer.h</td> <td>用于ST图的速度规划，使用动态编程优化路径时间</td> </tr> <tr> <td>st_graph_point.h</td> <td>定义ST图的单个点，用于路径时间规划</td> </tr> <tr> <td>piecewise_jerk_speed_optimizer.h</td> <td>执行速度优化任务，用于生成车辆速度曲线</td> </tr> <tr> <td>piecewise_jerk_speed_nonlinear_ipopt_interface.h</td> <td>使用非线性方程优化速度曲线，提供到牛顿型点优化程序Ipopt的接口</td> </tr> <tr> <td>piecewise_jerk_speed_nonlinear_optimizer.h</td> <td>使用非线性方程优化速度，对速度曲线进行微调</td> </tr> <tr> <td>pull_over_path.h</td> <td>为车辆停靠操作制定路径</td> </tr> <tr> <td>reuse_path.h</td> <td>决定是否可以重用之前生成的路径</td> </tr> <tr> <td>rss_decider.h</td> <td>处理RSS（稳定驾驶模型）决策逻辑，包括检查障碍是否太近或者速度太快</td> </tr> <tr> <td>rule_based_stop_decider.h</td> <td>基于规则的停车决策逻辑，当满足特定停车要求时控制车辆停止</td> </tr> <tr> <td>speed_bounds_decider.h</td> <td>根据各种因素（如车辆位置，障碍物等）决定速度边界</td> </tr> <tr> <td>speed_limit_decider.h</td> <td>决定车辆的速度限制</td> </tr> <tr> <td>st_boundary_mapper.h</td> <td>将实际的障碍物和车辆决策映射到ST边界</td> </tr> <tr> <td>speed_decider.h</td> <td>决定车辆的速度，执行速度决策任务</td> </tr> <tr> <td>st_bounds_decider.h</td> <td>决定速度和时间的边界，用于安全的路径规划</td> </tr> <tr> <td>st_driving_limits.h</td> <td>决定了汽车的动态限制，如最大速度、最大加速和最大减速</td> </tr> </tbody> </table> <p>项目整体功能：该项目是一个完整的自动驾驶车辆道路规划和决策系统，包括路径时间优化、速度规划、驾驶限制决策、模式重用、停车策略、安全决策等各个方面。</p> <h2>用一张Markdown表格简要描述以下文件的功能：./tasks/st_bounds_decider/st_guide_line.h, ./tasks/st_bounds_decider/st_obstacles_processor.h, ./traffic_rules/backside_vehicle/backside_vehicle.h, ./traffic_rules/crosswalk/crosswalk.h, ./traffic_rules/destination/destination.h, ./traffic_rules/keepclear/keep_clear.h, ./traffic_rules/reference_line_end/reference_line_end.h, ./traffic_rules/rerouting/rerouting.h, ./traffic_rules/stop_sign/stop_sign.h, ./traffic_rules/traffic_light/traffic_light.h, ./traffic_rules/yield_sign/yield_sign.h。根据以上分析，用一句话概括程序的整体功能</h2> <table> <thead> <tr> <th>文件名</th> <th>功能</th> </tr> </thead> <tbody> <tr> <td>st_guide_line.h</td> <td>处理导向线信息的核心类，包括车辆期望速度、轨迹点和堵塞信息等参数。</td> </tr> <tr> <td>st_obstacles_processor.h</td> <td>处理和管理在s-t(距离-时间)图中的障碍</td> </tr> <tr> <td>backside_vehicle.h</td> <td>处理与后方车辆相关的规则，例如车道保持策略</td> </tr> <tr> <td>crosswalk.h</td> <td>处理交通规则中的人行横道功能</td> </tr> <tr> <td>destination.h</td> <td>决定是否应该在目的地停车</td> </tr> <tr> <td>keep_clear.h</td> <td>为每一个清晰区域创建一个虚拟障碍</td> </tr> <tr> <td>reference_line_end.h</td> <td>基于交通状况决定是否发送重路由请求</td> </tr> <tr> <td>rerouting.h</td> <td>基于交通状况决定是否应该发送重新路由请求</td> </tr> <tr> <td>stop_sign.h</td> <td>处理与路口停车标志有关的交通规则。</td> </tr> <tr> <td>traffic_light.h</td> <td>处理交通灯规则</td> </tr> <tr> <td>yield_sign.h</td> <td>处理让行标志相关的规则</td> </tr> </tbody> </table> <p>概括程序整体功能：这些文件均是Apollo无人驾驶系统的一部分，共同负责车辆在各种交通场景(包括交通灯、人行道、让行标志、停车标志等)下的驾驶行为决策，以及处理路径和速度规划，障碍物规避等问题。</p>",
    "publishDate": "2024-05-06T13:29:56.000Z",
    "modifiedDate": "2024-09-15T12:35:59.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 5,
        "name": "项目",
        "slug": "project",
        "count": 3
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 470,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374.jpg",
      "alt": "",
      "title": "index-banner-v2",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374-300x168.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"168\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374-300x168.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374-300x168.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-1024x288.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2024/05/index-banner-v2-scaled-e1726403715374.jpg"
      },
      "width": 989,
      "height": 554,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "closed",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2024/05/baidu-apollo/",
    "wordCount": 5454,
    "readingTime": 28,
    "seo": {
      "title": "百度 Apollo 自动驾驶平台译解报告",
      "description": "<p>GPT-Academic Report planners lattice lattice_planner.h [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2024/05/baidu-apollo/"
    }
  },
  {
    "id": "402",
    "title": "免费Github加速反向代理",
    "slug": "github_proxy",
    "excerpt": "<p>节点 github.com/ -&gt; github.sakurapuare.com/ api.github [&hellip;]</p>",
    "content": "<h2>节点</h2> <ul> <li>github.com/ -&gt; <a href=\"https://github.sakurapuare.com\" title=\"github.sakurapuare.com\">github.sakurapuare.com/</a></li> <li>api.github.com/ -&gt; <a href=\"https://github-api.sakurapuare.com\" title=\"github-api.sakurapuare.com\">github-api.sakurapuare.com/</a></li> <li>*.githubusercontent.com -&gt; <a href=\"https://github-usercontent.sakurapuare.com/\" title=\"github-usercontent.sakurapuare.com/\\*/\">github-usercontent.sakurapuare.com/*/</a></li> <li>*.githubassets.com -&gt; <a href=\"https://github-assets.sakurapuare.com\" title=\"github-assets.sakurapuare.com/\\*/\">github-assets.sakurapuare.com/*/</a></li> </ul> <h2>使用方法</h2> <p>对于没有通配符的网站，直接访问即可。</p> <p>对于有通配符的网站，需要将三级域名添加到路径后访问。</p> <pre><code class=\"language-text\">https://raw.githubusercontent.com/SakuraPuare/Workers_Github_Reverse_Proxy/master/README.md</code></pre> <p>如上，此网址的三级域名为<code>raw</code>，则需要将其添加到路径中：</p> <pre><code class=\"language-text\">https://github-usercontent.sakurapuare.com/raw/SakuraPuare/Workers_Github_Reverse_Proxy/master/README.md</code></pre> <p>即可访问</p> <h2>参考</h2> <div class='github-info-card github-info-card-full card shadow-sm' data-author='SakuraPuare' data-project='Workers_Github_Reverse_Proxy' githubinfo-card-id='5265999051' data-getdata='frontend' data-description='' data-stars='' data-forks=''><div class='github-info-card-header'><a href='https://github.com/' ref='nofollow' target='_blank' title='Github' no-pjax><span><i class='fa fa-github'></i> GitHub</span></a></div><div class='github-info-card-body'> <div class='github-info-card-name-a'> <a href='https://github.com/SakuraPuare/Workers_Github_Reverse_Proxy' target='_blank' no-pjax> <span class='github-info-card-name'>SakuraPuare/Workers_Github_Reverse_Proxy</span> </a> </div> <div class='github-info-card-description'></div> </div><div class='github-info-card-bottom'> <span class='github-info-card-meta github-info-card-meta-stars'> <i class='fa fa-star'></i> <span class='github-info-card-stars'></span> </span> <span class='github-info-card-meta github-info-card-meta-forks'> <i class='fa fa-code-fork'></i> <span class='github-info-card-forks'></span> </span> </div></div> <p><strong><a href=\"https://blog.sakurapuare.com/archives/2023/03/cloudflare_worker_based_github_reverse_proxy\">基于Cloudflare Workers的Github反向代理【JavaScript】</a></strong></p>",
    "publishDate": "2023-06-03T16:00:00.000Z",
    "modifiedDate": "2023-08-06T03:55:22.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 8,
        "name": "资源",
        "slug": "resource",
        "count": 2
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 414,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-e1706177497515.png",
      "alt": "",
      "title": "what-is-github-1-1",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-e1706177497515.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-300x150.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"150\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-300x150.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-300x150.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-1024x512.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2023/06/what-is-github-1-1-e1706177497515.png"
      },
      "width": 778,
      "height": 389,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2023/06/github_proxy/",
    "wordCount": 91,
    "readingTime": 1,
    "seo": {
      "title": "免费Github加速反向代理",
      "description": "<p>节点 github.com/ -&gt; github.sakurapuare.com/ api.github [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2023/06/github_proxy/"
    }
  },
  {
    "id": "249",
    "title": "最是书香能润心【杂谈】",
    "slug": "reading-books",
    "excerpt": "<p>书香与成长相伴相随，相得益彰，相映生辉。 习近平总书记热爱读书，认为读书“能够让思想保持活力，能够让智慧得到启 [&hellip;]</p>",
    "content": "<p>书香与成长相伴相随，相得益彰，相映生辉。</p> <p>习近平总书记热爱读书，认为读书“能够让思想保持活力，能够让智慧得到启迪，能够让人格升华”。作为知识的传递者，书籍也是人类历史和创造的延续，蕴含着无穷的潜力。书山里，有比眼前更精彩的风光。阅读一本好书，如同与一位智者交流：顺境时，给你警醒；困惑时，给你希望；挫折时，给你信心；追梦时，给你力量。以书籍为指引，人们不断探索、拓展生活的色彩。因为阅读，许多人超越平庸，积累了向上的力量。</p> <p>书香是一种气质，是一种修养，是一种境界。</p> <p>人生因阅读而博大精深。朱熹有言：“为学之道，莫先于穷理；穷理之要，必先于读书。”历史上留存下来的经典，往往承载着人类最基本的思想观念和价值取向，蕴含着丰厚的人生哲理和人文内涵，对于启迪智慧、陶冶情操、塑造品德、净化心灵等大有裨益。正因如此，养成读书的习惯，坚持阅读经典、品味好书，好似在心中长燃一盏明灯，能指引人们感悟人生、贴近真理、豁然开朗，找到属于自己的人生坐标。</p> <p>书香是一种力量，是一种魅力，是一种财富。</p> <p>人生因阅读而精彩纷呈。胸有诗书气自华，读书有益于拓宽视野、提高境界；惟有书香能致远，书海中深藏着炽热的理想信念、浓厚的家国情怀。翻阅《论语》《孟子》《礼记》等国学经典，领悟“修身齐家治国平天下”的博大精深；细览《史记》《资治通鉴》等古代典籍，获取“可以知兴替”的历史镜鉴；走进《红岩》《钢铁是怎样炼成的》等作品的文学情境，点燃拼搏奉献的生命烈火……书是桥梁，让人思贯千里；书是翅膀，让人心飞万仞。博览群书，沐浴书香，精神面貌也会透着文化的气息，闪耀不一样的气质。</p> <p>书香是一种乐趣，是一种情趣，是一种艺术。</p> <p>人生因阅读而灵动有趣。有人说过：“读书能给人带来快乐，能给人增添光彩，能给人锻炼才干。”书籍包含着丰富知识，展现着深刻哲理，是启迪智慧的泉源。拿起书，就拿起了希望；读好书，就能开阔眼界、提升智力。广泛阅读、深入阅读，是实现“学思用相通、知信行相统”的重要环节。对于广大党员、干部而言，热爱阅读，善于汲取书中精华，并将之转化为崇高的价值追求，才能始终坚定信仰、信念、信心，也才能不断提升干事创业的本领。</p> <p>书卷是我的故友，它们给了我无私的关怀和支持，它们给了我无穷的知识和力量，它们给了我无限的快乐和梦想。墨香是我的回忆，它们留下了我的足迹和印记，它们留下了我的心声和灵魂，它们留下了我的故事和传奇。</p> <p>书香与成长相伴相随，相得益彰，相映生辉。愿我们在阅读中汲取知识与智慧，在成长中体味书香的韵味与情趣。愿我们用书籍润泽我们的心灵花园，用书香照亮我们的人生航程。</p> <p><strong>&#8212; Generated by ChatGPT</strong></p>",
    "publishDate": "2023-04-10T04:00:54.000Z",
    "modifiedDate": "2023-07-25T19:00:41.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 322,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-scaled-e1706177526599.jpg",
      "alt": "",
      "title": "book",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-scaled-e1706177526599.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-300x169.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"169\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-300x169.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-300x169.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-1024x576.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2023/04/book-scaled-e1706177526599.jpg"
      },
      "width": 778,
      "height": 437,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2023/04/reading-books/",
    "wordCount": 14,
    "readingTime": 1,
    "seo": {
      "title": "最是书香能润心【杂谈】",
      "description": "<p>书香与成长相伴相随，相得益彰，相映生辉。 习近平总书记热爱读书，认为读书“能够让思想保持活力，能够让智慧得到启 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2023/04/reading-books/"
    }
  },
  {
    "id": "394",
    "title": "基于 Cloudflare Workers 的 Github 反向代理【JavaScript】",
    "slug": "cloudflare_worker_based_github_reverse_proxy",
    "excerpt": "<p>引言 作为全球最大的代码托管平台之一，GitHub [1]在开发者社区中具有重要地位。稳定且快速的访问对开发过 [&hellip;]</p>",
    "content": "<h2>引言</h2> <p>作为全球最大的代码托管平台之一，GitHub <a href=\"https://github.com/\" title=\"GitHub: Let&#039;s build from here · GitHub\">[1]</a>在开发者社区中具有重要地位。稳定且快速的访问对开发过程至关重要。然而，在中国境内，GitHub的响应速度和访问稳定性问题一直困扰着开发者，可能导致访问代码仓库时出现多种连接问题。</p> <p>通常，人们会采用网络代理服务（Network Proxy）<a href=\"https://en.wikipedia.org/wiki/Proxy_server\" title=\"Proxy server - Wikipedia\">[2]</a>或虚拟私人网络（VPN ）<a href=\"https://en.wikipedia.org/wiki/Virtual_private_network\" title=\"Virtual private network - Wikipedia\">[3]</a>来提高GitHub的连接速度。然而，由于多种原因，这些方法在某些情况下可能同样存在连接不稳定等问题。此外，国内的代码托管平台如Gitee <a href=\"https://gitee.com/\" title=\"Gitee - 企业级 DevOps 研发效能平台\">[4]</a>等也被视为GitHub的替代选择。然而，这些平台可能缺乏全球范围内的开发者社区和资源，或者因安全考虑实施了各种限制政策，导致相对于GitHub的吸引力稍显不足。</p> <p>在这一背景下，边缘计算技术 <a href=\"https://en.wikipedia.org/wiki/Edge_computing\" title=\"Edge computing - Wikipedia\">[5]</a>为解决这一问题提供了新的可能性。作为一种新兴的分布式计算范式，边缘计算旨在将计算和数据处理尽可能地靠近数据源、终端用户和物联网设备，以提高计算资源的响应速度、降低延迟，并减轻中心化数据中心的负担。通过在物理世界的“边缘”执行计算，边缘计算架构已在多个应用领域取得显著成就。<a href=\"https://blog.sakurapuare.com/archives/2022/12/a-review-of-technology-and-application-on-edge-computing/\" title=\"【文献检索】边缘计算技术及应用综述【杂谈】\">[6]</a></p> <p>Cloudflare作为全球领先的网络性能和安全公司，在全球范围内部署的边缘节点和强大的技术实力，为边缘计算的发展注入了新的动力。<a href=\"https://www.cloudflare.com/zh-cn/\" title=\"Cloudflare 中国官网 | 智能化云服务平台 | 免费CDN安全防护 | Cloudflare\">[7]</a></p> <h2>Cloudflare Workers</h2> <p>Cloudflare Workers充当边缘计算平台，为开发者提供了一个强大的工具，能够在遍布全球的边缘节点上执行代码，实现即时响应并降低延迟。这一过渡不仅填补了边缘计算在某些技术方面的不足，同时为开发者提供了更便捷和灵活的途径，以实现边缘计算的目标。此平台还提供了 Serverless 的执行环境，使您能够轻松创建新应用程序或扩展现有应用程序，而无需配置或维护基础设施。<a href=\"https://developers.cloudflare.com/workers/\" title=\"Cloudflare Workers · Cloudflare Workers docs\">[8]</a></p> <h3>什么是无服务器（Serverless）计算？</h3> <p>无服务器计算是一种按需提供后端服务的方法。无服务器提供者允许用户编写和部署代码，而不必担心底层基础设施。从无服务器提供商获得后端服务的公司将根据计算量来付费，由于这种服务是自动扩展的，不必预留和付费购买固定数量的带宽或服务器。请注意，虽然名为“无服务器”，实际上仍然需要物理服务器，但开发人员不需要考虑服务器细节。</p> <p>无服务器计算允许开发人员在灵活的“按需付费”的基础上购买后端服务，这意味着开发人员仅需为使用的服务付费。这类似于从每月固定限额的手机数据套餐切换到按实际使用的每个字节数据收费的套餐。</p> <p>“无服务器”一词在某种程度上具有误导性，因为它仍然依赖服务器提供这些后端服务，但所有服务器空间和基础设施问题都由提供商处理。无服务器意味着开发人员可以完全不用担心服务器。<a href=\"https://www.cloudflare.com/zh-cn/application-services/products/china-network/\" title=\"中国网络性能安全服务 | Cloudflare 中国官网 | Cloudflare\">[9]</a></p> <h3>为什么可以？</h3> <p>要实现以上目标，一个重要的前提是，我们连接到Cloudflare Workers的速度必须比连接到GitHub的速度更快，否则无论边缘计算技术的优势如何，其效果都将受到限制。中国的互联网架构与世界其他地区存在差异。在中国境内，用户访问位于境外的数据中心时可能会面临拥塞、数据丢失等问题，从而影响用户的使用体验。</p> <p>为了优化在中国境内的内容交付，关键在于建立遍布各地、地理位置分散的数据中心，并与每个地区的主要互联网服务提供商（ISP）建立连接。这正是Cloudflare中国网络所提供的服务。Cloudflare与京东云展开合作，以扩展网络覆盖。截至目前，Cloudflare在中国大陆已建立了超过45个数据中心，遍布约30个城市。<a href=\"https://www.cloudflare.com/zh-cn/application-services/products/china-network/\" title=\"中国网络性能安全服务 | Cloudflare 中国官网 | Cloudflare\">[9]</a></p> <h2>怎么开始</h2> <p>以下是Cloudflare Workers官方文档链接：</p> <ul> <li><a href=\"https://developers.cloudflare.com/workers/\">Cloudflare Workers · Cloudflare Workers docs</a> <a href=\"https://developers.cloudflare.com/workers/\" title=\"Cloudflare Workers · Cloudflare Workers docs\">[8]</a></li> <li><a href=\"https://developers.cloudflare.com/workers/runtime-apis/\">Runtime APIs · Cloudflare Workers docs</a> <a href=\"https://developers.cloudflare.com/workers/runtime-apis/\" title=\"Runtime APIs · Cloudflare Workers docs\">[10]</a></li> </ul> <h3>梦开始的地方</h3> <pre><code class=\"language-typescript\">addEventListener(&#039;fetch&#039;, (event) =&gt; { event.respondWith(handleRequest(event.request)); }); async function handleRequest(request: Request) { return new Response(&#039;Hello worker!&#039;, {}); }</code></pre> <p>熟悉JavaScript的同学应该一眼就能看出，这段代码注册了一个<code>fetch</code>事件处理程序，当有请求到达时，程序将调用<code>handleRequest</code>函数处理请求，并返回一个包含<code>Hello worker!</code>内容的<code>Response</code>对象。</p> <pre><code class=\"language-javascript\">addEventListener(type, listener): void</code></pre> <p>在Cloudflare中，<code>addEventListener</code>函数用于定义Workers处理请求的监听器。目前有三种监听器类型，我们只需要使用<code>fetch</code>类型。如果注册了多个<code>fetch</code>监听器，当一个监听器没有调用<code>event.respondWith()</code>时，事件将被传递给下一个注册的监听器。</p> <ul> <li><code>fetch</code>：当请求到达时触发</li> <li><code>scheduled</code>：定时触发</li> <li><code>queue</code>：队列触发</li> </ul> <h3>处理请求</h3> <p>要实现页面的反向代理，我们只需解析用户的请求，然后将请求发送到相应的目标服务器，最后将响应返回给客户端。</p> <pre><code class=\"language-typescript\">addEventListener(&#039;fetch&#039;, (event) =&gt; { event.respondWith(handleRequest(event.request)); }); async function handleRequest(request: Request) { const url = new URL(request.url); url.host = &#039;github.com&#039;; const newRequest = new Request(url.toString(), request); return fetch(newRequest); }</code></pre> <p>通过解析用户的请求，我们可以获得用户访问的URL。其中，<code>request.url</code>返回用户请求的URL字符串。我们可以构造一个<code>URL</code>对象来解析其中的信息。</p> <p>URL 接口用于解析，构造，规范化和编码 URL。它通过提供允许您轻松阅读和修改 URL 组件的属性来工作。通常，通过在调用 URL 的构造函数时将 URL 指定为字符串或提供相对 URL 和基本 URL 来创建新的 URL 对象。然后，您可以轻松读取 URL 的已解析组成部分或对 URL 进行更改。<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\" title=\"URL - Web APIs | MDN\">[11]</a></p> <p>我们可以通过修改<code>url.host</code>来修改用户请求的目标服务器，然后构造一个新的请求对象<code>newRequest</code>，将其发送到目标服务器。最后，将目标服务器返回的响应返回给客户端即可。</p> <p>这样，我们就完成了一个简单的反向代理。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691295829095.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691295829095.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>还有点问题</h3> <p>尽管我们已经实现了一个简单的反向代理，但仍然存在一些问题。例如，页面中存在许多链接，这些链接指向GitHub，而不是我们的反向代理。这会导致一个问题，即当用户点击这些链接时，他们会被重定向回GitHub，而不是我们的反向代理（例如左上角的GitHub Logo）。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691296063348.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691296063348.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>为解决这个问题，我们需要修改页面中的链接，使其指向我们的反向代理。这涉及解析页面，然后修改其中的链接。</p> <p>一种选择是使用HTMLRewriter，它允许开发人员在 Cloudflare Workers 应用程序内部构建全面且富有表现力的 HTML 解析器。它可以被视为直接位于 Workers 应用程序内部的类似于 jQuery 的体验。依靠强大的 JavaScript API 来解析和转换 HTML，HTMLRewriter 允许开发人员构建功能强大的应用程序。<a href=\"https://developers.cloudflare.com/workers/runtime-apis/html-rewriter\" title=\"HTMLRewriter · Cloudflare Workers docs\">[12]</a> 但是，此方法仅能修改 HTML 中的链接，无法修改 JavaScript 或返回 JSON 中的链接。因此，使用正则表达式解析页面并修改链接可能是更好的选择。</p> <pre><code class=\"language-typescript\">addEventListener(&#039;fetch&#039;, (event) =&gt; { event.respondWith(handleRequest(event.request)); }); async function handleRequest(request: Request) { const url = new URL(request.url); url.host = &#039;github.com&#039;; const newRequest = new Request(url.toString(), request); let newResponse = await fetch(newRequest); if (newResponse.body &amp;&amp; newResponse.headers.get(&#039;content-type&#039;)?.includes(&#039;text&#039;) || newResponse.headers.get(&#039;content-type&#039;)?.includes(&#039;application/json&#039;)) { let newBody = await newResponse.text(); newBody = newBody.replace(/\\/(www.)?github\\\\.com/g, &#039;\\/github.sakurapuare.com&#039;); newResponse = new Response(newBody, newResponse); } return newResponse; }</code></pre> <p>相较于上述代码，我们首先通过<code>fetch(newRequest)</code>获取返回的响应。然后，我们检查响应的<code>content-type</code>，只有在类型为<code>text</code>或<code>application/json</code>时，才对其进行解析。<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" title=\"MIME types - HTTP | MDN\">[13]</a> 随后，我们使用正则表达式将页面中的链接修改为指向我们的反向代理链接，并构建一个新的<code>Response</code>对象返回给客户端。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691297537761.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691297537761.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>谨防网络爬虫</h3> <p>在上述代码中，我们对所有请求都进行了处理，一切看起来很好。然而，我们还需要考虑一种情况，即网络爬虫。网络爬虫是一种用于浏览万维网内容的自动化程序，通常定期抓取网站内容以在搜索引擎中建立索引。<a href=\"https://en.wikipedia.org/wiki/Web_crawler\" title=\"Web crawler - Wikipedia\">[14]</a></p> <p>但这并不是我们所期望的，因为我们的网站只是GitHub的反向代理，不希望被搜索引擎收录。为此，我们需要屏蔽网络爬虫。</p> <p>这时，<code>robots.txt</code>文件就派上用场了。<code>robots.txt</code>是一个文本文件，网站管理员可以在其中指定哪些网页可以被网络爬虫访问，哪些网页不能被网络爬虫访问。<a href=\"https://en.wikipedia.org/wiki/Robots.txt\" title=\"robots.txt - Wikipedia\">[15]</a></p> <p>为避免网络爬虫，我们可以模拟一个<code>robots.txt</code>文件，然后将其返回给网络爬虫。以下是一个<code>robots.txt</code>文件示例，指示网络爬虫不要访问任何页面。</p> <pre><code class=\"language-text\">User-agent: * Disallow: /</code></pre> <p>我们可以读取用户访问的<code>pathname</code>，然后判断是否为<code>robots.txt</code>，如果是，则返回上面的内容。否则，我们就对用户的请求进行处理。</p> <pre><code class=\"language-typescript\">addEventListener(&#039;fetch&#039;, (event) =&gt; { event.respondWith(handleRequest(event.request)); }); async function handleRequest(request: Request) { const url = new URL(request.url); const {pathname} = url; if (pathname === &#039;/robots.txt&#039;) { return new Response(&#039;User-agent: *\\nDisallow: /&#039;, { headers: { &#039;content-type&#039;: &#039;text/plain;charset=UTF-8&#039;, }, }); } url.host = &#039;github.com&#039;; const newRequest = new Request(url.toString(), request); let newResponse = await fetch(newRequest); if (newResponse.body &amp;&amp; newResponse.headers.get(&#039;content-type&#039;)?.includes(&#039;text&#039;) || newResponse.headers.get(&#039;content-type&#039;)?.includes(&#039;application/json&#039;)) { let newBody = await newResponse.text(); newBody = newBody.replace(/\\/(www.)?github\\\\.com/g, &#039;\\/github.sakurapuare.com&#039;); newResponse = new Response(newBody, newResponse); } return newResponse; }</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691298559250.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/03/image-1691298559250.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>需要注意，尽管<code>robots.txt</code>中使用了“允许”和“禁止”术语，但该协议纯粹是建议性的，取决于网络爬虫是否遵守；它不能强制执行文件中的任何状态。恶意网络爬虫可能不会遵守<code>robots.txt</code>，有些人甚至可能使用<code>robots.txt</code>作为指南来查找不允许的链接并直接访问。</p> <p>为进一步防范，还可以结合Cloudflare的各种服务进行屏蔽，这里不再赘述。</p> <h2>Show me the Code</h2> <p>所有部署Workers需要的源代码已在<a href=\"https://github.com/SakuraPuare/Workers_Github_Reverse_Proxy\" title=\"Github\">Github</a>开源</p> <div class='github-info-card github-info-card-full card shadow-sm' data-author='SakuraPuare' data-project='Workers_Github_Reverse_Proxy' githubinfo-card-id='3874127929' data-getdata='frontend' data-description='' data-stars='' data-forks=''><div class='github-info-card-header'><a href='https://github.com/' ref='nofollow' target='_blank' title='Github' no-pjax><span><i class='fa fa-github'></i> GitHub</span></a></div><div class='github-info-card-body'> <div class='github-info-card-name-a'> <a href='https://github.com/SakuraPuare/Workers_Github_Reverse_Proxy' target='_blank' no-pjax> <span class='github-info-card-name'>SakuraPuare/Workers_Github_Reverse_Proxy</span> </a> </div> <div class='github-info-card-description'></div> </div><div class='github-info-card-bottom'> <span class='github-info-card-meta github-info-card-meta-stars'> <i class='fa fa-star'></i> <span class='github-info-card-stars'></span> </span> <span class='github-info-card-meta github-info-card-meta-forks'> <i class='fa fa-code-fork'></i> <span class='github-info-card-forks'></span> </span> </div></div> <h2>TS;WR (Too Short; Want Read)</h2> <p>直接使用吧 -&gt; <strong><a href=\"https://blog.sakurapuare.com/archives/2023/06/github_proxy/\">免费Github加速反向代理</a></strong></p> <h2>参考资料</h2> <ul> <li>[1] <a href=\"https://github.com/\">GitHub: Let&#8217;s build from here · GitHub</a></li> <li>[2] <a href=\"https://en.wikipedia.org/wiki/Proxy_server\">Proxy server &#8211; Wikipedia</a></li> <li>[3] <a href=\"https://en.wikipedia.org/wiki/Virtual_private_network\">Virtual private network &#8211; Wikipedia</a></li> <li>[4] <a href=\"https://gitee.com/\">Gitee &#8211; 企业级 DevOps 研发效能平台</a></li> <li>[5] <a href=\"https://en.wikipedia.org/wiki/Edge_computing\">Edge computing &#8211; Wikipedia</a></li> <li>[6] <a href=\"https://blog.sakurapuare.com/archives/2022/12/a-review-of-technology-and-application-on-edge-computing/\">【文献检索】边缘计算技术及应用综述【杂谈】</a></li> <li>[7] <a href=\"https://www.cloudflare.com/zh-cn/\">Cloudflare 中国官网 | 智能化云服务平台 | 免费CDN安全防护 | Cloudflare</a></li> <li>[8] <a href=\"https://developers.cloudflare.com/workers/\">Cloudflare Workers · Cloudflare Workers docs</a></li> <li>[9] <a href=\"https://www.cloudflare.com/zh-cn/learning/serverless/what-is-serverless/\">什么是无服务器计算_什么是后端服务_Cloudflare中国官网 | Cloudflare</a></li> <li>[10] <a href=\"https://www.cloudflare.com/zh-cn/application-services/products/china-network/\">中国网络性能安全服务 | Cloudflare 中国官网 | Cloudflare</a></li> <li>[11] <a href=\"https://developers.cloudflare.com/workers/runtime-apis/\">Runtime APIs · Cloudflare Workers docs</a></li> <li>[12] <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\">URL &#8211; Web APIs | MDN</a></li> <li>[13] <a href=\"https://developers.cloudflare.com/workers/runtime-apis/html-rewriter\">HTMLRewriter · Cloudflare Workers docs</a></li> <li>[14] <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\">MIME types &#8211; HTTP | MDN</a></li> <li>[15] <a href=\"https://en.wikipedia.org/wiki/Web_crawler\">Web crawler &#8211; Wikipedia</a></li> <li>[16] <a href=\"https://en.wikipedia.org/wiki/Robots.txt\">robots.txt &#8211; Wikipedia</a></li> </ul>",
    "publishDate": "2023-03-14T16:00:26.000Z",
    "modifiedDate": "2023-08-06T05:34:35.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 3,
        "name": "教程",
        "slug": "tutorial",
        "count": 2
      },
      {
        "id": 8,
        "name": "资源",
        "slug": "resource",
        "count": 2
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 407,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-e1706177649260.png",
      "alt": "",
      "title": "feature",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-e1706177649260.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-300x169.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"169\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-300x169.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-300x169.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-1024x576.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2023/03/feature-e1706177649260.png"
      },
      "width": 778,
      "height": 438,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2023/03/cloudflare_worker_based_github_reverse_proxy/",
    "wordCount": 646,
    "readingTime": 4,
    "seo": {
      "title": "基于 Cloudflare Workers 的 Github 反向代理【JavaScript】",
      "description": "<p>引言 作为全球最大的代码托管平台之一，GitHub [1]在开发者社区中具有重要地位。稳定且快速的访问对开发过 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2023/03/cloudflare_worker_based_github_reverse_proxy/"
    }
  },
  {
    "id": "337",
    "title": "【MCM / 2023 A题】How many plants can hit a drought? One or two more?",
    "slug": "how-many-plants-can-hit-a-drought-one-or-two-more",
    "excerpt": "<p>Abstract &quot;Global temperatures are warming, glacier [&hellip;]</p>",
    "content": "<h2>Abstract</h2> <p>&quot;Global temperatures are warming, glaciers are melting, sea levels are rising &#8230;&quot; All parts of the world are facing huge environmental disasters. In recent years, unusual weather and climate events have become more and more intense, and the number of &quot;record-breaking&quot; extreme weather events has increased. Trees are also becoming thin and weak under drought conditions. How many plants can survive drought conditions without being defeated and become the last survivors?</p> <p>In this paper, we investigate the change of species biomass over time under irregular weather conditions. For this we developed the <strong>Plant Community Interaction Model</strong> and an Improved Logistic Growth Competition Model. By using these two models, we investigated the tolerance of plant species and populations to the environment under drought conditions.</p> <p>First, we obtained a series of time-series images through the US nasa and worldview websites, and preprocessed the data through <strong>data visualization</strong> and <strong>cubic spline interpolation</strong>. In order to predict the changes of anomalous weather cycles and species populations, we developed the Lotka-Volterra competition model, further introduced the associated competition and growth coefficients, and derived a plot of actual species biomass versus time by analyzing the effects of their interspecific relationships on environmental biomass. In addition, we also proposed the climatic factors affecting environmental biomass, and selected the three most influential factors, temperature, precipitation and light, to derive the predicted species biomass versus time, and then determined the weight of each factor by <strong>difference fitting</strong> and <strong>entropy weight-multiple linear regression</strong>, and finally we obtained the predictive model of species biomass over time during the drought cycle.</p> <p>Second, to explore the relationship of how species species benefit the community. We selected three species with the same climate in the ecosystem as the study object and proposed an <strong>Improved Logistic Growth Competition Model</strong>. Based on this, we introduced the drought factor and species contact coefficients by considering environmental effects and interspecies effects, and the species contact coefficients were calculated separately. In the study of community benefit, we considered two parameters, Fraction of Photosynthetically Active Radiation and Gross Primary Productivity, to evaluate the impact brought by the ecosystem, and finally obtained the functional relationship between the species contact coefficient and the benefit coefficient by fitting the function Finally, the functional relationship between the species exposure coefficient and the benefit coefficient was obtained by fitting the function. The minimum number of species to benefit the community was determined to be <strong>460</strong> when the species contact coefficient was <strong>0.00937</strong>.</p> <p>Finally, we tested the robustness and sensitivity of the Improved Logistic Growth Competition Model and found that the model had better sensitivity by varying the images obtained from the species contact coefficients. We also evaluated the strengths and weaknesses of the model.</p> <p><strong>Keywords:</strong> <em>Lotka-Volterra competition model, improved logistic growth competition model, data visualization</em></p> <h2>Introduction</h2> <h3>Problem Background</h3> <p>Since plants can only grow in their pristine environment, they are vulnerable to various abiotic environmental impacts of stress such as sunlight, temperature, humidity, and drought throughout their growth and development. As one of the major abiotic stresses that affect normal plant growth and development and limit plant community diversity, drought affects plant life activities such as growth, development, and reproduction. Different species respond differently to their environment, while drought environments vary in their alteration of species traits. What is the minimum number of species required for a plant community to benefit from this local biodiversity? How does this phenomenon expand as the number of species increases? What does this imply for the long-term viability of plant communities?</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/Mountains_Lake_Forests_Russia_Chui_Lake_Altai_613981_1280x853-300x200.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/Mountains_Lake_Forests_Russia_Chui_Lake_Altai_613981_1280x853-300x200.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/173138-Sepik-300x188.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/173138-Sepik-300x188.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/Desert_Petra_Jordan_Crag_591491_1280x854-300x200.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/Desert_Petra_Jordan_Crag_591491_1280x854-300x200.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"\" /></div></p> <h3>Restatement of Problem</h3> <p>Considering the background information of plant and limiting conditions identified in the Problem Background , the main tasks of this paper are as follows:</p> <ol> <li> <p>A mathematical model is developed for predicting trends in plant communities over time in the face of irregular weather cycles. For example, in periods of drought when rain is supposed to fall, we will consider the interspecific relationships of plants to better predict changes in plant community biodiversity.</p> </li> <li> <p>With environmental variations, the sensitivity of different plant species to these changes may also vary. When the number of species increases, the ecosystem of the plant community may change, including species competition, interactions, etc., which in turn affects the ecological balance of the plant community.</p> </li> <li> <p>Evaluate and predict the role and importance of species diversity for the ecosystems in which the species lives.</p> </li> <li> <p>Future droughts occurring with greater frequency and variability will have widespread impacts on ecosystems and human societies. This could lead to water scarcity, poor crop yields, and increased desertification, thereby threatening biodiversity and human well-being.</p> </li> <li> <p>Pollution factors and habitat destruction are objectively present problems in the environment, which may significantly affect the conclusions. These problems may lead to loss of biodiversity, loss of ecosystem function, or even to the destruction of entire ecological chains.</p> </li> <li> <p>It is important to evaluate and predict the role and importance of species diversity to the ecosystem in which it is found. Species diversity is a key feature of ecosystems and has important implications for ecosystem health and stability.</p> </li> </ol> <h3>Literature Review</h3> <p>In recent years, the frequency of abnormal weather has increased significantly with global warming and human activities, and these abnormal weather events have had a dramatic impact on plant communities. It may affect the distribution range of species, and the composition of species and lead to changes in ecosystems. Thus, the analysis of the effects of the relationship between abnormal weather and plant populations has far-reaching implications for the succession of plant populations.</p> <p>Clark, James S., et al. [1] suggested that in the eastern United States, the effects of increased drought are better understood at the level of individual trees. Grossiord, Charlotte, et al. [2] modeled the predicted climate impacts on biodiversity across the continental United States.</p> <p>Tilman, D., Reich, P. B., et al. [3] discussed the high climate variability during the growing season over a decade, resulting in year-to-year changes in plant species abundance and ecosystem productivity. The greater the number of plant species, the greater the temporal stability of the annual production of above-ground plants in the ecosystem. Huang, W., Wang, W., et al. [4] studied the stability of grassland ecosystems under drought. concluded that alpine grasslands and alpine meadows were the most resistant but the least resilient. Meadow steppe and typical grassland were the least resistant but the most resilient.</p> <p>Prugh, Laura R., et al. [5] responded that plants are most responsive to a year of water deficit under extreme drought conditions. Spinoni, Jonathan, et al. [6] quantified the effects of extreme climatic events on contemporary ecological community composition.</p> <p>Zvereva, Elena L., Eija Toivonen, and Mikhail V. Kozlov. [7] showed for the first time that there are geographical differences in plant community responses to air emissions. By investigating the effects of IAP on Italian plant communities and Natura 2000 habitats, Lazzaro, Lorenzo, et al. concluded that competition was the main mechanism of influence. [8]</p> <h2>Our work</h2> <p>We need to analyze the laws behind the irregular weather and the effects between different species, and then build mathematical models based on them. In this paper, our work is focused on the following points:</p> <ul> <li> <p>Establishing Lotka-Volterra model based on multiple regression entropy weighting method, which can predict the results more accurately by the given input parameter values within a certain range.</p> </li> <li> <p>Predicting the effects of abnormal weather cycles and plant community biomass by analyzing the interspecific relationships of communities and the three factors affecting climate variables: temperature, precipitation, and light.</p> </li> <li> <p>Based on the above Lotka-Volterra model, a variety of factors including the environment is considered and parameters are added to make the model more responsive to the parameters and have better sensitivity.</p> </li> <li> <p>Successfully predicted the minimum number of species that would benefit itself from an ecosystem perspective.</p> </li> <li> <p>Discusses how to face drought in the future and makes recommendations from an ecosystem perspective</p> </li> </ul> <h2>Assumptions and Justifications</h2> <ul> <li> <p><strong>Assumption 1:</strong> There is no significant effect on the community except for the influencing factors proposed in the text.</p> <p><strong>Justification:</strong> Nature is a chaotic system with many external changing conditions, such as soil moisture, rainfall rate, and ozone layer hole. In order to simplify our model, other than the factors mentioned in the text, other factors did not have significant effects on the community.</p> </li> <li> <p><strong>Assumption 2:</strong> The variation of species biomass is determined by its internal and external factors, and the internal and external factors do not influence or interfere with each other.</p> <p><strong>Justification:</strong> Changes in species biomass are determined by both internal and external factors, and in order to make our model results strongly correlated with the factors that appear in the model, we consider that internal and external factors do not interfere with each other and only the factors that appear in the model need to be considered.</p> </li> <li> <p><strong>Assumption 3:</strong> The competitiveness index of each species is assumed to be fixed for each period of biological competition.</p> <p><strong>Justification:</strong> Since the change in the number of species does not change its original competitive index at each stage of the biological competition, the competitive index can remain approximately constant at a fixed stage.</p> </li> <li> <p><strong>Assumption 4:</strong> The data at the data collection sites represent the data of the whole region.</p> <p><strong>Justification:</strong> Since the climatic conditions of a region are roughly comparable, there may be a few points of difference, so we can assume that the climatic conditions of a region are roughly comparable.</p> </li> <li> <p><strong>Assumption 5:</strong> The growth rate of species growth is assumed to be continuous and stable.</p> <p><strong>Justification:</strong> The growth rate of a species is continuous and stable according to its survival years and also the environment will affect its growth rate.</p> </li> </ul> <h2>Notation</h2> <p>All symbols used in this paper are shown in Table [1]</p> <table> <thead> <tr> <th style=\"text-align: center;\">Symbols</th> <th style=\"text-align: center;\">Definitions</th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">N</code></td> <td style=\"text-align: center;\">Number of individuals of the species</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">r</code></td> <td style=\"text-align: center;\">Species intrinsic growth rate</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">K</code></td> <td style=\"text-align: center;\">Environmental capacity</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\alpha</code></td> <td style=\"text-align: center;\">Drought coefficient scale factor</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">D</code></td> <td style=\"text-align: center;\">Drought coefficient</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\beta</code></td> <td style=\"text-align: center;\">Species contact factor</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\delta</code></td> <td style=\"text-align: center;\">Standard deviation of the linear fit</td> </tr> </tbody> </table> <h2>The Data</h2> <h3>Data Collection</h3> <p>Data collection plays a role in mathematical modeling. the data we use in the paper comes from two main sources, one of which is NASA&#8217;s worldview. worldview provides data from several satellites, including Terra, Aqua, Suomi NPP, and NOAA. a worldview can be used to browse and analyze natural and anthropogenic activities on the Earth&#8217;s surface, such as meteorological phenomena, fires, climate change, land, and ocean surface temperatures, etc. We use Python to capture and visualize all data from 2010-2020 into images, the visualized image obtained from the search is shown in Figure [1]</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346196052.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346196052.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346232857.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346232857.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>We then used drought index data from Drought Monitor, a system developed by various U.S. government agencies to monitor and report on drought conditions. The system is updated weekly and provides nationwide drought data, analysis, and monitoring, as well as warnings and recommendations for different geographic areas. We collected drought levels from 2010-2020 for each U.S. state in the Drought Levels and DSCI data for use in our model tests, as shown in the Figure [2].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346252614.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346252614.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346265319.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346265319.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346275391.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690346275391.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <table> <thead> <tr> <th style=\"text-align: center;\">Name</th> <th style=\"text-align: center;\">URL</th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\">NASA Worldview</td> <td style=\"text-align: center;\"><a href=\"https://worldview.earthdata.nasa.gov/\">https://worldview.earthdata.nasa.gov/</a></td> </tr> <tr> <td style=\"text-align: center;\">U.S. Drought Monitor</td> <td style=\"text-align: center;\"><a href=\"https://droughtmonitor.unl.edu/\">https://droughtmonitor.unl.edu/</a></td> </tr> </tbody> </table> <h3>Data Visualization</h3> <p>We represent each data item in the database as a single graph element through data visualization techniques and use the data set collected in Table [2] to form a data image while representing the individual attribute values of the data as multidimensional data, which allows for a deeper observation and analysis of the data by observing the data in different dimensions, as shown in Figure [3].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344847015.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344847015.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>Finally, we also used some data from the literature, which we have attached at the end of the paper.</p> <h2>Model 1: Plant Community Interaction Model</h2> <h3>Model Prepraration</h3> <p>Plant growth is influenced by multiple factors, which can be mainly divided into external and internal factors. For external factors, the environment is usually the most dominant, while for internal factors, the widespread internal influences among species are also important. Therefore, we will study the changes in species communities in terms of interactions between species and the three factors that mainly influence climate. From this, we consider the analysis of the curvilinear pattern of changes in the three factors over time on species growth and modify the Lotka-Volterra model by weighting and multivariate linear fitting the weights obtained by the entropy weighting method with the three factors.</p> <h3>Model Introduction</h3> <p>A competition model for plant populations is a mathematical model used to describe the changes in numbers between plant populations due to contact. Common plant competition models include the Lotka-Volterra competition equation and the Tilman competition model.</p> <p>This model uses the Lotka-Volterra competition equation, a common two-species competition model that is often used to describe predator-prey interactions, to model population changes due to contact between species. The model is based on the simple assumption that the population size of each species grows at a rate proportional to the number of individuals of that species, but that the growth rate does not decrease while the two species compete with each other to maintain a stable value. The mathematical form of the Lotka-Volterra competition equation is as follows.</p> <pre><code class=\"language-katex\">\\frac{dN_1}{dt} = r_1 N_1(1-\\frac{N_1}{K_1} - \\frac{a_{12}N_2}{K_1})</code></pre> <pre><code class=\"language-katex\">\\frac{dN_2}{dt} = r_2 N_2(1-\\frac{N_2}{K_2} - \\frac{a_{21}N_1}{K_2})</code></pre> <p>Where <code class=\"katex-inline\">N_1</code> and <code class=\"katex-inline\">N_2</code> are the numbers of individuals of the two competing species; <code class=\"katex-inline\">r_1</code> and <code class=\"katex-inline\">r_2</code> are the endogenous growth rates of the two species, respectively; <code class=\"katex-inline\">K_1</code> and <code class=\"katex-inline\">K_2</code> are the environmental capacities of the two species, respectively; and <code class=\"katex-inline\">a_{12}</code> and <code class=\"katex-inline\">a_{21}</code> are the competition coefficients between the two species.</p> <p>The Lotka-Volterra competition model can be used to simulate population changes due to competition between different species of plants and interactions between the same species, on the basis of which future changes in plant communities can be predicted at the same time.</p> <p>At the same time, the Lotka-Volterra competition model can likewise be easily extended to use in the case of n species. On the basis of the above equation, we can describe the competition among n species by the following set of differential equations:</p> <pre><code class=\"language-katex\">\\frac{dN_i}{dt} = r N_i(1-\\frac{N_i}{K_i} - \\sum_{j=1}^n a_{ij} \\frac{N_j}{K_j})</code></pre> <p>Where <code class=\"katex-inline\">N_i</code> is the number of individuals of the <code class=\"katex-inline\">i</code> th species, <code class=\"katex-inline\">r_i</code> is the intrinsic growth rate of the <code class=\"katex-inline\">i</code> th species, <code class=\"katex-inline\">K_i</code> is the environmental capacity of the <code class=\"katex-inline\">i</code> th species, and <code class=\"katex-inline\">a_{ij}</code> is the competition coefficient of the <code class=\"katex-inline\">j</code> th species against the <code class=\"katex-inline\">i</code> th species. The Lotka-Volterra competition model takes into account both the environmental capacity and species relationship influences on community abundance, <code class=\"katex-inline\">\\frac{N_i}{K_1}</code> indicates that the specific growth rate is influenced by the environmental holding capacity <code class=\"katex-inline\">K</code> and also by the relative number and competitive ability between two species. In this model, we do not consider the effects caused by the same species to grab resources and space, i.e., the survival environment and space are sufficient. Therefore, the value of <code class=\"katex-inline\">a_{ii}</code> is zero here.</p> <p>From the theoretical model described above, we know that there is competition between two different species for food and habitat without considering the influence caused by the external environment. In general, the difference in competitiveness between two different species is not large, and eventually, the two populations reach a relative equilibrium and maintain it stably. For two species with a large difference in species competitiveness, the usual outcome is that the more competitive one competes the relatively less competitive one to extinction, and the autochthonous one reaches the environmental capacity allowed by the ecosystem. Therefore, we can predict the subsequent course of the final two species by giving the initial values between two different species, the environmental holding capacity, and their mutual competition coefficients.</p> <h4>Solution to the Problem 1</h4> <p>The use of the Lotka-Volterra competition model is predicated on the so-called need to give initial values between two different species, the environmental accommodation, and their competition coefficients with each other in order to predict the subsequent course of the final two species. For <strong>Problem 1</strong>, using the present model does not give us the option to give these values. Instead, we innovatively propose an ecosystem-based competition model theory, in other words, instead of giving the number between two different species, we cleverly solve the problem that the series parameters between two different species are not easy to determine by considering the larger concept of ecosystem. By considering 2-3 unique species within the ecosystem, we successfully solve the problem of predicting the number of organisms when considering both species competition and environmental factors.</p> <p>Specifically, it is assumed that only three different species exist in the ecosystem and that no other species exist in the ecosystem within a certain range, i.e., there is no interference with the model data from species other than these three. We use the observable &quot;Vegetation Index&quot; of the satellite species to predict the subsequent changes in biomass.</p> <p>In the introduction, we have given the Lotka-Volterra competition model for <code class=\"katex-inline\">N</code> species, as in Eq. Therefore, the Lotka-Volterra competition equation based on three different species can be given as follows.</p> <pre><code class=\"language-katex\">\\frac{dp}{dt} = r_1p (1- \\frac{p - \\alpha (q + \\mu)}{K_1})</code></pre> <pre><code class=\"language-katex\">\\frac{dq}{dt} = r_2q (1- \\frac{q - \\beta (p + \\mu)}{K_2})</code></pre> <pre><code class=\"language-katex\">\\frac{d\\mu}{dt} = r_3\\mu (1- \\frac{\\mu - \\gamma (p + q)}{K_3})</code></pre> <p>Where <code class=\"katex-inline\">p</code>, <code class=\"katex-inline\">q</code>, <code class=\"katex-inline\">\\mu</code> is the biomass of three different species, and <code class=\"katex-inline\">K_1</code>, <code class=\"katex-inline\">K_2</code> and <code class=\"katex-inline\">K_3</code> denote the environmental capacity of the three species, i.e., the maximum amount that can support the survival of the species when only species competition is considered. <code class=\"katex-inline\">r_1</code>, <code class=\"katex-inline\">r_2</code>, and <code class=\"katex-inline\">r_3</code> denote the growth rates of species 1,2, and 3, respectively, and <code class=\"katex-inline\">\\alpha</code> beta gamma denotes the competition coefficient between the three different species. The competition coefficient between the three different species. Meanwhile, the growth inhibition of <code class=\"katex-inline\">p</code>, <code class=\"katex-inline\">q</code>, and <code class=\"katex-inline\">\\mu</code> populations by their own populations is <code class=\"katex-inline\">\\frac{1}{k_1}</code>,<code class=\"katex-inline\">\\frac{1}{k_2}</code>, <code class=\"katex-inline\">\\frac{1}{k3}</code> and the influence of <code class=\"katex-inline\">p</code>, <code class=\"katex-inline\">q</code>, <code class=\"katex-inline\">\\mu</code> populations by other populations is <code class=\"katex-inline\">\\frac{a}{k_1}</code>, <code class=\"katex-inline\">\\frac{b}{k_2}</code>, and <code class=\"katex-inline\">\\frac{c}{k_3}</code>, respectively. the specific values of each parameter are shown in Table</p> <table> <thead> <tr> <th style=\"text-align: center;\"></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">r</code></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">\\frac{1}{k}</code></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">p</code>,<code class=\"katex-inline\">q</code>,<code class=\"katex-inline\">\\mu</code></th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\alpha</code></td> <td style=\"text-align: center;\">0.4</td> <td style=\"text-align: center;\">0.005</td> <td style=\"text-align: center;\">0.03</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\beta</code></td> <td style=\"text-align: center;\">0.7</td> <td style=\"text-align: center;\">0.008</td> <td style=\"text-align: center;\">0.02</td> </tr> <tr> <td style=\"text-align: center;\"><code class=\"katex-inline\">\\gamma</code></td> <td style=\"text-align: center;\">0.5</td> <td style=\"text-align: center;\">0.012</td> <td style=\"text-align: center;\">0.01</td> </tr> </tbody> </table> <p>We can change these coefficients to alter the different growth curve relationships of species, make different species grow at different rates by adjusting the growth rate of each species, and adjust the competition coefficients between different species to show the interspecific competition relationships of different species. On the basis of the table, we can draw the biomass of the three species as a function of time, as shown in Figure [3] .</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344866561.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344866561.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"The biomass of three different species with respect to time\" /></div></p> <p>This figure shows the change curves of the biological population of three different species with respect to time. It can be noted that the three different species have different growth rates and upper bounds for their three curves due to their different initial numbers of species, different growth rates of species, and different competition coefficients of species. In addition, we also plotted an image of the total ecosystem biomass on top of this graph, which is the red curve in the Figure [4]. This is because we have used the concept of &quot;Vegetation index&quot; to measure the total biomass of species, as described earlier, by summing the three curves.</p> <p>We collected all biomass data of Yellowstone Park from 2010 to 2020, collected the changes in biomass in the park over ten years, and plotted them in month classification. On top of this, we also superimposed the total biomass obtained from the graph with it and plotted the total biomass versus time for the theoretical model compared with the observed values as in Figure [5].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344889219.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344889219.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>Without considering other factors, although there are more than three species in Yellowstone, the growth trend of the total biomass should be consistent with the image obtained from the Lotka-Volterra competition model, but the fact is that the two curves do not overlap and the observed values are significantly lower than those calculated by the theory, and the model also has errors, as shown in Figure [6].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344894364.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344894364.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>A Little Correction</h3> <p>Although the above model can describe the species population change curve with time to some extent, it still cannot fit the data values we observed well, and there is an error value, thus indicating that there are some non-negligible factors that we accidentally ignored. Therefore, it is still necessary to correct the model we obtained on the basis of the above in order to finally obtain a predictable model image, as in Equation. where let the theoretical value of the observed total biomass be <code class=\"katex-inline\">f(t)</code> and the value we actually get is <code class=\"katex-inline\">g(t)</code>, and there is an error <code class=\"katex-inline\">\\delta</code> between the two.</p> <pre><code class=\"language-katex\">f(t) = g(t) + \\delta</code></pre> <p>After considering the internal factors between different species, the external factors objectively brought by the environment should not be neglected as well. Therefore, the impact of the variable climatic environment on organisms in the environment should be taken into account <code class=\"katex-inline\">\\delta</code>.</p> <p>There are many factors in the environment that affect the growth of organisms, such as <code class=\"katex-inline\">CO_2</code> concentration, microorganisms in the soil, and pH in rainwater, but the three most important factors for plant growth are temperature, precipitation, and sunlight, for the following reasons.</p> <ol> <li> <p><strong>Temperature</strong>: The life activities of living organisms are based on aerobic respiration, and the metabolic activities carried out by aerobic respiration require enzymes in a specific temperature range to work properly to catalyze the reactions. Too high or too low ambient temperature can affect the growth and development of the organism or even death.</p> </li> <li> <p><strong>Precipitation</strong>: The life activities of living organisms are carried out with water as a carrier. Living organisms not only need water to maintain cellular functions and life activities but also need water as a carrier for information transfer and energy transport. Too much or too little water may affect the growth and development of living organisms.</p> </li> <li> <p><strong>Sunlight</strong>: For plants, light is necessary for photosynthesis, and only in a place with proper and sufficient sunlight can plants properly carry out photosynthesis to release oxygen and produce organic matter. Therefore, we will consider the influence of the environment on organisms from the above three factors.</p> </li> </ol> <p>Therefore, we will consider the influence of the environment on organisms from the above three factors.</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344910035.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344910035.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><strong>Temperature effects on changes in total biomass</strong></p> <p>Temperature plays a key role in plant growth and development because many of the physiological processes that take place in plants require a certain temperature. In general, plants will grow faster at higher temperatures than at lower temperatures because the former respiration rate is higher than the latter. The photosynthesis of plants is affected by temperature, which in turn affects total biomass, and is modeled theoretically by the following equation.</p> <pre><code class=\"language-katex\">\\frac{dN}{dt} = rN(1-\\frac{N}{K}) - c(T-T_0)N</code></pre> <p>Where <code class=\"katex-inline\">N</code> denotes the population size of the plant, <code class=\"katex-inline\">r</code> is the growth rate of the plant population, <code class=\"katex-inline\">K</code> is the environmental holding capacity, <code class=\"katex-inline\">c</code> denotes the influence factor of temperature on plant growth, <code class=\"katex-inline\">T</code> is the current ambient temperature, and <code class=\"katex-inline\">T_0</code> is the baseline temperature for plant growth. The above equation is solved by MATLAB and the image is obtained as Figure [8].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344919002.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344919002.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><strong>Impact of precipitation on changes in total biomass</strong></p> <p>Precipitation is one of the most fundamental meteorological phenomena in nature and it has a profound impact on the environment. Precipitation is one of the necessary conditions for vegetation growth, and plants need water to grow, photosynthesize and metabolize substances. Suitable precipitation can promote plant growth and increase crop yield. The changes in the total biomass of plant communities due to the influence of precipitation can be expressed as follows.</p> <pre><code class=\"language-katex\">\\frac{dN}{dt} = rN (1 - \\frac{N}{K} ) \\frac{W} {W_0}</code></pre> <p>Where <code class=\"katex-inline\">N</code> is the number of individuals in the plant community, <code class=\"katex-inline\">r</code> is the specific growth rate, <code class=\"katex-inline\">K</code> is the environmental holding capacity, <code class=\"katex-inline\">W</code> are the amount of precipitation, and <code class=\"katex-inline\">W_0</code> represents the optimum rainfall level for plants, the image of which is shown in Figure [9].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344930510.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344930510.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>It is not difficult to see from the images that the total amount of plants increases with the increase of precipitation within a certain precipitation range. However, after exceeding the optimum precipitation amount <code class=\"katex-inline\">P_0</code> for plants, the total amount of plants instead decreases with the increase of precipitation.</p> <p><strong>Effect of sunlight on changes in total biomass</strong></p> <p>Light is also one of the key factors for plant growth because sunlight provides the necessary energy for photosynthesis, enabling plants to increase their total biomass by converting CO2 and water into organic matter, and the relationship between light and total plant mass has the differential equation.</p> <pre><code class=\"language-katex\">\\frac{dN}{dt} = rN(1-\\frac{N}{K})f(t)</code></pre> <p>Where <code class=\"katex-inline\">N</code> denotes the number of plant communities, <code class=\"katex-inline\">r</code> denotes the growth rate of plants, <code class=\"katex-inline\">K</code> denotes the capacity of the ecosystem, and <code class=\"katex-inline\">f(t)</code> denotes the variation of light intensity at time <code class=\"katex-inline\">t</code>. In the real situation, the variation of light is repeated in small cycles of one day and large cycles of one year. To simplify our model, we can choose a simple periodic function to replace the variation of light intensity, such as a simple sine function.</p> <pre><code class=\"language-katex\">f(t) = \\sin(\\omega t)</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344939495.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344939495.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><strong>The Entropy Weight Method</strong></p> <p>From the above description we can know that in the actual environment, unlight, precipitation, and temperature generally speaking influence he growth of total biomass by affecting the photosynthesis of plants nd thus the growth of total biomass, but these factors affect different roportions of the same. Based on the need to determine the weights of ultiple indicators, we decided to evaluate the influence of each index n the correction value in a comprehensive way by the entropy weight ethod.</p> <p>The entropy weighting method is a commonly used method to determine the weights of multiple indicators. By calculating the relative entropy values between multiple indicators, we can quickly and accurately calculate the weighting relationships between different indicators without a priori results, so as to improve the accuracy of the results. For the determined index, we need to calculate the entropy value <code class=\"katex-inline\">E_i</code> of the `$$i$$th index, i.e.</p> <pre><code class=\"language-katex\">E_i = - \\frac{1}{ln(n)} \\sum_{j=1}^n \\frac{p_{ij}}{ln(p_{ij})}</code></pre> <p>Where <code class=\"katex-inline\">n</code> denotes the number of indicators, <code class=\"katex-inline\">p_{ij}</code> denotes the proportion of the <code class=\"katex-inline\">i</code>th indicator in the <code class=\"katex-inline\">j</code>th sample, and <code class=\"katex-inline\">\\ln</code> denotes the natural logarithm. Then, the weight <code class=\"katex-inline\">w_i</code> of each indicator is calculated based on the entropy value of the indicator.</p> <pre><code class=\"language-katex\">\\hat{w_i} = \\frac{w_i}{\\sum^n_{i=1}w_i}</code></pre> <p>The weights of the obtained indicators are normalized so that the sum is equal to 1</p> <pre><code class=\"language-katex\">w_i = \\frac{1 - E_i}{n - \\sum^n_{j=1} E_j}</code></pre> <p>Based on the above description, we analyzed all the data of sunlight, precipitation, and temperature changes in Yellowstone Park during 2010-2020 using the entropy weighting method to determine the weights. The calculation results are as follows Figure [11].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344958613.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690344958613.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><strong>Solution</strong></p> <p>We obtained the relationship between the effects of temperature, precipitation, and light on total plant biomass. Then, we obtained the corresponding weights of the three variables by analyzing these three data. Next, we need to consider these three together and use them to correct our model.</p> <p>Multiple linear fitting is a statistical analysis method used to analyze the relationship between multiple independent variables and a dependent variable. Through multiple linear fitting, we can determine the degree of influence of the independent variables on the dependent variable and use the fitted results to make predictions or interpretations, the general equation of the multiple linear regression equation is as follows.</p> <pre><code class=\"language-katex\">y_i = b_1 x_{i1} + b_2 x_{i2} + \\cdots + b_n x_{in} + e_i</code></pre> <p>The three weights obtained above were then used to perform a ultivariate linear fit to them, and the actual error values were pproximated by least squares tests and minimizing the sum of squares of he residuals. For the three factors of temperature, precipitation, and ight, the following linear regression equations are available.</p> <pre><code class=\"language-katex\">\\delta = \\zeta x_1 + \\eta x_2 + \\xi x_n + \\epsilon</code></pre> <p>By solving and fitting their values, the parameter values of <code class=\"katex-inline\">\\zeta</code>, <code class=\"katex-inline\">\\eta</code>, <code class=\"katex-inline\">\\xi</code>, and <code class=\"katex-inline\">\\epsilon</code> are tabulated in Table [4].</p> <table> <thead> <tr> <th style=\"text-align: center;\"><code class=\"katex-inline\">\\zeta</code></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">\\eta</code></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">\\xi</code></th> <th style=\"text-align: center;\"><code class=\"katex-inline\">\\epsilon</code></th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\">0.34119</td> <td style=\"text-align: center;\">1.70569</td> <td style=\"text-align: center;\">0.5320</td> <td style=\"text-align: center;\">1.0962</td> </tr> </tbody> </table> <pre><code class=\"language-katex\">\\delta = 0.34119 x_1 + 1.70569 x_2 + 0.5320 x_n + 1.0962</code></pre> <p>As a result, we obtained the Lotka-Volterra competition model based on the multiple regression entropy methods, which can provide a good prediction of species numbers in relation to time after correcting for errors by taking into account the effects of species exchange and environmental factors, given sunlight, precipitation, and temperature parameters in advance, and the number of species over a period of time.</p> <h2>Model 2: Plant Community Interaction Environment Model</h2> <p>Unlike Model 1, we selected three different ecosystems under the same climatic conditions as the subject of this model (in this model it is a temperate monsoon climate). Since we selected ecosystems with the same climatic conditions. Therefore, we do not consider the effects of sunlight, precipitation, and temperature due to climate in the model. For a single species in an ecosystem, the number of species is continuous over time and has a constant growth rate in the absolute ideal case. We can derive the one-dimensional differential equation for the number of species with respect to time as follows.</p> <pre><code class=\"language-katex\">\\frac{dN(t)}{dt} = cN(t)</code></pre> <p>Where <code class=\"katex-inline\">c</code> denotes the growth rate of the species. However, all of the above is possible only under ideal conditions, considering that the number of organisms that the environment can bear, i.e., the environmental holding capacity, is limited within a certain range of the community. According to the Logistic growth principle, the growth rate of a species population slowly decreases with time due to the limited environmental carrying capacity. Therefore, we consider the blocking factor <code class=\"katex-inline\">\\frac{1-N(t)}{k}</code> that affects the number of species and correct the equation to</p> <pre><code class=\"language-katex\">\\frac{dN(t)}{dt} = cN(1 - \\frac{N}{K})</code></pre> <h3>Solution to the Problem 4</h3> <p>Although the subjects we selected for the study are all in the same environment, i.e., for the effects brought about by climate the three are equivalent in time scale, in other words, the effects on the number of species are equivalent. However, in the case of extreme drought, the growth rate of organisms is likely to decrease or even stop due to the lack of water resources. Therefore, taking into account the influence of irregular weather conditions in the environment, and under the assumption that the influence of environmental factors and interspecific relationships on community biomass is linear, we derive the following equation.</p> <pre><code class=\"language-katex\">\\frac{dN(t)}{dt} = rN(t)(1-\\frac{N(t)}{K} - \\alpha D)</code></pre> <p>This equation is compared with Eq. with an additional coefficient <code class=\"katex-inline\">\\alpha D</code>. where <code class=\"katex-inline\">\\alpha</code> is the effect of environmental factors on community biomass, and since <code class=\"katex-inline\">\\alpha</code> is only a coefficient controlling the degree of drought impact, we can temporarily ignore the effect of changes in this value. d is the drought index. At this point, the number of species is not only limited by the environmental holding capacity <code class=\"katex-inline\">K</code> but also affected by irregular drought conditions. We use the Drought Monitor&#8217;s drought index to measure the drought conditions of the area. This drought index is obtained from the cumulative drought monitoring data, i.e., the percentages of <code class=\"katex-inline\">D_0</code> to <code class=\"katex-inline\">D_4</code> for a given week are summed to obtain the drought severity and coverage index for that week.</p> <p>Thus, we can get the answer to question four. For more frequent and more variable droughts. An increase in drought frequency increases the effect of drought on plant community biomass by affecting the magnitude of <code class=\"katex-inline\">\\alpha</code>, while greater variability affects the change in plant community biomass by climatically changing the value of the drought index <code class=\"katex-inline\">D</code>.</p> <h3>Solution to the Problem 3</h3> <p>Although the coefficient aD presented in question four takes into account the more frequent and variable drought climate scenario, the biomass in relation to time differs in our chosen study population, even though the effects of drought on the three ecosystems are simultaneous and equivalent. The Figure [12] shows the total biomass of three ecosystems, namely forest, grassland, and desert, obtained after fitting processing.</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345003876.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345003876.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>The graph is a plot of total biomass versus time for three ecosystems, namely forest, grassland, and desert, obtained after fitting processing. From the figure, it can be concluded that the growth rate of the three curves varies without considering the influence of climate and other factors, and the speed of their growth rate is determined by the inherent properties of their ecosystems. For different organisms, the curves grow faster in the initial period when the biomass is low. However, the growth rate of the curve slows down due to the influence of environmental capacity. As can be seen from the figure, the three curves do not overlap and have a certain distance.</p> <p>Therefore, we add a coefficient <code class=\"katex-inline\">\\beta</code> to the above equation and define it as the &quot;Species Contact Coefficient&quot;. The so-called species contact coefficient is essentially the coefficient of the difference in the number of species between ecosystems, specifically the effect of interspecific relationships between species on the biomass of the community. This coefficient defines the relationship between species and the sum of the values of harmful and beneficial exposures between species.</p> <pre><code class=\"language-katex\">\\frac{dN(t)}{dt} = rN(t)(1-\\frac{N(t)}{K} - \\alpha D+ \\beta)</code></pre> <p>The answer to question 3 is that, given the same environmental factors, differences in species types affect the growth of total biomass by influencing what we define as the &quot;species contact factor&quot;. As the number of species increases, their biomass grows faster and faster over time, and the gradient of growth becomes larger and larger.</p> <h3>Solution to the Problem 2</h3> <p>The differential equations of forest community biomass for different environmental factors and interspecific relationships can be evolved accordingly for the community biomass for different environmental factors and interspecific relationships under grassland, and desert regions, as follows.</p> <pre><code class=\"language-katex\">\\frac{dN_1(t)}{dt} = r_1N_1(t)(1-\\frac{N_1(t)}{K_1} - \\alpha D_1 + \\beta_1)</code></pre> <pre><code class=\"language-katex\">\\frac{dN_2(t)}{dt} = r_2N_2(t)(1-\\frac{N_2(t)}{K_2} - \\alpha D_2 + \\beta_2)</code></pre> <pre><code class=\"language-katex\">\\frac{dN_3(t)}{dt} = r_3N_3(t)(1-\\frac{N_3(t)}{K_3} - \\alpha D_3 + \\beta_3)</code></pre> <p>Where <code class=\"katex-inline\">N_1</code>, <code class=\"katex-inline\">N_2</code>, and <code class=\"katex-inline\">N_3</code> represent the biomass of forest, grassland, and desert, respectively; <code class=\"katex-inline\">r_1</code>, <code class=\"katex-inline\">r_2</code>, and <code class=\"katex-inline\">r_3</code> represent the growth rates of species 1,2, and 3, respectively; <code class=\"katex-inline\">a</code>, <code class=\"katex-inline\">b</code>, and <code class=\"katex-inline\">c</code> represent the interspecific competition coefficients, respectively; and <code class=\"katex-inline\">k1</code>, <code class=\"katex-inline\">k_2</code>, and <code class=\"katex-inline\">k_3</code> represent the maximum environmental holding capacity of species, respectively.</p> <p>We chose the grassland ecosystem as a benchmark and made the following scatter plot of its biomass with respect to time and fitted it as a function, as shown in Figure [13].</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345010940.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345010940.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>By fitting the function and comparing it with our theoretical model, we can derive the difference <code class=\"katex-inline\">\\delta</code>, which is the value of the &quot;species contact coefficient&quot; mentioned in the previous section, which is only related to the species of the community ecosystem, but not to the environment and other factors.</p> <p>Similarly, for the other two ecosystems, we can obtain the &quot;species contact coefficients&quot; for the three different ecosystems, as shown in the Table [5].</p> <table> <thead> <tr> <th style=\"text-align: center;\">Forrest</th> <th style=\"text-align: center;\">Grasslands</th> <th style=\"text-align: center;\">Dessert</th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\">0.025</td> <td style=\"text-align: center;\">0.017</td> <td style=\"text-align: center;\">0.008</td> </tr> </tbody> </table> <p>We next focus on the issue of ecosystem benefit, which for plant communities benefits the community in several ways.</p> <ol> <li> <p><strong>Photosynthesis</strong>: Through photosynthesis, plants absorb carbon dioxide from the air and emit oxygen back to the atmosphere, maintaining the carbon cycle and oxygen balance of the ecosphere.</p> </li> <li> <p><strong>Provision of food</strong>: As the bottom producer in the biosphere, plants have the function of transferring energy and providing food to the upper layers of the food chain. Through photosynthesis, plant bodies obtain energy from sunlight and transfer it to higher consumers within the food chain.</p> </li> <li> <p><strong>Habitat</strong>: Some large plants can also provide habitat and protection functions for some small animals. The shading of sunlight by large trees and the range of their influence make animals protected.</p> </li> <li> <p><strong>Maintain soil structure and prevent erosion</strong>: Plants have very well-developed root systems, which penetrate deep into the ground to maintain the soil structure and prevent erosion and erosion caused by rainfall.</p> </li> </ol> <p>We used two parameters, Fraction of Photosynthetically Active Radiation and Gross Primary Productivity, to evaluate the impact on the ecosystem.</p> <p>The fraction of Photosynthetically Active Radiation is the proportion of radiant energy in the visible spectrum in the range of 400-700 nm to the full wavelength of radiant energy, which can be absorbed by pigments such as chlorophyll and converted into chemical energy, thus promoting photosynthesis in plants and thus increasing their oxygen production. Primary Productivity is the rate at which an organism converts inorganic substances into organic substances through photosynthesis or chemical synthesis in an ecosystem over a certain period of time. These organic substances supply the organism&#8217;s own energy and nutrient needs and support the survival of other organisms in the ecosystem.</p> <p>Therefore, based on the above elaboration, it is reasonable for us to use these two data to determine the impact of the community on the ecosystem.</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348092523.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348092523.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348101414.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348101414.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>Since the periodicity of the images can be clearly observed for the above two variables, we first classify them, i.e., by month for the years 2010-2020, and perform a linear fit to the above two variables, using the slope <code class=\"katex-inline\">k</code> of their functions as their return coefficients.</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345022048.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345022048.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>Similarly, the species exposure coefficients for the three ecosystems and their benefit coefficients can be calculated as Table [6].</p> <table> <thead> <tr> <th style=\"text-align: center;\">Species exposure factor</th> <th style=\"text-align: center;\">Benefit factor</th> </tr> </thead> <tbody> <tr> <td style=\"text-align: center;\">0.025</td> <td style=\"text-align: center;\">0.06704</td> </tr> <tr> <td style=\"text-align: center;\">0.017</td> <td style=\"text-align: center;\">0.04451</td> </tr> <tr> <td style=\"text-align: center;\">0.008</td> <td style=\"text-align: center;\">0.01524</td> </tr> </tbody> </table> <p>The analytical equation can be derived from the above equation</p> <pre><code class=\"language-katex\">y = 3.051x - 0.02858</code></pre> <p>When <code class=\"katex-inline\">y = 0</code>, we have <code class=\"katex-inline\">x = 0.00937</code>.</p> <p>That is when its species contact coefficient is 0.00937, the coefficient of the benefit of the population to the ecosystem is 0. At this point, the species contact coefficient is 1.17125 times the species contact coefficient of the grassland, and according to mentioned, the grassland has an average of 393 different species [9], so we can conclude that the minimum number of species that benefit the community is 460 species.</p> <p>The equation we derived here also further proves that in Problem 4: When greater frequency and wider variation of the occurrence of droughts, their rainfall will decrease. Since the independent variable b is positively correlated with the response variable y. Therefore, the greater frequency and wider variation of the occurrence of droughts will decrease. Therefore, the greater frequency and wider variation of the occurrence of droughts will also lead to a decrease in species biomass.</p> <h3>Solution to Problem 5</h3> <p>The three questions above all explore the relationship between community biomass and time well without considering external factors, but real life is not so rosy. In addition to the effects of natural factors on biomass, human-caused impacts have more serious effects on plants. For example air pollution, dust pollution, toxins, crop diseases, etc.</p> <p>For less severe impacts, we consider that such impacts are different from the previously mentioned environmental drought, and although they also reduce total biomass, the rate of reduction should be exponentially increasing.</p> <p>In the equation, <code class=\"katex-inline\">P</code> represents the negative effect of environmental pollution on total biomass. This indicates that organisms are very sensitive to pollution, implying that a very small amount of pollution can be devastating to an entire biome or even cause the extinction of a specific species.</p> <h2>Sensitive Analysis</h2> <p>Considering that differences in the number of species types differ in the extent to which they are beneficial to the environment, we wanted to test the sensitivity of the model by performing a sensitivity analysis of the second problem using a second model. Based on the above study, we consider that the species exposure coefficient increases at 5% to obtain a set of control curves, from which it is calculated that</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348198932.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348198932.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348205963.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/image-1690348205963.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>From the data in the figure, it can be concluded that the benefit coefficient changes sensitively as the species exposure coefficient increases.</p> <h2>Discussion</h2> <h3>Solution to Problem 6</h3> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345033024.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/07/image-1690345033024.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>According to the flowchart, abnormal weather cycles have a double impact on the diversity of plant tribes. On the one hand, if plant tribes become more diverse, the competition between different plant species will become more intense and therefore the number of each species will decrease, which has a negative impact on plant diversity. On the other hand, biodiversity will certainly increase the stability of the ecosystem. When unusual weather cycles occur, ecosystems with high biodiversity are more likely to maintain reproductive efficiency and avoid collapse.</p> <p>The importance of biodiversity is different in different environments. Arid environments prefer low plant diversity because in this case, the environment is stable, so maintaining efficient reproduction is a priority. As plant tribal diversity increases, it becomes more important to maintain the stability of the system, and therefore, in forest environments, plant tribal diversity is high.</p> <h3>Strengths</h3> <ul> <li> <p>Our model is based on a certain theoretical foundation. By reviewing a large amount of literature, the corresponding parameters were selected. For the model solution, it can be found that it fits well with the real values, which shows that our model can predict the changes in plant populations under abnormal weather conditions more accurately.</p> </li> <li> <p>Since nature is full of unknowns, we made a reasonable simplification by selecting among the climatic factors the more influential cases of temperature, precipitation, and light on plants. We used the forest scenario to predict, and then we calculated the grassland and desert, and we tested the accuracy of the model, which can reflect the universality of our model to some extent.</p> </li> <li> <p>We verified the stability of the model through reasonable assumptions and sensitivity analysis of the model.</p> </li> </ul> <h3>Weaknesses</h3> <ul> <li> <p>The growth rate of the same species is not constant due to environmental changes and human factors, and this paper does not analyze the growth rate of such changes.</p> </li> <li> <p>Nature is a chaotic system, and there are many uncontrollable factors in nature, such as severe weather conditions that we cannot predict.</p> </li> </ul> <h3>Futher Work</h3> <p>In this paper, we only selected the study in the United States, the climate of drought areas around the world is not necessarily the same, so we should select a larger research scope to study, and in the future, we can propose better models or more advanced algorithms to expand the model to more objects with a wider range of application.</p> <h2>Reference</h2> <ul> <li>[1] Clark, J., Iverson, L., Woodall, C., Allen, C., Bell, D., Bragg, D., D&#8217;Amato, A., Davis, F., Hersh, M., Ibanez, I., &amp; others (2016). The impacts of increasing drought on forest dynamics, structure, and biodiversity in the United States. Global change biology, 22(7), 2329–2352.</li> <li>[2] Grossiord, C., Granier, A., Gessler, A., Jucker, T., &amp; Bonal, D. (2014). Does drought influence the relationship between biodiversity and ecosystem functioning in boreal forests?. Ecosystems, 17, 394–404.</li> <li>[3] Tilman, D., Reich, P., &amp; Knops, J. (2006). Biodiversity and ecosystem stability in a decade-long grassland experiment. Nature, 441(7093), 629–632.</li> <li>[4] Huang, W., Wang, W., Cao, M., Fu, G., Xia, J., Wang, Z., &amp; Li, J. (2021). Local climate and biodiversity affect the stability of China&#8217;s grasslands in response to drought. Science of the Total Environment, 768, 145482.</li> <li>[5] Prugh, L., Deguines, N., Grinath, J., Suding, K., Bean, W., Stafford, R., &amp; Brashares, J. (2018). Ecological winners and losers of extreme drought in California. Nature Climate Change, 8(9), 819–824.</li> <li>[6] Spinoni, J., Naumann, G., Carrao, H., Barbosa, P., &amp; Vogt, J. (2014). World drought frequency, duration, and severity for 1951–2010. International Journal of Climatology, 34(8), 2792–2804.</li> <li>[7] Zvereva, E., Toivonen, E., &amp; Kozlov, M. (2008). Changes in species richness of vascular plants under the impact of air pollution: a global perspective. Global Ecology and Biogeography, 17(3), 305–319.</li> <li>[8] Lazzaro, L., Bolpagni, R., Buffa, G., Gentili, R., Lonati, M., Stinca, A., Acosta, A., Adorni, M., Aleffi, M., Allegrezza, M., &amp; others (2020). Impact of invasive alien plants on native plant communities and Natura 2000 habitats: State of the art, gap analysis and perspectives in Italy. Journal of Environmental Management, 274, 111140.</li> <li>[9] Wang, J., Wang, W., Li, J., Feng, Y., Wu, B., &amp; Lu, Q. (2017). Biogeographic patterns and environmental interpretation of plant species richness in desert regions of Northwest China. Biodiversity Science, 25(11), 1192.</li> </ul>",
    "publishDate": "2023-02-20T16:00:26.000Z",
    "modifiedDate": "2023-12-20T12:16:14.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 380,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-scaled-e1706177571866.jpg",
      "alt": "",
      "title": "IMG_20230726_125902",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-scaled-e1706177571866.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-300x169.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"169\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-300x169.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-300x169.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-1024x576.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2023/02/IMG_20230726_125902-scaled-e1706177571866.jpg"
      },
      "width": 778,
      "height": 438,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2023/02/how-many-plants-can-hit-a-drought-one-or-two-more/",
    "wordCount": 7943,
    "readingTime": 40,
    "seo": {
      "title": "【MCM / 2023 A题】How many plants can hit a drought? One or two more?",
      "description": "<p>Abstract &quot;Global temperatures are warming, glacier [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2023/02/how-many-plants-can-hit-a-drought-one-or-two-more/"
    }
  },
  {
    "id": "204",
    "title": "【年度总结】再也不见！2022！",
    "slug": "2022-end-year-of-mix",
    "excerpt": "<p>我在这里，你在那里，我们的距离，是一年的距离。 “写点什么吧，总结一下这一过去的2022年。” 我躺在床上，想 [&hellip;]</p>",
    "content": "<p>我在这里，你在那里，我们的距离，是一年的距离。</p> <p>“写点什么吧，总结一下这一过去的2022年。”</p> <p>我躺在床上，想了想，这一年，我做了很多事情，也遇到了很多人。</p> <p>记忆很快模糊了起来，那是2022年的元旦。</p> <p>我们相互暧昧地在甜蜜的问候中迎接来了2022年，此时距离2022年高考还有158天，我们都很幸福且美好。</p> <p>我们在拥抱中度过了在一起的第一年，在焰火中尽享温暖，此时距离2022年高考还有113天，我们都很幸福且美好。</p> <hr /> <blockquote> <p>子弹划过红玫瑰，英雄也曾掉眼泪</p> </blockquote> <p>春日的夕阳照耀山头，一位男孩手擎一面大旗，冲下了山头，此时距离2022年高考还有50天，我尝试变得美好。</p> <p>英雄总会落幕，故事总有结局</p> <p>都说毕业季是一个分别的季节，在一起的日子也是如此。</p> <p>既匆匆忙忙，又晕头转向。</p> <p>匆匆忙忙地结束了人生中最重要的考试。</p> <p>匆匆忙忙地为自己的高中生活画上了一个句号。</p> <p>匆匆忙忙地选择了一个陌生的城市，一所陌生的大学。</p> <p>匆匆忙忙的结束了一段美好的时光，晕头转向的是未来的路。</p> <p>午夜的钟声响起，我在窗前，望着远方的星空，想着你。</p> <hr /> <p>结束了？</p> <p>结束了，是的。</p> <p>虽然度过了一个糟糕的高中生活。</p> <p>虽然有很多不开心的事情。</p> <p>虽然路过了很多地方，却没有留下足迹。</p> <p>虽然失去了很多，得到的却很少。</p> <p>但是，我还是足够幸运。</p> <p>我足够幸运，我还有许多默默支持我的人，</p> <p>我足够幸运，我遇到了许多值得珍惜的人，</p> <p>我足够幸运，我们生活在一个充满机遇的时代，</p> <p>我足够幸运，我还有无数的风景没有看。</p> <p>我望向窗外，华灯初上，万家灯火通明，一片祥和之景。</p> <p>我在这里，你在那里，我们的距离，是一年的距离。</p> <p><strong><em>你好，2023！</em></strong></p> <p><strong><em>再见，2022！</em></strong></p> <h1><strong>🎉🧨2023新年快乐🧨🎉</strong></h1>",
    "publishDate": "2022-12-31T16:00:12.000Z",
    "modifiedDate": "2023-07-25T18:55:12.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 319,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-e1706177555198.jpg",
      "alt": "",
      "title": "2022",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-e1706177555198.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-300x169.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"169\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-300x169.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-300x169.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-1024x576.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2023/01/2022-e1706177555198.jpg"
      },
      "width": 778,
      "height": 438,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2023/01/2022-end-year-of-mix/",
    "wordCount": 38,
    "readingTime": 1,
    "seo": {
      "title": "【年度总结】再也不见！2022！",
      "description": "<p>我在这里，你在那里，我们的距离，是一年的距离。 “写点什么吧，总结一下这一过去的2022年。” 我躺在床上，想 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2023/01/2022-end-year-of-mix/"
    }
  },
  {
    "id": "242",
    "title": "【文献检索】边缘计算技术及应用综述【杂谈】",
    "slug": "a-review-of-technology-and-application-on-edge-computing",
    "excerpt": "<p>引言 随着智能化社会的发展和人们对于美好生活的需求的不断提高，智能化设备已经融入到人们生活的方方面面中。与此同 [&hellip;]</p>",
    "content": "<h2>引言</h2> <p>随着智能化社会的发展和人们对于美好生活的需求的不断提高，智能化设备已经融入到人们生活的方方面面中。与此同时，随着万物互联（Internet of Everything，IoE）的快速发展，越来越多的智能设备需要接入互联网连接。根据思科在Cisco Annual Internet Report中提到的数据[1]：到2023年，全球将近三分之二的人口可以上网，互联网用户总数将达到53亿（占全球人口的66%），高于2018年的39亿（占全球人口的51%），人均联网设备数量将从2018年的2.4台增加到3.6台，联网设备将达到293亿台，高于2018年的184亿。[1]互联网数据中心（Internet Data Center ，IDC）统计显示，到2020年，连接到网络的终端和设备数量将超过500亿，2020年全球数据总量也将超过40ZB。[2]</p> <p>施魏松等人定义的边缘计算是指在网络边缘执行计算的一种新型计算模型，边缘计算中边缘的下行数据表示云服务，上行数据表示万物互联服务，而边缘计算的边缘是指从数据源到云计算中心路径之间的任意计算和网络资源[3]。边缘计算将计算和数据存储转移到网络边缘，这样就可以对数据进行实时数据处理和分析。边缘计算减少了对远程中心数据中心的依赖，使系统能够更快地响应用户请求。</p> <h2>边缘计算概述</h2> <h3>产生背景</h3> <p>21世纪，信息与数据的爆炸式增长使得传统的服务方式无法应对，即将计算机服务器部署在本地，用户通过网络访问服务器，从而获取所需的服务，因此催生了云计算的繁荣发展。云计算使用互联网来提供动态扩展的计算资源，包括计算机、存储和网络资源。用户可以按需访问这些资源，而无需管理基础架构，这样就可以灵活地响应业务需求。但由于云服务和终端用户之间始终存在着物理距离和延迟的限制，云计算面临着以下方面的问题。</p> <ol> <li>网络带宽：不论是将本地的数据通过网络上传到云端中计算，还是将云端中的数据下载到本机进行处理，都需要和远程数据中心进行数据，这就需要足够的网络带宽。如果网络带宽不足，云计算的性能可能会受到影响。同时，如果网络连接中断或不稳定，云计算的服务可能会受到影响。</li> <li>网络延迟：在存在大量设备访问云服务时，同时也有大量的数据需要传输到云端进行处理。大量数据在链路中传输不但会占据大量的带宽，导致网络负荷增大，数据传输也会延迟。在一些对实时性要求很高的应用场景中，如监控设备等，云计算所产生的延迟无法满足业务的实时性要求。</li> <li>能源消耗：边缘计算将计算资源部署在网络边缘，这样就可以减少数据传输的距离，降低能源消耗。例如，在工业自动化领域，边缘计算可以将计算资源部署在工厂内，这样就可以减少对远程数据中心的依赖，降低能源消耗。</li> <li>设备成本：边缘计算可以使用低成本的设备，因为它们只需要处理本地的数据。在物联网领域，边缘计算可以使用低成本的传感器和边缘设备，而无需投资昂贵的服务。</li> <li>隐私安全：边缘计算可以提供更高的隐私和安全性，因为数据不需要传输到远程数据中心。例如，在智能手机中使用各种应用程序时，应用程序需要将用户隐私数据上传到云计算中心时，这样可能存在隐私泄露或被攻击的风险。</li> </ol> <h3>发展历程</h3> <h4>内容分发网络</h4> <p>“边缘计算”的概念最早可以追溯到1999年Akamai公司设计从网络边缘提供请求的代理服务器。[4]这个边缘计算的“雏形”最初时用来分发图片和文件，后来逐渐发展为从网络边缘动态生成网页或者提供应用程序给用户，同时也给用户提供了需要的带宽和计算能力，这便是内容分发网络技术（Content Delivery Network，CDN）的由来。CDN是一种基于互联网的缓存网络，依靠部署在各地的缓存服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，将用户的访问指向距离最近的缓存服务器上，以此降低网络拥塞，提高用户访问响应速度和命中率。[5]</p> <h4>云计算</h4> <p>根据美国国家标准技术研究所（National Institute of Standards and Technology，NIST）的定义，云计算是一种实现无处不在的、方便的、按需网络访问的可配置计算资源（如网络、服务器、存储、应用和服务）共享池的模式，可以通过最小的管理开销或服务提供商的交际来快速配置和释放。[6]云计算提供了一种使用计算资源的灵活方式，可以根据需求来扩展或缩减计算资源。云计算提供了许多优势，包括：</p> <ol> <li>灵活性：云计算允许用户根据需求来扩展或缩减计算资源，因此可以更加灵活地适应业务发展。</li> <li>成本效益：云计算可以节省传统计算架构中的硬件和软件成本，并提供按需付费的模式，因此可以较低的成本使用计算资源。</li> <li>可用性：云计算提供了高可用性的服务，可以提供99.99% 的服务级别协议（SLA），这意味着系统的可用性高达99.99%。</li> <li>可移植性：云计算可以跨越多个平台和操作系统，因此可以方便地将应用程序移植到不同的环境中。</li> <li>安全性：云计算提供了高水平的安全性，通常会使用多种技术来保护数据，包括加密、身份验证、安全隔离和审计等。此外，云计算还提供了多种备份和恢复机制，以确保数据安全。</li> </ol> <p>尽管云计算有着许多优势，但是它也存在一些缺点，包括网络依赖性、隐私和安全问题、合规性问题、成本问题和可移植性问题等。</p> <h4>Cloudlet</h4> <p>小云（Cloudlet）一词最早由卡内基梅隆大学的Satyanarayanan教授在论文中提出，Cloudlet是一个可信的、资源丰富的计算机或计算机集群，有着良好的互联网连接，可供附近的移动设备使用。[7]Cloudlet是在云计算和移动计算之间提供一个中间层的技术，旨在解决移动计算设备的低带宽、高延迟和高能耗等问题。使用Cloudlet还可以简化满足多个用户互动生成和接收媒体（如高清视频和高分辨率图像）的峰值带宽需求。把云服务器的计算迁移到靠近用户的Cloudlet上，通过移动终端与Cloudlet的近距离交互降低网络时延并提高服务质量。[8] Cloudlet可以被比喻成“盒子里的数据中心”，即运行一个能够通过WLAN网络实时向终端设备和用户提供资源的虚拟机。Cloudlet通过高带宽的单跳访问提供服务，因此为应用程序提供了低延迟服务。[9]尽管Cloudlet在解决通信延迟方面取得了成功，但移动的用户仍然是Cloudlet面临的最大挑战。[12]</p> <p>Verbelen T等人将Cloudlet分为三个层次：组件层、节点层和Cloudlet层。[10]组件层通过向执行环境忽略的高层提供接口来提供一组服务。一个或多个运行在操作系统之上的执行环境形成一个节点，由节点代理管理。一组位于同一位置的节点组成了由Cloudlet代理管理的Cloudlet层。[9]</p> <h4>雾计算</h4> <p>雾计算（Fog Computing）一词最早由思科在2012年提出[11],雾计算是指将云计算技术扩展到网络边缘的分布式计算模式。“雾”指的是一种分散的计算范式，通过充当传统云和物联网最终用户之间的中间层，将云服务扩展到更接近物联网设备的地方。[12]在雾计算中，服务可以托管在终端设备上，如机顶盒或接入点。这种新型分布式计算的基础设施允许应用程序尽可能接近可感知的可操作的大量数据，这些数据来自于人、流程和事物。这样的雾计算概念，实际上是一种接近“地面”的云计算，创造了驱动价值的自动响应。[15]雾计算最大限度地缩短了受支持应用程序的请求响应时间，并为终端设备提供本地计算资源，并在需要时提供到集中式服务的网络连接。此外，雾计算不是边缘计算的同义词，但它是边缘计算的一部分。[13]</p> <h4>Ad-Hoc Cloud</h4> <p>Ad-Hoc Cloud，又被称之为“临时云”，在此模型上，基础设施软件分布在已经在使用的机器上收集的资源上。在此之前，现有的云基础设施主要基于数据中心，可用资源是充分已知的。[14]所谓“临时”，指的是组成云的机器的集合是动态变化的，每台机器的计算资源和存储资源在给定时间点上的比例也是动态变化的。因此，与数据中心云模型相比，资源供应级别不是预先建立的，资源在使用时也不是专门提交给云的。[16]Ad-Hoc 云可以从现有的、非专用和不可靠的（即非专用于计算的设备）边缘基础设施中获取计算资源。[17]</p> <p>Ad-Hoc云是一种革命性的范式，通过涉及网络交付计算等服务，具有高效利用云资源和改进可管理性的优点。[12]研究表明，在多种能力（如计算能力）下的Ad-Hoc云策略优于传统云服务器。具有更高的任务完成率，以及对各种物联网设备的利用率更高，完成时间更短。[18]然而，由于移动设备的便携性的显著特征使得其在Ad-Hoc云中带来了较大的影响，对参与其中的“设备——设备”和“设备——云”的通信组合的连接有较大的影响。因此，临时云的特性，如设备的异构性等，仍然在资源管理、路由、安全和隐私方面带来了更大的挑战。</p> <h4>移动边缘计算</h4> <p>在我们的日常生活中有着大量的移动设备，并且这些小型移动设备已经越来越流行，如：智能手机、智能平板。虽然它们有着相对可观的性能，但它们的使用率不到25%。[19]因此，研究人员提出了通过集成移动设备来构建云基础设施，同时，这些移动设备可以同时作为云服务的客户和提供商。</p> <p>为了演示物联网生物医学传感器向最终用户提供高级应用程序的可用性，Mora等人提出了一个基于物联网的医疗保健计算框架，用于监测涉及体力的运动。[20]他们在足球比赛期间监测了足球运动员的心率，强调了可穿戴设备在运动员移动中的优点，因为这种物联网设备支持在边缘处实时处理物联网数据的多种通信标准(如蓝牙和WLAN)。因此，移动设备的开发进一步加强了边缘计算中连接附近计算资源的思想。与传统的集中式云相比，协作移动设备可以更好地满足物联网应用程序的需求(如低延迟)。</p> <p>在这种背景下，学术界已经提出了几个移动云平台来产生最有希望的边缘结果，例如GEMCloud[21]、NativeBOINC[22]、Hyrax[23]和MobiCOP[24]。然而，能源是利用移动设备作为计算资源基础设施所面临的挑战之一，因为移动设备只使用它们的自带的电池来提供服务。另一个问题是建设云基础设施的设备数量，使得大量的移动设备得以完成大型计算任务。因此，当前的问题是如何保证移动云设备的可协作性和可持续性，从而达到最优的计算性能。</p> <h2>基本架构</h2> <h3>边缘计算通用架构</h3> <p>边缘计算架构是一种联邦网络结构，通过在终端设备和云计算之间引入边缘设备，将云服务扩展到网络边缘。[12][25]</p> <p>边缘计算架构一般可分为终端层、边缘层和云计算层。[2]各层可以进行层间及跨层通信，各层的组成决定了层级的计算和存储能力，从而决定了各个层级的功能。下面将简要介绍边缘计算架构中各层的组成和功能。</p> <ol> <li>终端层：终端层由各式各样不同大小的物联网设备（如传感器、射频识别（Radio-frequency identification，RFID）标签、摄像头、智能手机、智能汽车等）组成。在终端层，物联网设备不仅是数据的消费者，也是数据的提供者。为了减少终端服务延迟，我们通常只考虑各种终端设备的感知功能，而不考虑它们的计算能力。因此，终端层数以亿计的设备将收集各种原始数据，并上传到边缘层进行存储和计算。</li> <li>边缘层：边缘层是三层架构的核心。它位于网络的边缘，由广泛分布在终端设备和云之间的边缘节点组成。它通常包括基站、接入点、路由器、交换机、网关等。边缘层同样也可以是智能终端设备本身，例如智能手机既能够从世界中手机数据，同时也有相对强大的计算和储存能力。同时，边缘层支持终端设备下行访问，存储和计算终端设备上传的数据。并且可以连接云层，将处理后的数据上传到云服务中。[26]由于边缘层离用户较近，因此向边缘层传输的数据更适合进行实时数据分析和智能处理，比云计算更高效、更安全。同时，边缘计算层通过合理部署和调配网络边缘侧的计算和存储能力，可以实现基础服务响应。</li> <li>云计算层：在以云计算为中心的云边缘计算联邦服务中，云计算仍然是最强大的数据处理中心。云计算层由多个高性能服务器和存储设备组成，具有强大的计算和存储能力，在日常维护和业务决策支持等需要大量数据分析的领域可以很好地发挥作用。云计算中心可以永久存储边缘计算层上报的数据，也可以完成边缘计算层无法处理的分析任务和整合全局信息的处理任务。此外，云模块还可以根据控制策略动态调整边缘计算层的部署策略和算法。</li> </ol> <h3>边缘计算参考架构3.0</h3> <p>2018年12月，主要由华为、中国科学院沈阳自动化研究所、中国信息通信研究院等知名企业联合发起的边缘计算产业联盟（Edge Computing Consortium，ECC）发布了边缘计算白皮书3.0，并提出了边缘计算参考架构3.0。参考框架是基于模型驱动的工程方法。为了对物理世界和数字世界的知识进行建模，我们需要实现以下四个目标：</p> <ol> <li>建立实时、系统的物理世界认知模型，实现物理世界与数字世界的协同；</li> <li>基于建模方法，建立各垂直行业可重用的知识模型系统，完成跨行业生态合作；</li> <li>系统对系统、服务对服务等基于模型的接口进行交互，实现软件接口与开发语言的解耦，减少系统异构性；</li> <li>能有效支持开发服务、部署运营、数据处理和安全的生命周期。</li> </ol> <p>ECC边缘计算参考架构以多视图的方式从不同角度呈现架构内容，并通过多层功能透视图展示每一层的功能。边缘引用框架有一个连接整个框架的底层服务层，包括管理服务、数据生命周期服务和安全服务。管理服务提供统一的管理，监视体系结构的操作，并向管理平台提供信息。数据生命周期服务为机器数据的预处理、分析、分发和执行以及可视化和存储提供集成管理。安全服务可以通过业务编排层定义数据全生命周期的业务逻辑，灵活部署和优化数据服务，满足业务的实时性要求。安全服务覆盖边缘计算架构的各个层次，适应边缘计算的具体架构，利用统一的安全管理和感知系统，保证整个架构的安全可靠运行。[2]</p> <p>从垂直结构来看，模型驱动的统一服务框架位于规模的顶端，实现服务的开发和部署。根据边缘计算的一般框架，将边缘计算分为云、边缘层和场层。边缘层由两个主要部分组成：边缘节点和边缘管理器。边缘节点是能够承载边缘计算业务的实体硬件。边缘管理器主要通过软件对边缘节点进行统一管理。根据硬件特点和业务类型，将边缘计算节点分为处理和转换网络协议的边缘网关、控制实时闭环业务的边缘控制器、处理大规模数据的边缘云、收集和处理低成本信息的边缘。传感器等可以将边缘计算层的设备抽象为计算、组网和存储。接下来，使用应用程序编程接口（Application Programming Interface，API）实现通用功能调用。控制、分析和优化域功能模块用于实现上下两层的信息传递和局部边缘资源的规划。边缘计算参考架构3.0提供了从终端到云的四种业务开发框架，包括轻量级计算系统、实时计算系统、智能分布式系统和智能网关系统。</p> <h3>EdgeX FOUNDRY架构</h3> <p>EdgeX Foundry是一个由Linux基金会托管的开源项目[28]，同时也是一个用于物联网边缘计算的通用开放框架。该框架托管在一个完全独立于硬件和操作系统的参考软件平台上，支持即插即用组件生态系统，以统一物联网边缘的计算开放平台，并加速解决方案的部署。</p> <p>EdgeX的“下端”包含了所有可以直接与边缘网络通信的物联网应用设备，“上端”则包括云计算中心以及与云计算中心的通信网络。“下端”是数据的来源，“上端”用于收集“下端”的数据，并对数据进行存储、整合和分析。EdgeX Foundry位于上下之间，由一组微服务组成，这些微服务分为四个服务层和两个底层增强的系统服务。</p> <p>从纵向看，使用设备服务层提供的软件开发工具包（Software Development Kit，SDK）与“上端”建立通信链路。设备服务层对来自设备的数据进行转换，并将其发送到核心服务层。它还可以接收来自其他微服务的命令，并将它们传递给设备。EdgeX Foundry包括多种访问方法，如消息队列遥测传输协议（Message Queuing Telemetry Transport，MQTT）、虚拟设备和蓝牙低能耗（Bluetooth Low Energy，BLE）。作为中心的核心服务层，是实现边缘能力的关键。核心服务层由四个微服务组件组成:核心数据、命令、元数据、注册表和配置。核心数据服务为设备数据提供存储和管理服务。命令服务负责将设备文件中的操作命令定义为通用API，并对命令进行缓存和管理，可以将云计算中心的需求传递给设备端。元数据为设备和服务提供配对。注册和配置服务为其他微服务提供配置信息。支持服务层用于提供边缘分析和智能服务，并为框架本身提供规则引擎、调度、警报和日志服务。应用和导出服务层可与云计算中心连接，向云计算中心传输数据，保证EdgeX Foundry的独立运营。在导出服务层，客户端注册服务记录后端注册系统的相关信息，分发服务将相应的数据导出到指定的客户端。</p> <p>与边缘计算参考体系结构3.0类似，EdgeX Foundry框架也有一个贯穿整个框架的基本服务层——管理服务和安全服务。管理服务提供安装、升级、启动、停止和监视EdgeX Foundry操作等功能。安全服务中的组件用于保护数据不受设备和设备操作的影响。</p> <p>开发EdgeX Foundry框架是为了简化和标准化工业物联网的边缘计算。它提供了一个可操作的开源平台，所有微服务都可以以容器的形式运行在各种操作系统上，支持动态增减功能，具有较强的可扩展性。目前，EdgeX Foundry的应用领域已涉及零售、制造业[29]、能源[30]、城市公园、交通[31]等多个行业。</p> <h2>研究热点</h2> <h3>计算卸载</h3> <p>计算卸载是指资源受限的设备，将资源密集型的计算部分或全部从移动设备迁移到附近资源丰富的基础设施上，以解决移动设备在资源存储、计算性能和能效方面的不足。[32]在计算卸载中，移动设备将其部分计算任务迁移到云端。这个过程包括应用程序分区、卸载决策和分布式任务执行。计算卸载技术不仅降低了核心网的压力，还减少了传输造成的延迟。移动边缘计算可以在用户设备上运行新的复杂应用，计算卸载是边缘计算的关键技术。目前的相关的研究成果很多，主要包括两个主要问题：卸载决策和资源配置。[33]</p> <p>卸载决策讨论的是关于如何卸载计算任务、卸载多少计算任务以及为移动设备卸载什么计算任务，而资源配置是研究在哪里卸载资源。</p> <h3>移动管理</h3> <p>边缘计算依靠计算资源的地理性分布来支持应用程序的空间性移动，并且一个计算节点只能为一定区域内的用户服务。云计算通过固定服务器的位置，并通过网络将数据传输到服务器，以支持应用的空间性移动。因此，边缘计算中应用的移动管理是一种新的模式，涉及的主要问题有资源发现和资源切换。</p> <p>资源发现，即用户需要快速发现周围可用的资源，并在移动过程中选择最适合的资源。边缘计算的资源发现需要适应异构资源环境，也需要保证资源发现的速度，使应用能够不间断地向用户提供服务；资源切换，即用户移动时，移动应用所使用的计算资源可能在多台设备之间切换[34]。资源切换将迁移业务程序的运行站点，以保证业务的连续性。</p> <p>在移动边缘计算中，需要考虑的关键问题之一是如何确保用户在移动过程中获得服务的连续性。一些应用程序希望在更改位置后继续为用户提供服务。边缘计算资源的异构性和网络的多样性要求迁移过程中设备的自适应计算能力和网络带宽的变化。文章[35]通过预测用户移动进一步优化了虚拟机迁移策略，提出了一种基于移动性的服务迁移预测方案（Mobility based Service Migration Prediction，MSMP），该方案在成本和服务质量（Quality of Service，QoS）之间进行了折衷。</p> <h2>应用场景</h2> <h3>云计算服务</h3> <p>在计算量大的云场景中，可能在同一时间内就有数以千万级的设备同时访问云服务。如在大型网上交易平台，同一时间就有大量的用户对某种商品的信息进行请求访问。边缘计算中的云计算服务可以通过在边缘设备上进行计算来实现边缘计算，从而提高计算效率。可以将计算任务放在网络边缘进行，既降低了网络延迟，又减轻了云服务器的负担。目前，使用移动客户端网购变得流行，因此缩短响应延时，改善用户体验的需求日益增加。[3]</p> <h3>视频监控</h3> <p>传统的视频监控的摄像头由于其内置计算能力较低，无法完成复杂的计算工作，只能进行录制工作并把录像上传到云端进行处理。我国公安机关部署的“天网”监控系统通过在公共区域部署的大量摄像头维持稳定、安全的社会秩序，许多家庭也主动使用家用摄像头、宠物监视器等保障房屋、家庭成员的安全。最初人们只能用人工的方式处理图像信息，然而这种方式往往具有很长的时延和波动的准确率。[36]运用边缘计算与人工智能结合，在摄像头边缘进行计算，可以最大程度上避免网络波动所带来的影响。</p> <h3>智能家居</h3> <p>家居生活随着万物互联应用的普及变得越来越智能和便利，如智能照明控制系统、智能电视、智能机器人等．然而，在智能设备中，仅通过一种WiFi模块连接到云计算中心的做法，远远不能满足智能家居的需求。智能家居环境中，除了联网设备外，廉价的无线传感器和控制器应部署到房间、管道、地板和墙壁等，出于数据传输负载和数据隐私的考虑，这些敏感数据的处理应在家庭范围内完成。[3]以家庭为中心的边缘计算服务能够将这些敏感数据最大程度的保护在本地，从而一定程度上避免隐私数据的泄露。</p> <h3>智慧交通</h3> <p>智能交通是解决城市居民面临的出行问题，如恶劣的交通现状、拥塞的路面条件、贫乏的停车场地、窘迫的公共交通能力等。智能交通控制系统实时分析由监控摄像头和传感器收集的数据，并自动做出决策。这些传感器模块用于判断目标物体的距离和速度等。随着交通数据量的增加，用户对交通信息的实时性需求也在提高，若传输这些数据到云计算中心，将造成带宽浪费和延时等待，也不能优化基于位置识别的服务。在边缘服务器上运行智能交通控制系统来实时分析数据，根据路面的实况，利用智能交通信号灯减轻路面车辆拥堵状况或改变行车路线。同样，智能停车系统可收集用户周围环境的信息，在网络边缘分析用户附近的可用资源，并给出指示。</p> <h2>面临挑战</h2> <h3>可编程性</h3> <p>对于边缘计算方案，拥有易上手的编程模型可以是开发者更加快速上手开发应用产品，从而推动领域的发展。云计算模型中，用户编写应用程序并将其部署到云端。而云服务提供商则负责维护云计算服务器，用户对程序运行完全不知或知之较少。边缘计算模型中，部分或全部的计算任务从云端迁移到边缘节点，而边缘节点大多是异构平台，每个节点上的运行时环境可能有所差异，因此，在边缘计算模型下部署用户应用程序时，程序员将遇到较大的困难。</p> <h3>命名服务</h3> <p>边缘计算模型中一个重要假设是边缘设备的数目巨大。边缘节点平台上运行多种应用程序，每个应用程序提供特定功能的服务。与计算机系统的命名规则类似，边缘计算的命名规则对编程、寻址、识别和数据通信具有非常重要的作用，而当前暂无较为高效的命名规则。为了实现系统中异构设备间的通信，边缘计算研究者需要学习多种网络和通信协议。此外，边缘计算的命名规则需要满足移动设备、高度动态的网络拓扑结构、隐私安全等需求。传统的命名机制如域名服务器（Domain Name Server，DNS）、统一资源标志符（Universal Resource Locator，URL）满足大多数的网络结构，但却不能灵活地为动态边缘网络提供服务，原因在于大多数的边缘设备具有高度移动性和有限资源，而对于该类边缘设备而言，基于IP的命名规则，因复杂性和开销太大而难以应用到边缘计算中。</p> <h3>服务管理</h3> <p>边缘计算资源分散在数据的传输路径上，被不同的主体所管理和控制，比如用户控制终端设备、网络运营商控制通信基站、网络基础设施提供商控制路由器、应用服务供应商控制边缘服务器与内容传输网络。云计算中的资源都是集中式的管理，因此云计算的资源管理方式并不适用管理边缘计算分散的资源，而目前关于边缘计算的研究也主要集中在对单一主体资源的管理和控制，还未涉及多主体资源的管理。</p> <h3>隐私安全</h3> <p>网络边缘数据计算涉及了大量的个人隐私。虽然边缘数据处理的概念也为数据安全和隐私保护提供了更好的结构化支持，但边缘计算的分布式架构增加了攻击的方向。边缘计算客户端越智能，就越容易受到恶意软件感染和安全漏洞的攻击。现有的数据安全保护方法并不完全适用于边缘计算架构。此外，网络边缘的高度动态环境也使网络更加脆弱和难以保护。边缘计算中的数据安全和隐私保护面临四个新挑战：</p> <ol> <li>边缘计算对轻量级数据加密和基于多方授权的细粒度数据共享的新要求。由于边缘计算是一种将多个信任域以授权实体作为信任中心的计算模式，传统的数据加密和共享策略已不再适用。因此，设计一种适用于多个授权中心的数据加密方法就显得尤为重要。同时，也要考虑算法的复杂度。</li> <li>分布式计算环境下多源异构数据传播控制与安全管理问题。用户或数据所有者希望能够使用有效的信息传播控制和访问控制机制来实现数据的分发、搜索、访问和数据授权范围的控制。此外，由于数据的外包性质，其所有权和控制权是相互分离的，因此有效的审计验证方案可以确保数据的完整性。</li> <li>边缘计算大规模互联服务与资源受限终端之间的安全挑战。由于边缘计算的多源数据融合特性，移动网络和互联网网络的叠加，以及边缘终端存储、计算、电池容量等资源的限制，传统的和更复杂的加密算法、访问控制措施、身份认证协议和隐私保护方法无法应用于边缘计算。</li> <li>物联网服务多元化，边缘计算模式对高效隐私保护提出新要求。除了需要设计有效的数据、位置和身份隐私保护方案外，如何将传统隐私保护方案与边缘计算环境中的边缘数据处理特点相结合，实现多样化服务环境下的用户隐私保护是未来的研究趋势。</li> </ol> <p>目前，关于边缘计算安全和隐私保护的研究还处于起步阶段，现有的研究成果相对较少。其中，真正可行的研究思路是将其他相关领域的现有安全技术移植到边缘计算环境中。国内外学者对移动云计算及其安全性进行了深入研究。Roman等人[37]对几种常见的移动边缘范式进行了安全性分析，阐述了一种通用的协同安全保护系统，并给出了研究意见。这些工作为边缘计算的安全性研究提供了理论参考。</p> <h2>总结</h2> <p>随着物联网行业的不断发展，新一轮的科技革命很快就会到来。边缘计算有这它能承受海量数据传输、实时服务响应的优点，为学术界各种问题提供了行之有效的解决方案而受到了国内外学者的关注和认可。以边缘计算为主题的论文和会议也在连年增多。[5]</p> <p>本文首先从边缘计算的概念入手，介绍了边缘计算的产生背景，初步介绍了边缘计算的理论来源与基础——云计算。详细说明了云计算目前存在的四点不足之处，并指出了边缘计算的发展由来。</p> <p>在完成以上内容后，本文详细介绍了边缘计算的基本架构。从边缘计算通用架构开始，进一步深入由ECC联盟提出的边缘计算参考架构3.0，接着介绍了目前由Linux基金会托管的EdgeX FOUNDRY架构。详细介绍了以上架构的组成、优缺点，和未来的发展方向。</p> <p>最后分别从研究热点、应用场景、面临挑战三个层次，分开介绍了当前环境下学术界在对边缘计算的研究方向，已经目前已经存在的边缘计算的使用场景，已经未来边缘计算未来可能的发展方向。</p> <p>边缘计算自从正式提出以来，虽然有着几十年的历史，但是在最近的十年内却取得了爆炸性的增长。笔者相信，以此趋势，边缘计算将会在工业、交通、文化、军事等方面有着更加深远的影响与推动作用。</p> <h2>参考文献</h2> <ul> <li>[1] Cisco Annual Internet Report (2018–2023) White Paper [EB/OL]. [2022-12-23]. <a href=\"https://www.cisco.com/c/en/us/solutions/collateral/executive-perspectives/annual-internet-report/white-paper-c11-741490.html\">https://www.cisco.com/c/en/us/solutions/collateral/executive-perspectives/annual-internet-report/white-paper-c11-741490.html</a>.</li> <li>[2] Cao K, Liu Y, Meng G, et al. An Overview on Edge Computing Research[J]. IEEE Access, 2020,8:85714-85728.</li> <li>[3] 施巍松, 孙辉, 曹杰, 等. 边缘计算:万物互联时代新型计算模型[J]. 计算机研究与发展, 2017,54(05):907-924.</li> <li>[4] Dilley J, Maggs B, Parikh J, et al. Globally distributed content delivery[J]. IEEE internet computing, 2002,6(5):50-58.</li> <li>[5] 施巍松, 张星洲, 王一帆, 等. 边缘计算:现状与展望[J]. 计算机研究与发展, 2019,56(01):69-89.</li> <li>[6] Mell P, Grance T. The NIST definition of cloud computing[Z]. Special Publication (NIST SP), National Institute of Standards and Technology, Gaithersburg, MD, 2011.</li> <li>[7] M. S, P. B, R. C, et al. The Case for VM-Based Cloudlets in Mobile Computing[J]. IEEE Pervasive Computing, 2009,8(4):14-23.</li> <li>[8] 赵明. 边缘计算技术及应用综述[J]. 计算机科学, 2020,47(S1):268-272.</li> <li>[9] K. D, S. K D. Comparison of edge computing implementations: Fog computing, cloudlet and mobile edge computing: 2017 Global Internet of Things Summit (GIoTS)[C], 20 &#8211; IEEE, 2017</li> <li>[10] Verbelen T, Simoens P, De Turck F, et al. Cloudlets: Bringing the cloud to the mobile user: Proceedings of the third ACM workshop on Mobile cloud computing and services[C], 2012.</li> <li>[11] Cisco. Cisco Fog Computing Solutions: Unleash the Power of the Internet of Things[EB/OL]. [2022-12-23]. <a href=\"https://www.cisco.com/c/dam/en_us/solutions/trends/iot/docs/computing-solutions.pdf\">https://www.cisco.com/c/dam/en_us/solutions/trends/iot/docs/computing-solutions.pdf</a>.</li> <li>[12] Bangui H, Rakrak S, Raghay S, et al. Moving to the Edge-Cloud-of-Things: Recent Advances and Future Research Directions[J]. Electronics (Basel), 2018,7(11):309.</li> <li>[13] Michaela I, Larry F, Robert B, et al. Fog Computing Conceptual Model[Z]. Special Publication (NIST SP), National Institute of Standards and Technology, Gaithersburg, MD, 2018.</li> <li>[14] Varghese B, Buyya R. Next generation cloud computing: New trends and research directions[J]. Future Generation Computer Systems, 2018,79:849-861.</li> <li>[15] Stojmenovic I, Wen S. The Fog computing paradigm: Scenarios and security issues[C], 20 &#8211; Polish Information Processing Society, 2014.</li> <li>[16] Kirby G, Dearle A, Macdonald A, et al. An approach to ad hoc cloud computing[J]. arXiv preprint arXiv:1002.4738, 2010.</li> <li>[17] G. A M, A. B, M. A. Ad Hoc Cloud Computing: 2015 IEEE 8th International Conference on Cloud Computing[C], 2015.</li> <li>[18] Hasan R, Hossain M, Khan R. Aura: An incentive-driven ad-hoc IoT cloud framework for proximal mobile computation offloading[J]. Future Generation Computer Systems, 2018,86:821-835.</li> <li>[19] Huang D, Zhang X, Kang M, et al. MobiCloud: Building Secure Cloud Framework for Mobile Computing and Communication: 2010 Fifth IEEE International Symposium on Service Oriented System Engineering[C], 20 &#8211; IEEE, 2010.</li> <li>[20] Mora H, Gil D, Terol R M, et al. An IoT-Based Computational Framework for Healthcare Monitoring in Mobile Environments[J]. Sensors, 2017,17(10):2302.</li> <li>[21] Ba H, Heinzelman W, Janssen C, et al. Mobile computing &#8211; A green computing resource: 2013 IEEE Wireless Communications and Networking Conference (WCNC)[C], 20 &#8211; IEEE, 2013.</li> <li>[22] NativeBOINC &#8211; Welcome to NativeBOINC![EB/OL]. [2022-12-28]. <a href=\"http://www.nativeboinc.org/site/uncat/start\">http://www.nativeboinc.org/site/uncat/start</a>.</li> <li>[23] Marinelli E. Cloud computing on mobile devices using MapReduce[D]. Master Thesis Draft, Computer Science Dept., Carnegie Mellon University (CMU), 2009.</li> <li>[24] Benedetto J I, Valenzuela G, Sanabria P, et al. MobiCOP: A Scalable and Reliable Mobile Code Offloading Solution[J]. Wireless Communications and Mobile Computing, 2018,2018:8715294.</li> <li>[25] Ren J, Guo H, Xu C, et al. Serving at the Edge: A Scalable IoT Architecture Based on Transparent Computing[J]. IEEE Network, 2017,31(5):96-105.</li> <li>[26] Shi W, Cao J, Zhang Q, et al. Edge Computing: Vision and Challenges[J]. IEEE Internet of Things Journal, 2016,3(5):637-646.</li> <li>[27] 边缘计算参考架构3.0（2018年） &#8211; 边缘计算产业联盟[EB/OL]. [2022-12-30]. <a href=\"http://www.ecconsortium.org/Lists/show/id/334.html\">http://www.ecconsortium.org/Lists/show/id/334.html</a>.</li> <li>[28] EdgeX Foundry | The Enabled Open Software Platform[EB/OL]. [2022-12-30]. <a href=\"https://www.edgexfoundry.org\">https://www.edgexfoundry.org</a>.</li> <li>[29] C. K M L, Y. Z H, S. Z Z, et al. Design of a Smart Manufacturing System With the Application of Multi-Access Edge Computing and Blockchain Technology[J]. IEEE Access, 2020,8:28659-28667.</li> <li>[30] W. H, F. L, L. W, et al. Research on Distributed Power Distribution Fault Detection Based on Edge Computing[J]. IEEE Access, 2020,8:24643-24652.</li> <li>[31] Barthélemy J, Verstaevel N, Forehead H, et al. Edge-computing video analytics for real-time traffic monitoring in a smart city[J]. Sensors, 2019,19(9):2048.</li> <li>[32] Mach P, Becvar Z. Mobile Edge Computing: A Survey on Architecture and Computation Offloading[J]. IEEE Communications Surveys &amp; Tutorials, 2017,19(3):1628-1656.</li> <li>[33] Zhao J, Li Q, Gong Y, et al. Computation Offloading and Resource Allocation For Cloud Assisted Mobile Edge Computing in Vehicular Networks[J]. IEEE Transactions on Vehicular Technology, 2019,68(8):7944-7956.</li> <li>[34] Wang S. Edge Computing: Applications, State-of-the-Art and Challenges[J]. Advances in Networks, 2019,7(1):8-15.</li> <li>[35] A. N, A. S H, R. B. Mobility prediction model-based service migration procedure for follow me cloud to support QoS and QoE: 2016 IEEE International Conference on Communications (ICC)[C], 2016.2016</li> <li>[36] 李林哲, 周佩雷, 程鹏, 等. 边缘计算的架构、挑战与应用[J]. 大数据, 2019,5(02):3-16.</li> <li>[37] Roman R, Lopez J, Mambo M. Mobile edge computing, Fog et al.: A survey and analysis of security threats and challenges[J]. Future Generation Computer Systems, 2018,78:680-698.</li> </ul>",
    "publishDate": "2022-12-14T16:00:20.000Z",
    "modifiedDate": "2023-07-25T18:52:16.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 317,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-e1706177590937.png",
      "alt": "",
      "title": "TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-e1706177590937.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-300x174.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"174\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-300x174.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-300x174.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-1024x594.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2022/12/TB1cJS2KhjaK1RjSZKzXXXVwXXa-3197-1854-e1706177590937.png"
      },
      "width": 778,
      "height": 451,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "closed",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2022/12/a-review-of-technology-and-application-on-edge-computing/",
    "wordCount": 908,
    "readingTime": 5,
    "seo": {
      "title": "【文献检索】边缘计算技术及应用综述【杂谈】",
      "description": "<p>引言 随着智能化社会的发展和人们对于美好生活的需求的不断提高，智能化设备已经融入到人们生活的方方面面中。与此同 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2022/12/a-review-of-technology-and-application-on-edge-computing/"
    }
  },
  {
    "id": "247",
    "title": "以我辈青年奋进担当 绽中华民族绚丽之花【杂谈】",
    "slug": "value-morality-and-rule-of-law",
    "excerpt": "<p>源源活水，奔涌襄江。青年是整个社会力量中最积极、最有生气的力量，国家的希望在青年，民族的未来在青年。中国青年始 [&hellip;]</p>",
    "content": "<p>源源活水，奔涌襄江。青年是整个社会力量中最积极、最有生气的力量，国家的希望在青年，民族的未来在青年。中国青年始终是实现中华民族伟大复兴的先锋力量。</p> <p>隆中山下，生生不息。习近平总书记曾说：“中国的未来属于青年，中华民族的未来也属于青年。青年一代的理想信念、精神状态、综合素质，是一个国家发展活力的重要体现,也是一个国家核心竞争力的重要因素。”</p> <p>“苟利国家生死以，岂因祸福避趋之。”新时代中国青年应该任劳任怨，在平凡岗位上奋斗奉献。</p> <p>在工厂车间，青年工人苦练本领、精益求精，拧好每个螺丝、焊好每个接头，争当“青年岗位能手”，让“中国制造”走向世界；在田间地头，青年农民寒耕暑耘、精耕细作，用科学技术为粮食增产、为土地增效，努力把中国人的饭碗牢牢端在自己手中；在建筑工地，青年农民工不畏辛劳、日以继夜，用一砖一瓦筑造起一座座高楼大厦，将都市装点得更加美丽；在训练场上，青年健儿刻苦训练、顽强拼搏，以过硬的作风和惊人的毅力向世界顶峰发起冲锋，让五星红旗在国际赛场高高飘扬；在城市的大街小巷，快递小哥、外卖骑手风里来、雨里去，为千家万户传递幸福与温暖，他们用勤劳和汗水生动展现了中国青年“衣食无忧而不忘艰苦、岁月静好而不丢奋斗”的整体风貌，让青春在平凡岗位的奋斗中出彩闪光。</p> <p>鲁迅先生寄语青年，“你们所多的是生力，遇见深林，可以辟成平地的，遇见旷野，可以栽种树木的，遇见沙漠，可以开掘井泉的”。青年是最富生命力、最有创造力的群体，青年是国家的明天、民族的未来。“勇立时代潮头、争做时代先锋”这是对青年的殷切期望，更是青年自身成长、实现价值的必由之路。</p> <p>作为新时代青年大学生，我们应该坚持实践第一、知行合一，求真务实、有为善为的理念，勇于面对实际生活中的各种挫折考验，时刻准备应对各种风险挑战，勤奋刻苦、磨砺意志、脚踏实地、孜孜不倦。</p> <p>“位卑未敢忘忧国，事定犹须待阖棺。”新时代中国青年应该舍我复谁，在急难险重任务中冲锋在前。</p> <p>新冠肺炎疫情发生以来，青年不畏艰险、冲锋在前、舍生忘死，32万余支青年突击队、550余万名青年奋战在医疗救护、交通物流、项目建设等抗疫一线，为打赢疫情防控的人民战争、总体战、阻击战做出重大贡献。援鄂医疗队2.86万名护士中，“80后”、“90后”占90%。在武汉火神山、雷神山医院建设工地上，占总数达60%的青年建设者组建13支青年突击队，靠钢铁般的意志和攻坚克难的勇气，拼搏在前、奉献在前，创造了令世人惊叹的建设奇迹，用事实证明中国青年面对困难挫折撑得住、关键时刻顶得住、风险挑战扛得住。</p> <p>马克思曾说：“一个时代的精神是青年代表的精神，一个时代的性格是青春代表的性格。”梁启超又言：“红日初升，其道大光。河出伏流，一泻汪洋。”从国家民族看，青年都勇挑重担、勇克难关、勇斗风险，中国特色社会主义就能充满活力、充满后劲、充满希望。</p> <p>作为新时代青年大学生，我们应该始终保持昂扬向上的精神状态，富有求新求变的朝气锐气，敢于站在变革前沿，引领潮流之先，守正创新，以新的实践创造更大成就，让中华民族伟大复兴在我们的奋斗中梦想成真。</p> <p>“人生自古谁无死，留取丹心照汗青。”新时代中国青年应该中流砥柱，在创新创业中走在前列。</p> <p>从抗击新冠肺炎疫情的青年志愿者到喊出“清澈的爱，只为中国”的戍边英雄，从孜孜投身航天事业的科研工作者到拨亮乡村教育灯火的支教群体，无数奋进青年以事实和行动向世人说明：“新时代的中国青年是好样的，是堪当大任的！”</p> <p>习近平总书记在党的二十大报告中强调：“全党要把青年工作作为战略性工作来抓，用党的科学理论武装青年，用党的初心使命感召青年，做青年朋友的知心人、青年工作的热心人、青年群众的引路人。”</p> <p>作为新时代青年大学生，我们只有把自己的小我融入祖国的大我、人民的大我之中，与时代同步伐、与人民共命运，感知人民的所思所想所盼，在实践中增长才干、练就本领，以真才实学服务于人民之所需、以创新创造满足人民之所急，将个人的理想与人民的需要紧密结合在一起，青年才能在人生路上走得更正、走得更远，才能在体察世间冷暖、民众忧乐、现实矛盾中找到人生真谛、生命价值和事业方向。</p> <p>“横眉冷对千夫指，俯首甘为孺子牛。”新时代中国青年应该堪当大任，在社会文明建设中引风气之先。</p> <p>无论在城镇还是乡村、企业还是学校，青年都自觉把正确的道德认知、自觉的道德养成、积极的道德实践紧密结合起来，带头倡导向上向善社会风气、塑造社会文明新风尚。在城乡社区建设中，越来越多的青年投身社区治理和服务体系建设，主动参加“社区青春行动”，加强实践锻炼、提升服务贡献。在各行各业，青年秉承“敬业、协作、创优、奉献”的理念，踊跃创建“青年文明号”，大力弘扬新时代职业文明，展现新时代职业形象。</p> <p>作为新时代青年大学生，我们应该锤炼高尚品格，崇德修身，启润青春。只有把正确的道德认知、自觉的道德养成、积极的道德实践结合贯通，自觉树立和践行社会主义核心价值观，崇德修身，夯基固本，才能让青春的航船劈波斩浪、行稳致远。面对变幻时势，要明辨是非、恪守正道，不人云亦云、盲目跟风；面对外部诱惑，应保持定力、严守规矩，用勤劳和诚实创造美好生活，拒绝投机取巧、远离自作聪明；面对幸福生活，应饮水思源、懂得回报，感恩党和国家，感恩社会和人民；面对时代使命，要体察世间冷暖、民众忧乐、现实矛盾，从中找到人生真缔、生命价值、事业方向。</p> <p>鸿鹄展翅凌云志，鹏程万里今朝始。青年强，则国家强。当代中国青年生逢其时，施展才干的舞台无比广阔，实现梦想的前景无比光明。广大青年要坚定不移听党话、跟党走，怀抱梦想又脚踏实地，敢想敢为又善作善成，立志做有理想、敢担当、能吃苦、肯奋斗的新时代好青年，让青春在全面建设社会主义现代化国家的火热实践中绽放绚丽之花。</p> <p><strong>&#8212; Generated by ChatGPT</strong></p>",
    "publishDate": "2022-09-30T16:00:43.000Z",
    "modifiedDate": "2023-07-25T19:04:20.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 324,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-e1706177542381.jpg",
      "alt": "",
      "title": "youth",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-e1706177542381.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-300x188.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"188\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-300x188.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-300x188.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-1024x640.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2022/10/youth-e1706177542381.jpg"
      },
      "width": 778,
      "height": 486,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2022/10/value-morality-and-rule-of-law/",
    "wordCount": 22,
    "readingTime": 1,
    "seo": {
      "title": "以我辈青年奋进担当 绽中华民族绚丽之花【杂谈】",
      "description": "<p>源源活水，奔涌襄江。青年是整个社会力量中最积极、最有生气的力量，国家的希望在青年，民族的未来在青年。中国青年始 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2022/10/value-morality-and-rule-of-law/"
    }
  },
  {
    "id": "121",
    "title": "【教程】如何在VSCode上调试C++程序",
    "slug": "debug-cpp-in-vscode",
    "excerpt": "<p>序言 这篇文章是写给那些，包括书樱在内，对于 VSCode 不太了解，但是又迫切的需要一个比 Visual S [&hellip;]</p>",
    "content": "<h2>序言</h2> <p>这篇文章是写给那些，包括书樱在内，对于 VSCode 不太了解，但是又迫切的需要一个比 Visual Studio 安装和开发更加简便的、想要学习 C++ 的小白。同时，也是献礼给即将在大学进入计算机专业的准大学生。</p> <p>通常我们在学习 C/C++时，第一节课接触的都是<code>Hello World</code>程序，而不是实现这个程序的编译过程。当然，你可以无脑安装 Visual Studio ，因为它是一个帮我们配置好所有配置的 IDE（Integrated Development Environment，集成开发环境）。但是，对于大部分人来说，Visual Studio 可能都过于庞大，因为我们只需要一个简单的编译器，而不需要其背后的其他功能和工具。</p> <p>这也就是书樱写这篇教程的目的，恭喜你，如果你想找一个 Visual Studio 的替代品或者使用一些更“现代”的开发工具。那么你找对地方了，请跟随书樱的脚步，继续往下阅读。</p> <blockquote> <p>这篇文章很大程度上启发自官方文档，部分内容由官方文档指导而来或自官方文档翻译：</p> </blockquote> <ul> <li>Get Started with C++ and MinGW-w64 in Visual Studio Code<a href=\"https://code.visualstudio.com/docs/cpp/config-mingw\" title=\"Get\">[1]</a></li> <li>Debug C++ in Visual Studio Code <a href=\"https://code.visualstudio.com/docs/cpp/cpp-debug\" title=\"Debug\">[2]</a></li> <li>Configure launch.json for C/C++ debugging in Visual Studio Code <a href=\"https://code.visualstudio.com/docs/cpp/launch-json-reference\" title=\"Configure\">[3]</a></li> </ul> <p>这是书樱第一次尝试写教程类的文章，如果有书樱有任何未写清楚或您不懂的地方，欢迎<a href=\"/contact-us\">联系我们</a></p> <p>如果您觉得我写的东西对您有所帮助的话，不妨请我喝杯咖啡。=&gt; <a href=\"/support\" title=\"赞助\">赞助</a></p> <p>话不宜迟，进入正题。</p> <h2>准备</h2> <ul> <li>一台电脑</li> <li>一个稍动脑筋的脑子</li> <li>一颗乐于解决问题的心</li> <li>一个能高速访问国际互联网的网络</li> </ul> <p>接下来，我们来下载我们所需要的东西：</p> <ul> <li>VSCode 或 VSCodium</li> <li>编译器</li> </ul> <h3>什么是 VSCode</h3> <p>Visual Studio Code（简称 VSCode）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全（又称 IntelliSense）、代码重构功能，并且内置了命令行工具和 Git 版本控制系统。用户可以更改主题和键盘快捷方式实现个性化设置，也可以通过内置的扩展程序商店安装扩展以拓展软件功能。<a href=\"https://zh.wikipedia.org/zh-cn/Visual_Studio_Code\" title=\"Visual Studio Code\">[4]</a></p> <p><strong>官网：<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a></strong></p> <p>上面是 VSCode 的官网链接，在中国大陆的下载速度可能会很感人，因此书樱在此更推荐 VSCodium。</p> <h3>什么又是 VSCodium</h3> <p>VSCodium 是 VSCode 的一个开源分支，由一群社区志愿者维护和开发。与 VSCode 相同，二者都是一款免费的文本编辑器，提供了丰富的功能，支持多种编程语言和开发框架。但不同的是，VSCodium 去除了 VSCode 中一些微软特有的功能和服务，比如集成 Azure 和 Live Share 等，因此它更为轻量级和自由，可以给开发人员提供更为自由的使用体验。</p> <p>VSCodium 的功能和 VSCode 相当接近，两者都可以提供类似的开发体验，你可以根据自己的喜好选择使用 VSCode 或 VSCodium。</p> <p><strong>官网：<a href=\"https://vscodium.com/\">https://vscodium.com/</a></strong></p> <p>对于 VSCodium，好在<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站</a>有他对应的镜像。我们可以通过镜像获得更快的下载服务。</p> <p><a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站</a></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309223913.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309223913.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>我该如何选择二者？</h3> <p>VSCode 是由微软开发并维护的，包含了一些微软特有的功能和服务，如集成 Azure 和 Live Share 等。这些功能对于那些需要使用微软产品和服务的开发人员来说，可能会非常有用。</p> <p>VSCodium 去除了 VSCode 中的微软链接，因此它提供了更为自由的使用体验。如果你希望避免使用微软产品和服务，或者希望获得更为轻量级的文本编辑器，那么 VSCodium 可能是一个不错的选择。</p> <p>总而言之，对于没有这方面需求的人来说，二者之间并没有什么区别，如果你访问 VSCode 速度过慢，不妨可以选择 VSCodium。</p> <h3>编译器</h3> <p>编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。它主要的目的是将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序，也就是可执行文件。编译器将原始程序（source program）作为输入，翻译产生使用目标语言（target language）的等价程序。<a href=\"https://zh.wikipedia.org/zh-cn/%E7%B7%A8%E8%AD%AF%E5%99%A8\" title=\"编译器\">[5]</a></p> <p>想要在 VSCode 中调试 C++程序，理所应当的，我们需要 C++ 编译器和 GDB 调试器来创建在 Windows 上运行的程序。</p> <p>常见的 C++ 编译器包括：</p> <ul> <li>GCC：GNU Compiler Collection，由 GNU 项目维护的免费开源 C++ 编译器。</li> <li>Clang：由苹果公司开发的开源 C++ 编译器。</li> <li>Visual C++：微软公司推出的商业 C++ 编译器。</li> <li>Borland C++：Borland 公司推出的商业 C++ 编译器。</li> <li>Turbo C++：Borland 公司推出的商业 C++ 编译器。</li> </ul> <blockquote> <p>选择哪种 C++ 编译器取决于你的需求和喜好。如果对编译器的性能和功能要求不高，可以选择免费开源的编译器，比如 GCC 和 Clang。如果希望获得更高性能和更丰富的功能，可以选择商业编译器，比如 Visual C++ 和 Borland C++。</p> </blockquote> <p>不过对于本文而言，我们选择 GCC 编译器。首先，GCC 有着广泛的社区支持，我们可以通过社区获得帮助和支持；其次， GCC 编译器具有良好的性能和功能，可以帮助我们快速编译 C++ 源代码，并且在编译过程中发现一些语法错误和类型错误等问题。</p> <h3>MSYS2</h3> <p>MSYS2 是一种基于 MinGW-w64 的类 Unix 环境，可以在 Windows 下为开发人员提供一系列工具和库。它包含了一个可以安装和管理软件包的包管理器，并提供了一个可以编译和运行 Unix-like 程序的 shell 环境。</p> <blockquote> <p>MSYS2 is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.<a href=\"https://www.msys2.org/\" title=\"MSYS2\">[6]</a></p> <p>MinGW 的全称是：Minimalist GNU on Windows 。它实际上是将经典的开源 C 语言 编译器 GCC 移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux 平台下的开发工具。一句话来概括：MinGW 就是 GCC 的 Windows 版本 。<a href=\"https://www.jianshu.com/p/d66c2f2e3537\" title=\"MinGW-w64 安装教程\">[7]</a></p> <p>而 MinGW-w64 则是对原始 mingw.org 项目的改进，旨在支持 Windows 系统上的 GCC 编译器。为了提供对 64 位和新 API 的支持，它在 2007 年对其进行了分叉。<a href=\"https://www.mingw-w64.org/\" title=\"MinGW-w64\">[8]</a></p> </blockquote> <p>MSYS2 还提供了一个可以安装和管理软件包的包管理器，可以让我们方便地安装、更新和卸载软件包。它还提供了一个简单易用的命令行界面，可以让开发人员快速访问常用的工具和库，我们需要的 GCC 编译器就在其中。</p> <p>MSYS2 官方有对于该应用的<a href=\"https://www.msys2.org/wiki/MSYS2-installation/\" title=\"MSYS2-Installation\">安装教程</a>，有能力的读者可以自行阅读。</p> <p><strong>官网：<a href=\"https://www.msys2.org/\">https://www.msys2.org/</a></strong></p> <p>以下是 MSYS2 安装程序的 GitHub 仓库：</p> <div class='github-info-card github-info-card-full card shadow-sm' data-author='msys2' data-project='msys2-installer' githubinfo-card-id='5618737918' data-getdata='frontend' data-description='' data-stars='' data-forks=''><div class='github-info-card-header'><a href='https://github.com/' ref='nofollow' target='_blank' title='Github' no-pjax><span><i class='fa fa-github'></i> GitHub</span></a></div><div class='github-info-card-body'> <div class='github-info-card-name-a'> <a href='https://github.com/msys2/msys2-installer' target='_blank' no-pjax> <span class='github-info-card-name'>msys2/msys2-installer</span> </a> </div> <div class='github-info-card-description'></div> </div><div class='github-info-card-bottom'> <span class='github-info-card-meta github-info-card-meta-stars'> <i class='fa fa-star'></i> <span class='github-info-card-stars'></span> </span> <span class='github-info-card-meta github-info-card-meta-forks'> <i class='fa fa-code-fork'></i> <span class='github-info-card-forks'></span> </span> </div></div> <p>当然，对于中国大陆用户，以上页面也许连打开都成困难。好在我们的<a href=\"https://mirrors.tuna.tsinghua.edu.cn/\">清华大学开源软件镜像站</a>又给我们准备了镜像链接。</p> <p><strong>下载链接：<a href=\"https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/msys2-x86_64-latest.exe\">https://mirrors.tuna.tsinghua.edu.cn/msys2/distrib/msys2-x86_64-latest.exe</a></strong></p> <h3>小结</h3> <p>通过以上内容，我们准备好了：</p> <ul> <li>VSCode 或 VSCodium 的安装包</li> <li>MSYS2 的安装包</li> </ul> <p>确认完毕后，请前往下一小节。</p> <h2>安装</h2> <p>以下环节运行于 Windows 沙盒中，可能于实际环境有所不同。</p> <p>请确保以上环节的安装包都下载完成。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309270626.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309270626.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>安装 MSYS2</h3> <p>下载完成后安装 MSYS2</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309278902.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309278902.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>选择对应的安装文件夹，注意文件夹路径<strong>不能有中文等特殊字符</strong>：</p> <p><strong>若您选择了非默认路径<code>C:\\msys64</code>安装，请确保您能完成之后的安装步骤。</strong></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309298779.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309298779.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>一路 Next 等待安装：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309303563.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309303563.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>由于我们的 MSYS2 只是一个包管理工具，所以现在我们进行的才是 GCC 编译器的安装：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309323968.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309323968.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>先换源</p> <pre><code class=\"language-bash\">sed -i &quot;s#https\\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g&quot; /etc/pacman.d/mirrorlist*</code></pre> <p>输入并执行下列命令以更新包数据库和基础包，在下载过程中请耐心等待。</p> <pre><code class=\"language-bash\">pacman -Syu</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309328148.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309328148.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>在完成之后会提示关闭终端以完成更新，请输入<code>y</code>或<code>Enter</code>以确认。</p> <pre><code class=\"language-bash\">:: To complete this update all MSYS2 processes including this terminal will be closed. Confirm to proceed [Y/n]</code></pre> <p>之后再重新打开 MSYS2 终端（你应该知道去哪里打开吧，对吧），我们再输入以下命令，安装 MinGW-w64 GCC 编译器：</p> <pre><code class=\"language-bash\">pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb</code></pre> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309429661.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309429661.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>更新过程中需要输入<code>y</code>或<code>Enter</code>以确认安装，由于安装包数量多，可能需要较长的时间完成，请耐心等待。</p> <p>安装完成之后就可以关闭终端了。</p> <h3>配置环境变量</h3> <p>在安装完 GCC 编译器之后，其实还不够。配置环境变量是为了让操作系统和程序能够正确地找到需要使用的文件和库，以及让操作系统能够找到编译器可执行文件的位置。否则，在命令行中输入编译命令时，操作系统可能找不到编译器，导致编译失败。</p> <p>在 Windows 搜索框中输入<strong>环境变量</strong> 或 <strong>env</strong> ，点击第一个 <strong>编辑系统环境变量</strong>（在英文版系统下为 <strong>Edit the system environment variables</strong>）</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309460883.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309460883.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309457436.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309457436.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>在打开的环境变量窗口中，在<strong>“用户变量”</strong>部分下方先选择<code>Path</code>条目，再点击<strong>“编辑”</strong>。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309570306.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309570306.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>请输入<code>C:\\msys64\\mingw64\\bin\\</code>，如果你修改了 MSYS2 的安装路径，请自行调整路径。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309576142.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309576142.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>接下来一路确定返回，最好重启一次计算机。</p> <h3>安装 VSCode 或 VSCodium</h3> <h4>VSCode</h4> <p>接下来我们来安装 VSCodium，一路 Next 就行，~象征性配几张图~<br /> <div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309593524.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309593524.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h4>VSCodium</h4> <p>接下来我们来安装 VSCodium，一路 Next 就行，~象征性配几张图~</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309584828.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309584828.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309588539.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309588539.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>配置 VSCode</h3> <p>根据前文所说，VSCode 和 VSCodium 本质上没有什么区别，所以以下书樱以 VSCode 作为演示。</p> <p>打开您的 VSCode，如果如下图所示为英文，请前打开扩展市场，搜索 <strong>Chinese</strong>，安装 VS Code 的中文（简体）语言包。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309640376.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309640376.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>右下角会弹出提示告诉你重启 VSCode 以改变界面语言。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309650724.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309650724.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>打开扩展市场，搜索<strong>C++</strong> 安装官方 C++扩展插件。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309664820.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309664820.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>到这一步 VSCode 就算安装完成了。</p> <h2>配置编译与调试</h2> <p>在 VSCode 中有两种调试方法，一种是在不生产配置文件的情况下，直接启用调试；另一种是生成特定的配置文件，根据配置文件中的条目进行编译和调试。</p> <h3>单文件调试</h3> <p>现在，书樱已经打开了一个 C++ 源文件，它向控制台输出一个<code>Hello World</code>并换行。</p> <pre><code class=\"language-c++\">#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl; return 0; }</code></pre> <p>想要进行编译和调试，你可以直接按快捷键<code>F5</code>，也可以选择<strong>运行与调试</strong>选项卡中的<strong>运行和调试</strong>，接着选择<strong>C++ (GDB/LLDB)</strong>，进行调试。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309691732.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309691732.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>接着选择对应的调试器，通常来说，如果你进行的是纯 C 语言的开发，否则都应该选择 g++ 编译器。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309695171.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309695171.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <blockquote> <p>更加严谨一点，gcc 和 g++ 都能用于 C/C++ 语言的编译。对于后缀为 .c 的程序，gcc 会默认作为 C 语言程序，g++ 会认为是 C++ 语言程序；而后缀为 .cpp 的程序，两者都会认为是 C++ 语言程序。不同的是，在链接过程中，gcc 默认不会链接 C++ 的标准库，而 g++ 会默认告诉链接器链接上 C++ 标准库。</p> </blockquote> <p>程序成功给我们输出了<code>Hello World</code>！</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309732104.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309732104.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h3>配置文件</h3> <div class='admonition shadow-sm admonition-primary'><div class='admonition-title'>注意</div><div class='admonition-body'>配置 VSCode 的配置文件是实现 VSCode 调试的关键，也是本教程的难点所在</div></div> <p>要进行配置文件调试编译，你需要新建一个文件夹以保存 VSCode 的配置文件，本教程中为<code>CPP</code>。</p> <p>在更新的 VSCode 版本中，你还会遇到信任文件夹窗口，请大胆“信任文件夹并启用所有功能”。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309778566.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309778566.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>VSCode 进行调试的流程遵循下图：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309784345.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309784345.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>文件夹应该如图所示，<code>.vscode</code>为 VSCode 自动生成的用于存放配置文件：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310222239.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310222239.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <h4>配置 tasks.json</h4> <p>为了让 VSCode 知道我们在调试 C++ 程序，创建一个<code>main.cpp</code>：</p> <p>在打开<code>main.cpp</code>下，在标题栏 <strong>终端</strong> -&gt; <strong>配置任务</strong>中，选择 <strong>C/C++: g++.exe 生成活动文件</strong>：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310281096.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310281096.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>生成如下：</p> <p><code>tasks.json</code></p> <pre><code class=\"language-json\">{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;command&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin&quot; }, &quot;problemMatcher&quot;: [&quot;$gcc&quot;], &quot;group&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;编译器: C:\\\\msys64\\\\mingw64\\\\bin\\\\g++.exe&quot; } ] }</code></pre> <p><strong>Q: 为什么我没有显示 C/C++: g++.exe 生成活动文件</strong></p> <p><strong>A: 因为您没有正确安装好 g++ 或没有安装到默认路径，VSCode 没有识别到您的 g++。这种情况下请您重新安装或自行复制以下内容并配置好 g++ 的路径，具体为<code>command</code>条目。</strong></p> <p>而<code>detail</code>条目则是当前调试项目的备注，可选择更改。</p> <div class='admonition shadow-sm admonition-primary'><div class='admonition-title'>注意</div><div class='admonition-body'>如果是用斜杠作为分隔符，请使用双斜杠<code>//</code>或者反斜杠<code>\\</code>，不要使用单斜杠<code>/</code>，如果使用单斜杠<code>/</code>，斜杠本身将会和后面的字符一起被 VSCode 转义为其他字符</div></div> <pre><code class=\"language-json\">{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;command&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [&quot;$gcc&quot;], &quot;group&quot;: &quot;build&quot;, &quot;detail&quot;: &quot;编译器: C:\\\\msys64\\\\mingw64\\\\bin\\\\g++.exe&quot; } ] }</code></pre> <h4>配置 launch.json</h4> <p>切换到调试选项卡，选择 <strong>创建 launch.json</strong> 开始配置调试：</p> <p>选择<code>C++(GDB/LLDB)</code>:</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309691732.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690309691732.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>在右下角选择<code>添加配置</code>，并选择<code>C/C++：(gdb)启动</code>:</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310347539.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/image-1690310347539.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>点击后，VSCode 给我们自动配置如下:</p> <pre><code class=\"language-json\">{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) 启动&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;输入程序名称，例如 ${workspaceFolder}/a.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;/path/to/gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ] } ] }</code></pre> <p><strong>第一步：调整<code>program</code>条目，配置 gdb 调试的文件名。</strong></p> <p><code>program</code>条目指向的是我们要调试的程序，这里则是我们上一布编译生成的活动文件。</p> <p>在上一节中，系统配置的 g++ 编译参数为<code>-o ${fileDirname}\\\\${fileBasenameNoExtension}.exe </code>，生成的则是在 VSCode 中打开的文件夹路径下的当前打开的活动文件的文件名。</p> <p>所以，将<code>program</code>的<strong><code>输入程序名称，例如 ${workspaceFolder}/a.exe</code></strong>，改为<strong><code>${fileDirname}/${fileBasenameNoExtension}.exe</code></strong>，并注意保留两侧的英文双引号。</p> <pre><code class=\"language-json\"> &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;,</code></pre> <p>VSCode 为我们保留了许多预定义变量，可以被我们在配置文件中直接使用：<a href=\"https://code.visualstudio.com/docs/editor/variables-reference\" title=\"Visual\">[9]</a></p> <ul> <li><strong><code>${userHome}</code></strong> &#8211; 用户主文件夹的路径</li> <li><strong><code>${workspaceFolder}</code></strong> &#8211; 在 VSCode 中打开的文件夹的路径</li> <li><strong><code>${workspaceFolderBasename}</code></strong> &#8211; 在 VS Code 中打开的文件夹的名称，不带任何斜杠 (/)</li> <li><strong><code>${file}</code></strong> &#8211; 当前打开的文件</li> <li><strong><code>${fileWorkspaceFolder}</code></strong> &#8211; 当前打开的工作区文件夹</li> <li><strong><code>${relativeFile}</code></strong> &#8211; 相对于<code>${workspaceFolder}</code>的当前打开的文件路径</li> <li><strong><code>${relativeFileDirname}</code></strong> &#8211; 相对于<code>${workspaceFolder}</code>的当前打开的文件夹路径</li> <li><strong><code>${fileBasename}</code></strong> &#8211; 当前打开文件名</li> <li><strong><code>${fileBasenameNoExtension}</code></strong> &#8211; 当前打开的无文件扩展名的文件名</li> <li><strong><code>${fileDirname}</code></strong> &#8211; 当前打开文件的目录名</li> <li><strong><code>${fileExtname}</code></strong> &#8211; 当前打开文件的扩展名</li> <li><strong><code>${cwd}</code></strong> &#8211; 运行任务时的当前工作目录</li> <li><strong><code>${lineNumber}</code></strong> &#8211; 活动文件中当前选定的行号</li> <li><strong><code>${selectedText}</code></strong> &#8211; 活动文件中当前选定的文本</li> <li><strong><code>${execPath}</code></strong> &#8211; 正在运行的 VS Code 可执行文件的路径</li> <li><strong><code>${defaultBuildTask}</code></strong> &#8211; 默认运行任务的名称</li> <li><strong><code>${pathSeparator}</code></strong> &#8211; 操作系统用来分隔文件路径中的组件的字符</li> </ul> <p>所以，配置程序可执行文件的完整路径时，将会自动替换为<code>CPP/hello.exe</code>，gdb 将会对此文件进行调试。</p> <p><strong>第二步：调整<code>miDebuggerPath</code>条目，配置<code>gdb</code>的文件路径。</strong></p> <p>如果你的 MSYS2 安装路径为默认，那么这一步的 gdb.exe 的路径将会是<code>C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe</code>，如果你的安装路径不是系统默认，请自行配置<code>gdb</code>的绝对路径。</p> <pre><code class=\"language-json\"> &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ {</code></pre> <p><strong>第三步：添加<code>preLaunchTask</code>条目，并配置执行任务</strong></p> <ul> <li><strong><code>preLaunchTask</code></strong> &#8211; 要在调试会话开始之前启动的任务，这里指向的就是我们上一小节中创建的<code>C/C++: g++.exe 生成活动文件</code></li> </ul> <p>由于我们在上一小节中，系统自动生成的标签（<code>lable</code>）为：<code>C/C++: g++.exe 生成活动文件</code>，所以在这里我们需要添加一条条目，并保存如下：</p> <pre><code class=\"language-json\"> &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\msys64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;setupCommands&quot;: [ {</code></pre> <p><strong>Q: 为什么我按照上面配置完成后调试报错？</strong></p> <p><strong>A: 请先检查 1. 系统变量 2.路径是否有中文 3.用户名是否为中文 4.命令行编译是否成功</strong></p> <h3>完成</h3> <p>完成上述步骤后，切换到<code>hello.cpp</code>，轻按下<code>F5</code>，享受由 VSCode 带来的便捷调试吧！</p> <h2>小结</h2> <p>要实现在 VSCode 上调试 C/C++ 代码，首先 VSCode 通过<code>launch.json</code>中的<code>preLaunchTask</code>条目，使用 g++ 将 C++ 代码编译成可执行文件；接着在用 gdb 调试器对可执行文件进行调试，最后完成在 VSCode 上开发 C++ 的功能。</p> <p>相比与一些罐头式的 C++ IDE，如 Codeblocks，Dev-C++，VSCode 的配置相对来说会比较麻烦一点。但 VSCode 作为一个全功能的编辑器，能够满足不同类型的开发者的需求。同时 VSCode 界面美观，操作方便，并且能够定制主题和外观，还拥有着丰富的插件市场，可以根据个人需求安装各种插件，以提高编辑器的功能。最后，VSCode 还提供了强大的智能提示功能，能够帮助开发者快速完成编码，提高开发效率。</p> <p>作为轻量，几乎万能的编辑器，相比于 Visual Studio 这种适合大型项目开发的 IDE 来说，VSCode 更加适合在平时学习中对 C++ 短代码的测试以及 C++ 语言的学习，理所应当是我们的不二之选。</p> <h2>参考</h2> <ol> <li><a href=\"https://code.visualstudio.com/docs/cpp/config-mingw\">Get Started with C++ and Mingw-w64 in Visual Studio Code</a></li> <li><a href=\"https://code.visualstudio.com/docs/cpp/cpp-debug\">Debug C++ in Visual Studio Code</a></li> <li><a href=\"https://code.visualstudio.com/docs/cpp/launch-json-reference\">Configure launch.json for C/C++ debugging in Visual Studio Code</a></li> <li><a href=\"https://zh.wikipedia.org/zh-cn/Visual_Studio_Code\">Visual Studio Code &#8211; 维基百科，自由的百科全书</a></li> <li><a href=\"https://zh.wikipedia.org/zh-cn/%E7%B7%A8%E8%AD%AF%E5%99%A8\">编译器 &#8211; 维基百科，自由的百科全书</a></li> <li><a href=\"https://www.msys2.org/\">MSYS2</a></li> <li><a href=\"https://www.jianshu.com/p/d66c2f2e3537\">MinGW-w64 安装教程 &#8211; 简书</a></li> <li><a href=\"https://www.mingw-w64.org/\">MinGW-w64</a></li> <li><a href=\"https://code.visualstudio.com/docs/editor/variables-reference\">Visual Studio Code Variables Reference</a></li> </ol>",
    "publishDate": "2022-06-14T16:00:55.000Z",
    "modifiedDate": "2024-03-14T11:19:54.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 3,
        "name": "教程",
        "slug": "tutorial",
        "count": 2
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 312,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-e1706177636337.png",
      "alt": "",
      "title": "debug-cpp-in-vscode",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-e1706177636337.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-300x187.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"187\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-300x187.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-300x187.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-1024x637.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2022/06/debug-cpp-in-vscode-e1706177636337.png"
      },
      "width": 778,
      "height": 484,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2022/06/debug-cpp-in-vscode/",
    "wordCount": 1376,
    "readingTime": 7,
    "seo": {
      "title": "【教程】如何在VSCode上调试C++程序",
      "description": "<p>序言 这篇文章是写给那些，包括书樱在内，对于 VSCode 不太了解，但是又迫切的需要一个比 Visual S [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2022/06/debug-cpp-in-vscode/"
    }
  },
  {
    "id": "26",
    "title": "【二】imagehash算法解析【Python】",
    "slug": "image-hash-algorithm",
    "excerpt": "<p>「论一个随机图片 api 的养成计划」 前段时间，书樱用 Python 稍微抓取了 Pixiv 的图片，总共大 [&hellip;]</p>",
    "content": "<h2>「论一个随机图片 api 的养成计划」</h2> <blockquote> <p>前段时间，书樱用 Python 稍微抓取了 Pixiv 的图片，总共大概有三万张左右。因为爬取时的爬虫只负责下载了，出现了很多重复的图片以及图片缩略图。最近想搞个图片 api，正好可以用上这些二次元图片，所以这个系列暂且叫做「论一个随机图片 api 的养成计划，于是便有了这篇文章。</p> </blockquote> <p>系列文章合集 -&gt; <a href=\"archives/category/project/to-make-a-pic-api/\">「论一个随机图片 api 的养成计划」</a></p> <div class='collapse-block shadow-sm collapse-block-transparent hide-border-left'><div class='collapse-block-title'><span class='collapse-block-title-inner'>提示</span><i class='collapse-icon fa fa-angle-down'></i></div><div class='collapse-block-body' style='display:none;'>您正在阅读的是一个系列文章，此系列书樱将会持续更新，敬请关注。</div></div> <p>如果您觉得我写的东西对您有所帮助的话，不妨请我喝杯咖啡。=&gt; <a href=\"/support\" title=\"赞助\">赞助</a></p> <h3>序言</h3> <p>不知不觉又摸鱼了好久，那么书樱今天系统地介绍一下 imagehash 这个 Python 库，我们在后面的过程中会用到。</p> <p>秉承着<strong>不重复发明轮子</strong>的原则，书樱在中文互联网上找了一圈，这应该是第一篇对 imagehash 这个库进行全面解析的文章。</p> <p>这是这个系列文章的第二篇，想看前一篇文章的朋友，可以点击进入。 <a href=\"archives/2021/01/resort-pic-with-opencv-and-pillow/\">【一】使用 OpenCV、Pillow 库分类图片【Python】</a></p> <p>话不宜迟，进入正题。</p> <h2>imagehash</h2> <blockquote> <p>An image hashing library written in Python. 来自 imagehash GitHub 页面</p> </blockquote> <p><code>imagehash</code>所有的代码都托管在<a href=\"https://github.com/JohannesBuchner/imagehash\" title=\"GitHub\">GitHub</a>上，大佬们可以自行阅读。</p> <div class='github-info-card github-info-card-full card shadow-sm' data-author='JohannesBuchner' data-project='imagehash' githubinfo-card-id='6583346631' data-getdata='frontend' data-description='' data-stars='' data-forks=''><div class='github-info-card-header'><a href='https://github.com/' ref='nofollow' target='_blank' title='Github' no-pjax><span><i class='fa fa-github'></i> GitHub</span></a></div><div class='github-info-card-body'> <div class='github-info-card-name-a'> <a href='https://github.com/JohannesBuchner/imagehash' target='_blank' no-pjax> <span class='github-info-card-name'>JohannesBuchner/imagehash</span> </a> </div> <div class='github-info-card-description'></div> </div><div class='github-info-card-bottom'> <span class='github-info-card-meta github-info-card-meta-stars'> <i class='fa fa-star'></i> <span class='github-info-card-stars'></span> </span> <span class='github-info-card-meta github-info-card-meta-forks'> <i class='fa fa-code-fork'></i> <span class='github-info-card-forks'></span> </span> </div></div> <p><code>imagehash</code>是一个用 Python 写的图片哈希算法库。支持以下功能：</p> <ul> <li>平均哈希（<code>ahash</code>）</li> <li>感知哈希（<code>phash</code>）</li> <li>差异哈希（<code>dhash</code>）</li> <li>小波哈希（<code>whash</code>）</li> <li>HSV 颜色哈希（<code>colorhash</code>）</li> <li>抗剪切哈希（<code>crop-resistant hashing</code>）</li> </ul> <h3>原理</h3> <h4>什么是哈希（hash）？</h4> <blockquote> <p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。<a href=\"https://zh.wikipedia.org/zh-hans/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8\" title=\"散列函数\">[1]</a></p> </blockquote> <p>诸如 MD5、HA256 一类的密码散列函数，可以输入任何一种数据，将数据压缩成部分摘要，使得数据量变小，从而创建出小的数字“指纹”。</p> <h4>什么是图像哈希（<code>imagehash</code>）？</h4> <p>在图像哈希算法中定义了一类可以输出可比较哈希的函数，这些函数可以提取图像中的特征，用来生成一个独特但不唯一的指纹，比较这些生成的指纹就能够比较两个图像的相似度。</p> <h4>图像哈希是怎么起作用的？</h4> <p>在使用加密哈希函数加密时，输出的散列值是随机的，散列值通常用一个短的随机字母和数字组成的字符串来代表。</p> <p>用于生成哈希的数据的行为类似于随机种子，对于同一种加密算法，相同的数据能生成相同的结果，但不同的数据将生成不同的结果，就如下面这个 MD5 加密：</p> <pre><code>MD5(&quot;114514&quot;) = c4d038b4bed09fdb1471ef51ec3a32cd</code></pre> <p>即使在原文中发生哪怕一个极其微小的变化，其散列输出也会发生巨大的变化：</p> <pre><code>MD5(&quot;114515&quot;) = ec5935f52ea59fbad054b523ccdf9c72</code></pre> <p>所以比较两个哈希值实际上只能告诉我们一件事，这两个文件是否相同——如果哈希不同，则数据不同。 如果哈希值相同，则数据<strong>可能</strong>相同。（由于存在哈希冲突的可能性，因此具有相同的哈希值不能保证相同的数据。）</p> <p>而在<code>imagehash</code>中，对于输入的图片，我们希望相似的图片输入能够有相似的哈希输出，而不同的图片输入能够输出不同的图像哈希，这样输出的哈希才具有可比性。比较哈希字符串之间的<a href=\"https://zh.wikipedia.org/zh-hans/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\" title=\"汉明距离\">汉明距离</a>，我们就可以比较两张图片的相似度。</p> <p>图像哈希算法，如:平均哈希（<code>ahash</code>）、感知哈希（<code>phash</code>）、差异哈希（<code>dhash</code>）、小波哈希（<code>whash</code>）是使用图像的明度信息来进行分析的（没有颜色信息）。</p> <p>而颜色哈希算法，如：HSV 颜色哈希（<code>colorhash</code>），则分析的是图片颜色分布以及黑色和灰色的占比（没有位置信息）。</p> <h3>安装</h3> <p>imagehash 基于 PIL，numpy 以及 scipy.fftpack(pHash)。可以轻松的通过<a href=\"https://pypi.python.org/pypi/ImageHash\" title=\"pypi\">pypi</a>安装：</p> <p><code>pip3 install imagehash</code></p> <p>pip 会自动安装当前不存在的 Python 依赖库</p> <h3>使用</h3> <p>要想使用 imagehash 里的函数，您必须导入<code>imagehash</code>和<code>PIL.Image</code></p> <pre><code class=\"language-python\">import imagehash from PIL import Image</code></pre> <p>所有的函数都可以在<code>import</code>后直接使用。</p> <p>例子（来自 GitHub 文档）:</p> <pre><code class=\"language-python\">>&gt;&gt; from PIL import Image >&gt;&gt; import imagehash >&gt;&gt; hash = imagehash.average_hash(Image.open(&#039;test.png&#039;)) >&gt;&gt; print(hash) d879f8f89b1bbf >&gt;&gt; otherhash = imagehash.average_hash(Image.open(&#039;other.bmp&#039;)) >&gt;&gt; print(otherhash) ffff3720200ffff >&gt;&gt; print(hash == otherhash) False >&gt;&gt; print(hash - otherhash) 36 >&gt;&gt; for r in range(1, 30, 5): ... rothash = imagehash.average_hash(Image.open(&#039;test.png&#039;).rotate(r)) ... print(&#039;Rotation by %d: %d Hamming difference&#039; % (r, hash - rothash)) ... Rotation by 1: 2 Hamming difference Rotation by 6: 11 Hamming difference Rotation by 11: 13 Hamming difference Rotation by 16: 17 Hamming difference Rotation by 21: 19 Hamming difference Rotation by 26: 21 Hamming difference >&gt;&gt;</code></pre> <h3>函数</h3> <p>以下内容来自 Github 页面，部分文本为书樱自行翻译添加，可能存在翻译有误。</p> <blockquote> <p>Each algorithm can also have its hash size adjusted (or in the case of colorhash, its binbits). Increasing the hash size allows an algorithm to store more detail in its hash, increasing its sensitivity tochanges in detail.</p> </blockquote> <p>每一种算法都可以调整其 hash_size（在 colorhash 里则是 binbits）。增加 hash_size 可以让算法在其哈希中存储更多的细节，增加其对细节变化的敏感性。</p> <h5>_binary_array_to_hex</h5> <p><code>_binary_array_to_hex(arr)</code></p> <blockquote> <p>internal function to make a hex string out of a binary array.</p> </blockquote> <p>一个可以把二进制数组输出为十六进制字符串的内置函数。</p> <p><strong>@arr</strong>：<code>numpy</code>对象</p> <h5>hex_to_hash</h5> <p><code>hex_to_hash(hexstr)</code></p> <blockquote> <p>Convert a stored hash (hex, as retrieved from str(Imagehash))back to an Imagehash object. Notes:1. This algorithm assumes all hashes are either bidimensional arrays with dimensions hash_size _hash<em>size, or one dimensional arrays with dimensions bin bits</em> 14.2. This algorithm does not work for hash_size &lt; 2.</p> </blockquote> <p>把一个存储的 hash 值（由<code>str(Imagehash)</code>输出的十六进制数）转化为<code>Imagehash</code>对象 <strong>注意</strong>：该算法假定所有的哈希都是<code>hash_size * hash_size</code>的二维数组，或者是具有<code>bin * 14.2</code>的一维数组。 此函数不适用于当<code>hash_size＜2</code>时。</p> <p><strong>@hexstr</strong>：<code>hash</code>字符串</p> <h5>hex_to_flathash</h5> <p><code>hex_to_flathash(hexstr, hashsize)</code></p> <p><strong>@hexstr</strong>：<code>hash</code>字符串 <strong>@hashsize</strong>：<code>hash</code>大小</p> <h5>old_hex_to_hash</h5> <p><code>old_hex_to_hash(hexstr, hash_size=8)</code></p> <blockquote> <p>Convert a stored hash (hex, as retrieved from str(Imagehash))back to an Imagehash object. This method should be used for hashes generated by ImageHash up to version 3.7. For hashes generated by newer versions of ImageHash, hex_to_hash should be used instead.</p> </blockquote> <p>把一个存储的<code>hash</code>值（由<code>str(Imagehash)</code>输出的十六进制数）转化为<code>imagehash</code>对象 这个函数应该被用于低于版本 3.7 的<code>Imagehash</code>生成的<code>hash</code>转换。而对于新版本生成的<code>hash</code>，应该使用<code>hex_to_hash</code>。</p> <p><strong>@hexstr</strong>：<code>hash</code>字符串 <strong>@hashsize</strong>：<em>可选</em>，<code>hash</code>大小，默认为 8</p> <h5>average_hash</h5> <p><code>average_hash(image, hash_size=8, mean=numpy.mean)</code></p> <blockquote> <p>Average Hash computation implementation follows <a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a>Step by step explanation: <a href=\"https://web.archive.org/web/20171112054354/https://www.safaribooksonline.com/blog/2013/11/26/image-hashing-with-python/\">https://web.archive.org/web/20171112054354/https://www.safaribooksonline.com/blog/2013/11/26/image-hashing-with-python/</a></p> </blockquote> <p>平均哈希计算 实例：<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a>分布解释：<a href=\"https://web.archive.org/web/20171112054354/https://www.safaribooksonline.com/blog/2013/11/26/image-hashing-with-python/\">https://web.archive.org/web/20171112054354/https://www.safaribooksonline.com/blog/2013/11/26/image-hashing-with-python/</a></p> <p><strong>@image</strong>：<code>PIL.image</code>对象 <strong>@hash_size</strong>：<em>可选</em>，<code>hash</code>大小，默认为 8 <strong>@mean</strong> ：<em>可选</em>，平均方式，默认为<code>numpy.mean</code></p> <h5>phash &amp; phash_simple</h5> <p><code> phash(image, hash_size=8, highfreq_factor=4)</code><code>phash_simple(image, hash_size=8, highfreq_factor=4) </code></p> <blockquote> <p>Perceptual Hash computation Implementation follows <a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p> </blockquote> <p>感知哈希计算 实例：<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p> <p><strong>@image</strong>：<code>PIL.image</code>对象 <strong>@hash_size</strong>：<em>可选</em>，<code>hash</code>大小，默认为 8 <strong>@highfreq_factor</strong>：<em>可选</em>，高频因子，默认为 4</p> <h5>dhash &amp; dhash_vertical</h5> <p><code> dhash(image, hash_size=8)</code><code>dhash_vertical(image, hash_size=8) </code></p> <blockquote> <p>Difference Hash computation. following <a href=\"http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html\">http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html</a></p> </blockquote> <p>差异哈希计算 <code>dhash()</code>是水平计算哈希，而<code>dhash_vertical()</code>是垂直计算哈希 实例：<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html\">http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html</a></p> <p><strong>@image</strong>：<code>PIL.image</code>对象 <strong>@hash_size</strong>：<em>可选</em>，<code>hash</code>大小，默认为 8</p> <h5>whash</h5> <p><code>whash(image, hash_size = 8, image_scale = None, mode = &#039;haar&#039;, remove_max_haar_ll = True)</code></p> <blockquote> <p>Wavelet Hash computation. based on <a href=\"https://www.kaggle.com/c/avito-duplicate-ads-detection/\">https://www.kaggle.com/c/avito-duplicate-ads-detection/</a></p> </blockquote> <p>小波哈希计算 基于：<a href=\"https://www.kaggle.com/c/avito-duplicate-ads-detection/\">https://www.kaggle.com/c/avito-duplicate-ads-detection/</a></p> <p><strong>@image</strong>：<code>PIL.image</code>对象 <strong>@hash_size</strong>：<em>可选</em>，<code>hash</code>大小，默认为 8 <strong>@image_scale</strong>：<em>可选</em>，必须是 2 的整数次幂且小于图像大小，默认为输入图片的最大值 <strong>@mode</strong>：<em>可选</em>，<code>PyWavelets</code>库的算法模式，默认为<code>haar</code>哈尔小波，也可为<code>db4</code>多贝西小波 <strong>@remove_max_haar_ll</strong>：<em>可选</em>，使用哈尔小波算法移除最差低频信息，默认为<code>True</code></p> <h5>colorhash</h5> <p><code>colorhash(image, binbits=3)</code></p> <blockquote> <p>Color Hash computation. Computes fractions of image in intensity, hue and saturation bins: the first binbits encode the black fraction of the image the next binbits encode the gray fraction of the remaining image (low saturation) the next 6<em>binbits encode the fraction in 6 bins of saturation, for highly saturated parts of the remaining image the next 6</em>binbits encode the fraction in 6 bins of saturation, for mildly saturated parts of the remaining image@binbits number of bits to use to encode each pixel fractions</p> </blockquote> <p>颜色哈希计算 计算图像在强度、色调和饱和度中的占比： 第一个二进制位编码了图像的黑色占比 下一个二进制位编码了剩余图像的灰度占比（低饱和度） 下六个二进制位以六位二进制编码了剩余图像高饱和度部分的饱和度 下六个二进制位以六位二进制编码了剩余图像中饱和度部分的饱和度</p> <p><strong>@image</strong>： <code>PIL.image</code>对象 <strong>@binbits</strong>：<em>可选</em>，用于编码每个像素部分的<code>bit</code>数，默认为 3</p> <h5>_find_region</h5> <p><code>_find_region(remaining_pixels, segmented_pixels)</code></p> <blockquote> <p>Finds a region and returns a set of pixel coordinates for it.</p> </blockquote> <p>查找区域并返回该区域的一组像素坐标。</p> <p><strong>@remaining_pixels</strong>：一个 numpy 布尔数组，当时<code>True</code>时意味着此像素将会被分割 <strong>@segmented_pixels</strong>：一组已经分割的像素坐标。这将随着新像素添加到返回分割段中而更新</p> <h5>_find_all_segments</h5> <p><code>_find_all_segments(pixels, segment_threshold, min_segment_size)</code></p> <blockquote> <p>Finds all the regions within an image pixel array, and returns a list of the regions. Note: Slightly different segmentations are produced when using pillow version 6 vs. &gt;=7, due to a change in rounding in the greyscale conversion.</p> </blockquote> <p>查找图像像素数组中的所有区域，并返回区域列表。 注意：由于灰度转换中的舍入变化，使用<code>Pillow 6</code>与<code>Pillow 7</code>及以上相比较而言会略有不同的分割。</p> <p><strong>@pixiels</strong>：一个值为像素亮度的·数组 <strong>@segment_threshold</strong>：区分峰值和谷值的阈值 <strong>@min_segment_size</strong>：一次分割的最小像素值</p> <h5>crop_resistant_hash</h5> <p><code>crop_resistant_hashcrop_resistant_hash(image,hash_func=None,limit_segments=None,segment_threshold=128,min_segment_size=500,segmentation_image_size=300)</code></p> <blockquote> <p>Creates a CropResistantHash object, by the algorithm described in the paper &quot;Efficient Cropping-Resistant Robust Image Hashing&quot;. DOI 10.1109/ARES.2014.85 This algorithm partitions the image into bright and dark segments, using a watershed-like algorithm, and then does an image hash on each segment. This makes the image much more resistant to cropping than other algorithms, with the paper claiming resistance to up to 50% cropping, while most other algorithms stop at about 5% cropping. Note: Slightly different segmentations are produced when using pillow version 6 vs. &gt;=7, due to a change in rounding in the greyscale conversion. This leads to a slightly different result.</p> </blockquote> <p>使用<code>&quot;Efficient Cropping-Resistant Robust Image Hashing&quot;. DOI 10.1109/ARES.2014.85</code>论文中描述的算法创建一个<code>CropResistantHash</code>对象 这个算法使用<a href=\"https://en.wikipedia.org/wiki/Watershed\" title=\"分水岭算法\">分水岭算法</a>将图像分割成亮和暗两部分，再将其每一个图像进行哈希计算。这使得图像比其他算法更抗剪切。 论文声称，此算法将能达到 50%的抗剪切，而其他的算法最多只有 5%。 注意：由于<code>Pillow</code>中灰度缩放转换算法的改变，使用<code>Pillow 6</code>与<code>Pillow 7</code>及以上版本所处理的图像可能会有细小差别。这会导致一些轻微的差别。</p> <p><strong>@image</strong>：<code>PIL.image</code>对象 <strong>@hash_func</strong>：<em>可选</em>，将要使用的哈希函数。默认为<a href=\"mailto:code&gt;None&lt;/code&gt;**@limit_segments**：_可选_，如果您有储存需求，您可以限制算法只计算最大部分。默认为&lt;code\">code>None</code>**@limit_segments**：_可选_，如果您有储存需求，您可以限制算法只计算最大部分。默认为<code</a>None</code><strong>@segment_threshold</strong>：<em>可选</em>，介于峰值和谷值之间的亮度阈值。这应该是个静态的值，若介于峰值和低谷之间会动态中断匹配。默认为 128 <strong>@min_segment_size</strong>：<em>可选</em>，哈希分段的最小像素数，默认为 500 <strong>@segmentation_image_size</strong>：<em>可选</em>，图像分割之前被调整的大小，默认为 300</p> <h3>算法解析</h3> <p>还是用这张天依的照片来演示一下各个算法的运行过程，此为测试图片，来自 Pixiv，画师 id：<a href=\"https://www.pixiv.net/users/418969\">418969</a>，作品：<a href=\"https://www.pixiv.net/artworks/82910218\">#VOCALOIDCHINA Espejo</a><a href=\"https://www.pixiv.net/artworks/82910218\"><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://ae01.alicdn.com/kf/Hc784f57058ed4c4f8187461c3d5a999aE.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://ae01.alicdn.com/kf/Hc784f57058ed4c4f8187461c3d5a999aE.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"\" /></div></a></p> <h4>ahash</h4> <p><code>ahash</code>，又称为<code>average hash</code>，平均哈希算法。这是最简单的算法，速度最快，但精度也是最低的。</p> <p>ahash 的基本原理就是，把图片的每个像素与所有像素的平均值进行比较，大于平均值的像素输出<code>True</code>，小于平均值的像素输出<code>False</code>，最后再输出哈希。</p> <pre><code class=\"language-python\">def average_hash(image, hash_size=8, mean=numpy.mean): &quot;&quot;&quot; Average Hash computation Implementation follows http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html Step by step explanation: https://web.archive.org/web/20171112054354/https://www.safaribooksonline.com/blog/2013/11/26/image-hashing-with-python/ @image must be a PIL instance. @mean how to determine the average luminescence. can try numpy.median instead. &quot;&quot;&quot; if hash_size &lt; 2: raise ValueError(&quot;Hash size must be greater than or equal to 2&quot;) # reduce size and complexity, then covert to grayscale image = image.convert(&quot;L&quot;).resize((hash_size, hash_size), Image.ANTIALIAS) # find average pixel value; &#039;pixels&#039; is an array of the pixel values, ranging from 0 (black) to 255 (white) pixels = numpy.asarray(image) avg = mean(pixels) # create string of bits diff = pixels &gt; avg # make a hash return ImageHash(diff)</code></pre> <p><strong>注意</strong>：传入的参数<code>hash_size</code>必须要＞ 2，否则会返回<code>ValueError</code>错误。</p> <p><strong>第一步</strong>：将原始图像转为灰度图、缩放图片、平滑滤波</p> <p><code>image = image.convert(&quot;L&quot;).resize((hash_size, hash_size), Image.ANTIALIAS)</code></p> <p><code>image.convert(&quot;L&quot;)</code>将图片转化为灰度图，如下：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308254620.L.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308254620.L.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><code>Image.resize((hash_size, hash_size))</code>缩放图片大小为长宽都为<code>hash_size</code>。（默认为 8）</p> <p>接着使用<code>Image.ANTIALIAS</code>操作进行平滑滤波。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308281896.L.resize.ANTIALIAS.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308281896.L.resize.ANTIALIAS.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308295010.L.resize.600.ANTIALIAS.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308295010.L.resize.600.ANTIALIAS.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p>这就是算法的第一步，缩小图片的尺寸，减少运算量。</p> <p><strong>第二步</strong>：将处理后的图像转为<code>numpy</code>数组</p> <pre><code class=\"language-python\">pixels = numpy.asarray(image) avg = mean(pixels)</code></pre> <p>使用<code>numpy.asarray()</code>将<code>image</code>图像的每一个像素读取出明度值，输出大概长这样。</p> <pre><code class=\"language-python\">>&gt;&gt; numpy.asarray(Image.open(&#039;0.L.resize.ANTIALIAS.png&#039;)) array([[162, 128, 135, 84, 28, 7, 12, 17], [109, 137, 122, 129, 110, 48, 25, 20], [ 88, 131, 139, 128, 144, 135, 121, 93], [129, 160, 161, 149, 137, 150, 146, 115], [179, 189, 177, 130, 127, 179, 133, 112], [177, 171, 138, 64, 69, 163, 80, 94], [171, 166, 138, 125, 109, 115, 126, 113], [105, 130, 128, 114, 106, 114, 115, 93]], dtype=uint8)</code></pre> <p>每一个数值都代表了一个像素，大小为 0-255，代表了该像素的明度。</p> <p><strong>第三步</strong>：计算哈希</p> <p>使用<code>numpy.mean()</code>操作对数组求平均值。</p> <pre><code class=\"language-python\">>&gt;&gt; numpy.mean(numpy.asarray(Image.open(&#039;0.L.resize.ANTIALIAS.png&#039;))) 117.953125</code></pre> <p><code>diff = pixels &gt; avg</code></p> <p>把所有的像素与求得的平均值比较，大于则为<code>True</code>，小于则为<code>False</code></p> <pre><code>array([[ True, True, True, False, False, False, False, False], [False, True, True, True, False, False, False, False], [False, True, True, True, True, True, True, False], [ True, True, True, True, True, True, True, False], [ True, True, True, True, True, True, True, False], [ True, True, True, False, False, True, False, False], [ True, True, True, True, False, False, True, False], [False, True, True, False, False, False, False, False]])</code></pre> <p>最后再将这 8*8 个 bit 每 4 位组成一个字符，输出哈希为：<code>e0707efefee4f260</code>，这便是这张图片的<code>ahash</code>值</p> <pre><code class=\"language-python\">>&gt;&gt; print(imagehash.average_hash(Image.open(&#039;0.L.resize.ANTIALIAS.png&#039;))) e0707efefee4f260</code></pre> <h4>phash &amp; phash_simple</h4> <p><code>phash</code>，又称为<code>perceptual hash</code>，感知哈希算法。感知哈希算法是精度最高的算法，因为涉及使用到了 DCT（离散余弦变换），在提高精度的同时也降低了速度。</p> <blockquote> <p><strong>离散余弦变换</strong>（英语：<strong>discrete cosine transform, DCT</strong>）是与傅里叶变换相关的一种变换，类似于离散傅里叶变换，但是只使用实数。离散余弦变换相当于一个长度大概是它两倍的离散傅里叶变换，这个离散傅里叶变换是对一个实偶函数进行的（因为一个实偶函数的傅里叶变换仍然是一个实偶函数），在有些变形里面需要将输入或者输出的位置移动半个单位（DCT 有 8 种标准类型，其中 4 种是常见的）。<a href=\"https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\" title=\"离散余弦变换\">[2]</a></p> </blockquote> <pre><code class=\"language-python\">def phash(image, hash_size=8, highfreq_factor=4): &quot;&quot;&quot; Perceptual Hash computation. Implementation follows http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html @image must be a PIL instance. &quot;&quot;&quot; if hash_size &lt; 2: raise ValueError(&quot;Hash size must be greater than or equal to 2&quot;) import scipy.fftpack img_size = hash_size * highfreq_factor image = image.convert(&quot;L&quot;).resize((img_size, img_size), Image.ANTIALIAS) pixels = numpy.asarray(image) dct = scipy.fftpack.dct(scipy.fftpack.dct(pixels, axis=0), axis=1) dctlowfreq = dct[:hash_size, :hash_size] med = numpy.median(dctlowfreq) diff = dctlowfreq &gt; med return ImageHash(diff) def phash_simple(image, hash_size=8, highfreq_factor=4): &quot;&quot;&quot; Perceptual Hash computation. Implementation follows http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html @image must be a PIL instance. &quot;&quot;&quot; import scipy.fftpack img_size = hash_size * highfreq_factor image = image.convert(&quot;L&quot;).resize((img_size, img_size), Image.ANTIALIAS) pixels = numpy.asarray(image) dct = scipy.fftpack.dct(pixels) dctlowfreq = dct[:hash_size, 1:hash_size+1] avg = dctlowfreq.mean() diff = dctlowfreq &gt; avg return ImageHash(diff)</code></pre> <p><strong>注意</strong>：传入的参数<code>hash_size</code>必须要＞ 2，否则会返回<code>ValueError</code>错误。</p> <p><strong>第一步</strong>：将原始图像转为灰度图、缩放图片、平滑滤波</p> <p>与<code>ahash</code>一样，<code>phash</code>也要将图像变小以便减少计算量。</p> <pre><code class=\"language-python\"> import scipy.fftpack img_size = hash_size * highfreq_factor image = image.convert(&quot;L&quot;).resize((img_size, img_size), Image.ANTIALIAS)</code></pre> <p>为了实现 DCT，这里<code>import</code>了一个叫<code>scipy</code>的模块。</p> <blockquote> <p>SciPy is a collection of mathematical algorithms and convenience functions built on the NumPy extension of Python. It adds significant power to the interactive Python session by providing the user with high-level commands and classes for manipulating and visualizing data.<a href=\"https://docs.scipy.org/doc/scipy/tutorial/general.html\" title=\"Introduction\">[3]</a></p> </blockquote> <p><code>SciPy</code>是一个基于 Python 的<code>NumPy</code>扩展构建的数学算法和函数的集合。通过为用户提供用于操作和可视化数据的高级命令和类。</p> <p>其中<code>fftpack</code>则是离散傅里叶变换（Discrete Fourier transforms）的相关库。</p> <p><code>image = image.convert(&quot;L&quot;).resize((img_size, img_size), Image.ANTIALIAS)</code></p> <p><code>image.convert(&quot;L&quot;)</code>将图片转化为灰度图，如下：</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308311873.L.resize.32.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308311873.L.resize.32.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><code>Image.resize((img_size, img_size))</code>缩放图片大小为长宽都为<code>img_size</code>。对于 DCT 来说，32 比较合适，所以默认为<code>hash_size * highfreq_factor</code>即 32。</p> <p>接着使用<code>Image.ANTIALIAS</code>操作进行平滑滤波。</p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308308353.L.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308308353.L.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308314992.L.resize.32.600.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/image-1690308314992.L.resize.32.600.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"file\" /></div></p> <p><strong>第二步</strong>：离散余弦变换（DCT）</p> <p>phash</p> <pre><code class=\"language-python\"> pixels = numpy.asarray(image) dct = scipy.fftpack.dct(scipy.fftpack.dct(pixels, axis=0), axis=1) dctlowfreq = dct[:hash_size, :hash_size]</code></pre> <p>phash_simple</p> <pre><code class=\"language-python\"> pixels = numpy.asarray(image) dct = scipy.fftpack.dct(pixels) dctlowfreq = dct[:hash_size, 1:hash_size+1]</code></pre> <p>使用<code>numpy.asarray()</code>将<code>image</code>图像的每一个像素读取出明度值，输出大概长这样。</p> <pre><code class=\"language-python\">array([[ 33, 155, 191, ..., 12, 14, 17], [133, 180, 178, ..., 15, 17, 17], [186, 178, 172, ..., 21, 19, 18], ..., [126, 122, 116, ..., 99, 103, 91], [103, 101, 98, ..., 102, 100, 97], [ 92, 89, 90, ..., 97, 96, 94]], dtype=uint8)</code></pre> <p>紧随其后的就是 <strong>离散余弦变换</strong> ，这是官网给出的计算公式<a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.dct.html#scipy.fftpack.dct\" title=\"scipy.fftpack.dct\">[4]</a></p> <pre><code class=\"language-katex\"> y_{k}=2 \\sum_{n=0}^{N-1} x_{n} \\cos \\left(\\frac{\\pi k(2 n+1)}{2 N}\\right)</code></pre> <p><code>phash</code>和<code>phash_simple</code>的区别就在这里，前者是对<code>pixels</code>，也就是图像明度的每一轴都变换一次；而后者只运算了一次，所以称之为所谓的<code>simple</code>。</p> <p><code>phash_simple</code>中，对于 dct 的取值为什么要从<code>0</code>到<code>hash_size</code>和<code>1</code>到<code>hash_size+1</code>，博客中大佬给出的解释是这样的。</p> <blockquote> <p>Like the Average Hash, compute the mean DCT value (using only the 8&#215;8 DCT low-frequency values and excluding the first term since the DC coefficient can be significantly different from the other values and will throw off the average). Thanks to David Starkweather for the added information about pHash. He wrote: &quot;the dct hash is based on the low 2D DCT coefficients starting at the second from lowest, leaving out the first DC term. This excludes completely flat image information (i.e. solid colors) from being included in the hash description.&quot;&quot;<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\" title=\"Looks\">[5]</a></p> </blockquote> <p>像平均哈希一样，计算平均 DCT 值（只使用 8&#215;8 的 DCT 低频值，不包括第一项，因为改 DC 系数可能与其他值有很大不同，会影响中位数）。感谢 David Starkweather 提供的关于 pHash 的补充信息。他写道：&quot;dct 哈希是基于从最低的第二个开始的低二维 DCT 系数，排除了第一个 DC 项。这就把完全平坦的图像信息（即纯色）排除在散列描述之外&quot;。</p> <pre><code class=\"language-python\">dctlowfreq = dct[:hash_size, 1:hash_size+1]</code></pre> <p>接着减小 DCT 的输出，虽然 DCT 处理之后输出的是 32<em>32 的矩阵，但是我们只保留其中左上角的 8</em>8，这代表了该图像中最低频的部分。</p> <p><strong>第三步</strong>：计算哈希</p> <pre><code class=\"language-python\"> med = numpy.median(dctlowfreq) diff = dctlowfreq &gt; med</code></pre> <p>对输出的<code>dctlowfreq</code>低频因子用<code>numpu.median()</code>求得中位数，再把低频因子中每一位与该中位数比较，大于则为 True，小于则为 False，再将此差异序列<code>diff</code>输出哈希。</p> <h4>dhash</h4> <blockquote> <p>Like aHash and pHash, dHash is pretty simple to implement and is far more accurate than it has any right to be. As an implementation, dHash is nearly identical to aHash but it performs much better.<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html\" title=\"Kind\">[6]</a></p> </blockquote> <p>与 aHash 和 pHash 一样，dHash 的实现相当简单，而且要准确得多。实现起来，dHash 几乎与 aHash 相同，但它的表现要好得多。</p> <pre><code class=\"language-python\">def dhash(image, hash_size=8): &quot;&quot;&quot; Difference Hash computation. following http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html computes differences horizontally @image must be a PIL instance. &quot;&quot;&quot; # resize(w, h), but numpy.array((h, w)) if hash_size &lt; 2: raise ValueError(&quot;Hash size must be greater than or equal to 2&quot;) image = image.convert(&quot;L&quot;).resize((hash_size + 1, hash_size), Image.ANTIALIAS) pixels = numpy.asarray(image) # compute differences between columns diff = pixels[:, 1:] &gt; pixels[:, :-1] return ImageHash(diff) def dhash_vertical(image, hash_size=8): &quot;&quot;&quot; Difference Hash computation. following http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html computes differences vertically @image must be a PIL instance. &quot;&quot;&quot; # resize(w, h), but numpy.array((h, w)) image = image.convert(&quot;L&quot;).resize((hash_size, hash_size + 1), Image.ANTIALIAS) pixels = numpy.asarray(image) # compute differences between rows diff = pixels[1:, :] &gt; pixels[:-1, :] return ImageHash(diff)</code></pre> <p><strong>注意</strong>：传入的参数<code>hash_size</code>必须要＞ 2，否则会返回<code>ValueError</code>错误。</p> <p><strong>第一步</strong>：将原始图像转为灰度图、缩放图片、平滑滤波</p> <p>放缩的方式与<code>ahash</code>和<code>phash</code>一致。</p> <p>值得我们注意的是，<code>dhash</code>默认的缩放并不是直接缩放成 8<em>8，而是 9</em>8，具体的理由在下面会提出。</p> <p><strong>第二步</strong>：计算差异</p> <p><code>dhash</code>是水平计算哈希，而<code>dhash_vertical</code>是垂直计算哈希。</p> <p>正如前面所说，<code>dhash</code>比较的是梯度差异，这样就确定了图像的相对梯度方向，九列像素两两比较，生成八个值，这就是为什么我们要选取 9*8 大小的原因。</p> <pre><code class=\"language-python\"> image = image.convert(&quot;L&quot;).resize((hash_size + 1, hash_size), Image.ANTIALIAS) pixels = numpy.asarray(image)</code></pre> <p><strong>第三步</strong>：生成哈希</p> <p>如果每一列右边的像素比左边的亮，则输出<code>Ture</code>，否则输出<code>False</code>。</p> <pre><code class=\"language-python\"> diff = pixels[1:, :] &gt; pixels[:-1, :] return ImageHash(diff)</code></pre> <h4>whash</h4> <h5>什么是 Wavelet（小波）</h5> <blockquote> <p>A wavelet is a wave-like oscillation with an amplitude that begins at zero, increases or decreases, and then returns to zero one or more times. Wavelets are termed a &quot;brief oscillation&quot;. A taxonomy of wavelets has been established, based on the number and direction of its pulses. Wavelets are imbued with specific properties that make them useful for signal processing.</p> </blockquote> <p>小波是一种波状振荡，其振幅从零开始，增加或减少，然后一次或多次返回到零。小波被称为 &quot;短暂振荡&quot;。根据其脉冲的数量和方向，已经建立了一个小波的分类法。小波被赋予了特定的属性，使它们在信号处理中很有用。</p> <blockquote> <p>For example, a wavelet could be created to have a frequency of Middle C and a short duration of roughly one tenth of a second. If this wavelet were to be convolved with a signal created from the recording of a melody, then the resulting signal would be useful for determining when the Middle C note appeared in the song. Mathematically, a wavelet correlates with a signal if a portion of the signal is similar. Correlation is at the core of many practical wavelet applications.</p> </blockquote> <p>例如，可以创建一个频率为中央 C，其持续时间大约为十分之一秒的小波。如果将这个小波与一个从旋律录音中产生的信号进行卷积，那么产生的信号将有助于确定中央 C 音符何时出现在歌曲中。在数学上，如果信号的一部分是相似的，那么小波就与信号相关。相关性是许多实际小波应用的核心。</p> <blockquote> <p>As a mathematical tool, wavelets can be used to extract information from many different kinds of data, including – but not limited to – audio signals and images. Sets of wavelets are needed to analyze data fully. &quot;Complementary&quot; wavelets decompose a signal without gaps or overlaps so that the decomposition process is mathematically reversible. Thus, sets of complementary wavelets are useful in wavelet based compression/decompression algorithms where it is desirable to recover the original information with minimal loss.<a href=\"https://en.wikipedia.org/wiki/Wavelet\" title=\"Wavelet\">[7]</a></p> </blockquote> <p>作为一种数学工具，小波可以被用来从许多不同种类的数据中提取信息，包括但不限于音频信号和图像。小波也会被成套的用来全面分析数据。互补小波对信号进行分解的没有空隙或重叠，因此分解过程在数学上是可逆的。因此，在基于小波的压缩/解压缩算法中，互补小波的集合是有用的，此算法也许能以最小的损失恢复原始信息。</p> <pre><code class=\"language-python\">def whash(image, hash_size = 8, image_scale = None, mode = &#039;haar&#039;, remove_max_haar_ll = True): &quot;&quot;&quot; Wavelet Hash computation. based on https://www.kaggle.com/c/avito-duplicate-ads-detection/ @image must be a PIL instance. @hash_size must be a power of 2 and less than @image_scale. @image_scale must be power of 2 and less than image size. By default is equal to max power of 2 for an input image. @mode (see modes in pywt library): &#039;haar&#039; - Haar wavelets, by default &#039;db4&#039; - Daubechies wavelets @remove_max_haar_ll - remove the lowest low level (LL) frequency using Haar wavelet. &quot;&quot;&quot; import pywt if image_scale is not None: assert image_scale &amp; (image_scale - 1) == 0, &quot;image_scale is not power of 2&quot; else: image_natural_scale = 2**int(numpy.log2(min(image.size))) image_scale = max(image_natural_scale, hash_size) ll_max_level = int(numpy.log2(image_scale)) level = int(numpy.log2(hash_size)) assert hash_size &amp; (hash_size-1) == 0, &quot;hash_size is not power of 2&quot; assert level &lt;= ll_max_level, &quot;hash_size in a wrong range&quot; dwt_level = ll_max_level - level image = image.convert(&quot;L&quot;).resize((image_scale, image_scale), Image.ANTIALIAS) pixels = numpy.asarray(image) / 255. # Remove low level frequency LL(max_ll) if @remove_max_haar_ll using haar filter if remove_max_haar_ll: coeffs = pywt.wavedec2(pixels, &#039;haar&#039;, level = ll_max_level) coeffs = list(coeffs) coeffs[0] *= 0 pixels = pywt.waverec2(coeffs, &#039;haar&#039;) # Use LL(K) as freq, where K is log2(@hash_size) coeffs = pywt.wavedec2(pixels, mode, level = dwt_level) dwt_low = coeffs[0] # Substract median and compute hash med = numpy.median(dwt_low) diff = dwt_low &gt; med return ImageHash(diff)</code></pre> <blockquote> <p>Wavelets are a popular tool for computational harmonic analysis. They provide localization in both the temporal (or spatial) domain as well as in the frequency domain (Daubechies, 1992). A prominent feature is the ability to perform a multiresolution analysis (S. Mallat, 2008). The wavelet transform of natural signals and images tends to have most of its energy concentrated in a small fraction of the coefficients. This sparse representation property is key to the good performance of wavelets in applications such as data compression and denoising. For example, the wavelet transform is a key component of the JPEG 2000 image compression standard.<a href=\"https://joss.theoj.org/papers/10.21105/joss.01237\" title=\"Journal\">[9]</a></p> </blockquote> <p>小波是计算谐波分析的一个流行工具。它们在时域（或空间）和频域上都能提供定位（Daubechies，1992）。一个突出的特点是能够进行多分辨率分析（S. Mallat, 2008）。自然信号和图像的小波变换倾向于将其大部分能量集中在一小部分系数中。这种稀疏的表示特性是小波在数据压缩和去噪等应用中表现良好的关键。例如，小波变换是 JPEG 2000 图像压缩标准的一个关键组成部分。</p> <div class='collapse-block shadow-sm collapse-block-transparent hide-border-left'><div class='collapse-block-title'><span class='collapse-block-title-inner'>提示</span><i class='collapse-icon fa fa-angle-down'></i></div><div class='collapse-block-body' style='display:none;'>这里应该到了计算机图形/视频研究技术的前沿，鉴于书樱只是一个普普通通的高中生，没有牢固的数学知识和英语水平，对于这样的研究书樱并不在行。有兴趣的朋友可以 Google 搜索**wavelet**等关键词，以获得更全面深刻的信息</div></div> <h4>colorhash</h4> <pre><code class=\"language-python\">def colorhash(image, binbits=3): &quot;&quot;&quot; Color Hash computation. Computes fractions of image in intensity, hue and saturation bins: * the first binbits encode the black fraction of the image * the next binbits encode the gray fraction of the remaining image (low saturation) * the next 6*binbits encode the fraction in 6 bins of saturation, for highly saturated parts of the remaining image * the next 6*binbits encode the fraction in 6 bins of saturation, for mildly saturated parts of the remaining image @binbits number of bits to use to encode each pixel fractions &quot;&quot;&quot; # bin in hsv space: intensity = numpy.asarray(image.convert(&quot;L&quot;)).flatten() h, s, v = [numpy.asarray(v).flatten() for v in image.convert(&quot;HSV&quot;).split()] # black bin mask_black = intensity &lt; 256 // 8 frac_black = mask_black.mean() # gray bin (low saturation, but not black) mask_gray = s &lt; 256 // 3 frac_gray = numpy.logical_and(~mask_black, mask_gray).mean() # two color bins (medium and high saturation, not in the two above) mask_colors = numpy.logical_and(~mask_black, ~mask_gray) mask_faint_colors = numpy.logical_and(mask_colors, s &lt; 256 * 2 // 3) mask_bright_colors = numpy.logical_and(mask_colors, s &gt; 256 * 2 // 3) c = max(1, mask_colors.sum()) # in the color bins, make sub-bins by hue hue_bins = numpy.linspace(0, 255, 6+1) if mask_faint_colors.any(): h_faint_counts, _ = numpy.histogram(h[mask_faint_colors], bins=hue_bins) else: h_faint_counts = numpy.zeros(len(hue_bins) - 1) if mask_bright_colors.any(): h_bright_counts, _ = numpy.histogram(h[mask_bright_colors], bins=hue_bins) else: h_bright_counts = numpy.zeros(len(hue_bins) - 1) # now we have fractions in each category (6*2 + 2 = 14 bins) # convert to hash and discretize: maxvalue = 2**binbits values = [min(maxvalue-1, int(frac_black * maxvalue)), min(maxvalue-1, int(frac_gray * maxvalue))] for counts in list(h_faint_counts) + list(h_bright_counts): values.append(min(maxvalue-1, int(counts * maxvalue * 1. / c))) # print(values) bitarray = [] for v in values: bitarray += [v // (2**(binbits-i-1)) % 2**(binbits-i) &gt; 0 for i in range(binbits)] return ImageHash(numpy.asarray(bitarray).reshape((-1, binbits)))</code></pre> <p>&#8212; 更新中。。。</p> <h2>参考资料</h2> <ol> <li><a href=\"https://zh.wikipedia.org/zh-hans/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8\">&quot;散列函数 &#8211; 维基百科，自由的百科全书</a></li> <li><a href=\"https://zh.wikipedia.org/zh-hans/%E7%A6%BB%E6%95%A3%E4%BD%99%E5%BC%A6%E5%8F%98%E6%8D%A2\">离散余弦变换 &#8211; 维基百科，自由的百科全书</a></li> <li><a href=\"https://docs.scipy.org/doc/scipy/tutorial/general.html\">Introduction — SciPy v1.8.0 Manual</a></li> <li><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.dct.html#scipy.fftpack.dct\">scipy.fftpack.dct — SciPy v1.8.0 Manual</a></li> <li><a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">Looks Like It &#8211; The Hacker Factor Blog</a></li> <li><a href=\"http://www.hackerfactor.com/blog/index.php?/archives/529-Kind-of-Like-That.html\">Kind of Like That &#8211; The Hacker Factor Blog</a></li> <li><a href=\"https://en.wikipedia.org/wiki/Wavelet\">Wavelet &#8211; Wikipedia</a></li> <li><a href=\"https://pywavelets.readthedocs.io/en/latest/\">PyWavelets &#8211; Wavelet Transforms in Python — PyWavelets Documentation</a></li> <li><a href=\"https://joss.theoj.org/papers/10.21105/joss.01237\">Journal of Open Source Software: PyWavelets: A Python package for wavelet analysis</a></li> </ol> <p>To be continue -&gt;</p>",
    "publishDate": "2021-02-27T16:00:54.000Z",
    "modifiedDate": "2023-07-25T18:09:16.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 6,
        "name": "「论一个随机图片api的养成计划」",
        "slug": "to-make-a-pic-api",
        "parent": 5,
        "count": 2
      },
      {
        "id": 5,
        "name": "项目",
        "slug": "project",
        "count": 3
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 276,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-e1706177626421.png",
      "alt": "",
      "title": "image-hash-algorithm",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-e1706177626421.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-300x187.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"187\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-300x187.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-300x187.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-1024x637.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/image-hash-algorithm-e1706177626421.png"
      },
      "width": 778,
      "height": 484,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2021/02/image-hash-algorithm/",
    "wordCount": 2915,
    "readingTime": 15,
    "seo": {
      "title": "【二】imagehash算法解析【Python】",
      "description": "<p>「论一个随机图片 api 的养成计划」 前段时间，书樱用 Python 稍微抓取了 Pixiv 的图片，总共大 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2021/02/image-hash-algorithm/"
    }
  },
  {
    "id": "248",
    "title": "春运，一场共享发展的旅程【杂谈】",
    "slug": "chunyun",
    "excerpt": "<p>腾空而起的航班带着牵挂穿过云霄，呼啸而过的列车满载乡愁纵横南北，乘风破浪的航船让思念跨越江海……这场一年一度“ [&hellip;]</p>",
    "content": "<p>腾空而起的航班带着牵挂穿过云霄，呼啸而过的列车满载乡愁纵横南北，乘风破浪的航船让思念跨越江海……这场一年一度“人类最大规模的周期性迁徙”，以渴望团圆的“春运表情”，勾勒出流动中国的时代图景。</p> <p>时间是最客观的见证者。不久前，网络上发起了“十年对比挑战”的热门话题，有网友晒出十年前和十年后的铁路春运照片，感慨“十年什么都在变，绿皮火车驶向了远方成为追念；十年却又什么都没变，那些思念之情在高铁上依然心切。”从绿皮车到“复兴号”，从没有信号到WiFi满格，从通宵排队到网上订票，路还是那条回家的路，但旅程有了不一样的意义，时间有了不一样的刻度。春运的变与不变就像一面镜子，折射出个人回家的旅途、温暖的归程，映照着国家前进的步伐、时代发展的脉动。</p> <p>千里故乡一日还，每个人都希望让思念早一点抵达。可以说，快，是春运“开足马力”的主题曲，也是读懂春运的一个关键词。1978年，全国旅客列车平均速度为每小时43公里，而时至今日，时速350公里的“复兴号”高铁川流不息。不断提速的车轮，是经济社会快速发展的一个投射，对应的正是不断前行的美好生活、日新月异的发展脚步。使用二维码可以直接乘车，自助刷脸能够快速进站，手机扫一扫就能自动识别信息、在线使用服务……无论是缩短的距离，还是节省的时间，无论是效率的提升，还是服务的优化，都让赶路的身影更加从容，让眺望的目光更加深远，让发展的阳光照进每一个普通人的回家路。</p> <p>车轮再快，也不能忘记为了什么出发，“快春运”里也有“慢风景”。从内蒙古自治区根河市满归镇开往海拉尔方向有一趟“为一个人停车的‘冷极’慢火车”，每到大雪封山的季节就是沿途百姓出行的首选交通方式，被亲切地称为“公交招手停”。如果说“快”象征的是奔跑的姿态，那么“慢”就是守望的温情；如果说“快”代表的是风驰电掣的发展速度，那么“慢”就是要实现每个人都能上车、一个都不能少的公平与共享。从一些地方组织志愿者为农民工在网上订购车票，到铁路部门在客流高峰期加开大量临客列车，都是为了满足多元化、差异性的出行需求，让春运路上的每一次出发都能抵达回家的路。</p> <p>春运的变与不变、快慢之间，实际上是中国迅速发展的隐喻：让普通群众能够分享经济社会快速发展的红利，在做大蛋糕的同时分好蛋糕，在快速发展中践行这样的理念：“共享发展是人人享有、各得其所，不是少数人共享、一部分人共享”。当然，共享也需要共建，为了让共享的发展红利最大化，还需要每一位春运旅客的参与和支持。且不论相关部门要求依法严惩“车闹”“机闹”“高铁霸座”等旅客严重不文明行为，就看世界最长的高铁里程，就看那些为维护春运安全而在春节期间依然坚守岗位的工作人员，我们也应该用实际行动支持春运，让自己的行为更加文明得体，让我们在回家路上虽然摩肩接踵依然善待彼此，让我们的文明真正配得上体面的回家。</p> <p>户外温度-4℃，候车大厅18℃，飞机舱内25℃，拥抱的体温36.5℃……春运开始不久，一则观察“回家温度”的视频温暖了无数人的心。让每个人都能在春运的旅途感受温暖，春运之旅就将不仅是一条回家的路，还是一条前进的路、发展的路。</p> <blockquote> <p><a href=\"http://opinion.people.com.cn/n1/2019/0201/c1003-30604174.html\">《人民日报》（2019年02月01日 05版）</a></p> </blockquote>",
    "publishDate": "2021-02-11T16:00:30.000Z",
    "modifiedDate": "2023-07-25T18:11:54.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 4,
        "name": "杂谈",
        "slug": "essay",
        "count": 6
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 277,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-scaled-e1706177610824.jpg",
      "alt": "",
      "title": "IMG_20230726_021041",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-scaled-e1706177610824.jpg'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-300x169.jpg'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"169\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-300x169.jpg\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-150x150.jpg",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-300x169.jpg",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-1024x576.jpg",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2021/02/IMG_20230726_021041-scaled-e1706177610824.jpg"
      },
      "width": 778,
      "height": 437,
      "mimeType": "image/jpeg"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2021/02/chunyun/",
    "wordCount": 11,
    "readingTime": 1,
    "seo": {
      "title": "春运，一场共享发展的旅程【杂谈】",
      "description": "<p>腾空而起的航班带着牵挂穿过云霄，呼啸而过的列车满载乡愁纵横南北，乘风破浪的航船让思念跨越江海……这场一年一度“ [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2021/02/chunyun/"
    }
  },
  {
    "id": "29",
    "title": "【一】使用OpenCV、Pillow库分类图片【Python】",
    "slug": "resort-pic-with-opencv-and-pillow",
    "excerpt": "<p>「论一个随机图片api的养成计划」 前段时间，书樱用Python稍微抓取了 Pixiv 的图片，总共大概有三万 [&hellip;]</p>",
    "content": "<h2>「论一个随机图片api的养成计划」</h2> <blockquote> <p>前段时间，书樱用Python稍微抓取了 Pixiv 的图片，总共大概有三万张左右。因为爬取时的爬虫只负责下载了，出现了很多重复的图片以及图片缩略图。最近想搞个图片api，正好可以用上这些二次元图片，所以这个系列暂且叫做「论一个随机图片api的养成计划，于是便有了这篇文章。</p> </blockquote> <p>系列文章合集 -&gt; <a href=\"/archives/category/project/to-make-a-pic-api/\">「论一个随机图片api的养成计划」</a></p> <div class='collapse-block shadow-sm collapse-block-info collapsed hide-border-left'><div class='collapse-block-title'><span class='collapse-block-title-inner'>提示</span><i class='collapse-icon fa fa-angle-down'></i></div><div class='collapse-block-body' style='display:none;'>您正在阅读的是一个系列文章，此系列书樱将会持续更新，敬请关注。</div></div> <p>如果您觉得我写的东西对您有所帮助的话，不妨请我喝杯咖啡。=&gt; <a href=\"/support\" title=\"赞助\">赞助</a></p> <h3>序言</h3> <p>这是这个系列文章的第一篇，因为下一篇涉及的内容会非常多，信息量太大（完全不是因为想水文章），今天把相对简单的内容单独列成一篇，作为开胃小菜。</p> <p>话不宜迟，进入正题。</p> <h2>分类</h2> <h3>思路</h3> <p>图片分类，顾名思义，就是根据各自在图像信息中所反映的不同特征，把不同类别的目标区分开来的图像处理方法。它利用计算机对图像进行定量分析，把图像或图像中的每个像元或区域划归为若干个类别中的某一种，以代替人的视觉判读。<a href=\"https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/5199331\" title=\"图像分类_百度百科\">[1]</a> 所以，自然而然，能供我们分类的信息也有很多。</p> <p>有机会用DL写一个识别天依的程序</p> <p>当然，和广泛定义中的图片分类不一样，这将近三万张图片的分类呢，书樱只想按照长宽比来分类，原因很简单。首先，因为都是来自 Pixiv 的图片，所以不需要对图片内容进行分类。其次，不同设备屏幕长宽比不同，所需要显示图片的长宽比也不同，书樱希望在 api 中设置一个参数，来规范图片返回的长宽比，以适应不同的设备。因此，按尺寸分类图片也就顺理成章了。</p> <h3>算法</h3> <p>很好，现在想法有了，让我们来构思下这个小程序。</p> <ul> <li>首先，我们需要从一个文件夹里读取出图片。</li> <li>接着，读取出图片的长宽信息并计算出长宽比。</li> <li>然后，再按照长宽比对图片进行分类。</li> <li>最后，把分类好的图片转移到新文件夹，按照长宽比分类。</li> </ul> <h3>代码</h3> <p>下面是根据我们想法写代码。</p> <p>分类图片中，书樱使用到了<code>os</code>、<code>shutil</code>和<code>Opencv/Pillow</code>这两（三）个模块。</p> <p><code>os</code>（多种操作系统接口）这个模块不用多说，<code>os</code>提供了非常丰富的方法用来处理文件和目录，功能可以说是非常强大。<a href=\"https://docs.python.org/zh-cn/3/library/os.html\" title=\"os\">[2]</a></p> <p><code>shutil</code>（高阶文件操作）模块提供了一系列对文件和文件集合的高阶操作。特别是提供了一些支持文件拷贝和删除的函数。<a href=\"https://docs.python.org/zh-cn/3/library/shutil.html\" title=\"shutil\">[3]</a></p> <p>关于<code>Opencv</code>和<code>Pillow (PIL)</code>，这里我选择的是<code>Opencv</code>，因为<code>Opencv</code>在各方面速度都比<code>PIL</code>要快上不少，对于庞大数量的图片，这可以给我们省下很多时间，不过对于单线程读取来说，瓶颈在这，当然我也留下<code>PIL</code>的代码。<a href=\"https://zhuanlan.zhihu.com/p/30383580\" title=\"0.伏笔：图像读取方式以及效率对比\">[4]</a><a href=\"https://zhuanlan.zhihu.com/p/91078855\" title=\"Python\">[5]</a></p> <p><code>Opencv</code>和<code>PIL</code>本身就是非常强大的媒体处理库，这方面的内容可谓是相当丰富，特别是在深度学习方面。书樱在这里也只是使用了一些非常简单的功能，只是“冰山半角”，如果有兴趣的朋友可以Google搜索相关文档阅读。</p> <p>下面是导入 Python 模块，<code>import cv2</code>是导入<code>Opencv</code>模块。如果是使用<code>PIL</code>，因为我们使用的函数在<code>Image</code>中，则需要<code>from PIL import Image</code>从<code>PIL</code>库中导入我们需要的<code>Image</code>模块（可选）。</p> <pre><code class=\"language-python\"># 导入模块 import os import cv2 import shutil # from PIL import Image</code></pre> <p>请根据你使用的图片处理库导入相应的模块。</p> <p>导入了我们所需要的模块之后，是时候来处理图片了。</p> <p>首先，我们需要让Python从文件夹中读取图片。</p> <pre><code class=\"language-python\"># 修改这里的路径 path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的</code></pre> <p>我们使用<code>os.listdir()</code>这个函数，传递一个路径<code>path</code>，程序将会依次输出当前目录下的所有文件（夹）。</p> <p>[mdx_fold title=提示 open=false]对于os.listdir()本身是无法区分文件和文件夹的，必须使用os.path.isdir()判断是否为文件夹或使用os.path.isfile()判断是否是文件。为了代码的简便，建议您将待分类的图片单独放在一个文件夹中。[/collapse]</p> <p>首先，定义一个<code>path</code>，用来存储我们待分类的图片的路径。</p> <pre><code class=\"language-python\"># 修改这里的路径，此路径为绝对路径 path = &#039;path\\to\\pic&#039;</code></pre> <p>利用<code>for</code>可以依次将读取出文件名存入<code>file</code>中</p> <pre><code class=\"language-python\"># 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的</code></pre> <p>我们先打印出文件名，以便让我们知道系统当前处理的文件。</p> <p>我们使用了<code>os.chdir()</code>改变当前Python的工作目录，此处的<code>os.chdir()</code>是必要的，原因我会在后文讲到。</p> <p><strong>注意</strong>：<code>os.chdir()</code>中的路径必须存在，否则会丢出<code>FileNotFoundError</code>错误。</p> <p>有了文件名，现在可以让Opencv读取图片了。</p> <pre><code class=\"language-python\"># 修改这里的路径 path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的 im = cv2.imread(file) # Opencv代码 h, w = im.shape[0:2] # im = Image.open(file) # Pillow代码 # h, w = im.size[0:2]</code></pre> <p>使用<code>cv2.imread(file)</code>让Opencv读取图片为对象并保存到<code>im</code>中。</p> <p><code>im.shape[0:2]</code>读取出该文件的图片信息，并返回一个元组。我们将返回的数据存入h,w变量中。</p> <p>[mdx_fold title=cv2.shape open=false]cv.shape操作返回的是一个元组，(h, w, c)，三个参数分别是图片的高度、图片的宽度、颜色通道数，所以在这里我们只需要前两个参数即可[/collapse]</p> <p>对于<code>PIL</code>，只需要把<code>cv2.imread()</code>改成<code>Image.open()</code>，<code>im.shape</code>改成<code>im.size</code>。原理不变。</p> <p>接着是计算长宽比。所谓长宽比，即一个影像的宽度除以高度的比例。<a href=\"https://zh.wikipedia.org/wiki/%E9%95%B7%E5%AF%AC%E6%AF%94_(%E5%BD%B1%E5%83%8F)\" title=\"长宽比\">[6]</a></p> <p>所以，很自然的，长宽比就是<code>w/h</code>。不过大部分长宽比都是无限小数，所以书樱用了<code>round()</code>函数四舍五入，此函数基本用法为：<code>round (数字,保留位数)</code>。</p> <p>当然<code>round()</code>保留之后输出的是浮点数，所以还需要用<code>str()</code>转化成字符串。</p> <pre><code class=\"language-python\"># 修改这里的路径 path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的 im = cv2.imread(file) # Opencv代码 h, w = im.shape[0:2] # im = Image.open(file) # Pillow代码 # h, w = im.size[0:2] size = str(round(w/h, 1)) # 计算长宽比并保留一位小数</code></pre> <p>对于分类好的图片，我们需要让 Python 自动创建文件夹并把图片复制进来。</p> <p>所以我们定义一个函数<code>mkdir()</code>，传递一个参数<code>name</code>作为文件夹名，让Python自动创建文件夹。</p> <p>这里书樱直接使用图片长宽比<code>size</code>做为文件夹名。</p> <p><code>os.path.exists()</code>用于判断路径是否存在并返回布尔值。</p> <pre><code class=\"language-python\">def mkdir(name): # 修改这里的路径，为保存分类后图片的路径 os.chdir(&#039;path\\to\\save\\pic&#039;) if os.path.exists(name): os.chdir(name) else: os.mkdir(name) os.chdir(name)</code></pre> <p>我们先用<code>os.chdir()</code>切换到我们保存图片的路径，请修改此路径为你自己的路径。</p> <p>如果传入的<code>name</code>目录存在，我们则直接切换到该路径下；如果传入的<code>name</code>路径不存在，Python将会使用<code>os.mkdir()</code>创建名为<code>name</code>的文件夹，并用<code>os.chdir()</code>切换到该路径下。</p> <div class='collapse-block shadow-sm collapse-block-info collapsed hide-border-left'><div class='collapse-block-title'><span class='collapse-block-title-inner'>提示</span><i class='collapse-icon fa fa-angle-down'></i></div><div class='collapse-block-body' style='display:none;'>上文提到「<code>os.chdir()</code>是必要的」的原因是：我们在<code>mkdir()</code>函数中切换了文件路径到我们保存分类后图片的文件夹路径，若在程序一开始不切换路径，那么在下一次循环的开始就会出现因为路径不对而读取不到图片导致的错误。不过为了规避这个问题，您也可以使用绝对路径。</div></div> <p>函数创建好了，我们直接调用并创建一个名字为size的文件夹，不过注意此函数要在程序入口之前定义。</p> <pre><code class=\"language-python\"># 修改这里的路径 path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的 im = cv2.imread(file) # Opencv代码 h, w = im.shape[0:2] # im = Image.open(file) # Pillow代码 # h, w = im.size[0:2] size = str(round(w/h, 1)) # 计算并保留一位小数 mkdir(size)</code></pre> <p>最后则将图片按长宽比分类，这里使用的是<code>shutil.copy()</code>复制图片，此函数的用法是<code>shutil.copy(路径前, 路径后)</code>，把<code>copy</code>方法替换成<code>move</code>则是移动此图片。</p> <pre><code class=\"language-python\">import shutil import os import cv2 # 修改这里的路径 path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的 im = cv2.imread(file) # Opencv代码 h, w = im.shape[0:2] # im = Image.open(file) # Pillow代码 # h, w = im.size[0:2] size = str(round(w/h, 1)) # 计算并保留一位小数 mkdir(size) shutil.copy(path + &#039;\\\\&#039; + file, file) # 当操作为移动是此处为shutil.move</code></pre> <p>大功告成！程序会在目标文件夹下生成一系列文件夹。</p> <p>下面是完整的代码</p> <pre><code class=\"language-python\"># 导入模块 # from PIL import Image def mkdir(name): # 修改这里的路径，为保存分类后图片的路径 os.chdir(&#039;path\\to\\save\\pic&#039;) if os.path.exists(name): os.chdir(name) else: os.mkdir(name) os.chdir(name) path = &#039;path\\to\\pic&#039; # 对于 path 里的每一个 file 文件 for file in os.listdir(path): print(file) os.chdir(path) # 此处的os.chdir()是必要的 im = cv2.imread(file) # Opencv代码 h, w = im.shape[0:2] # im = Image.open(file) # Pillow代码 # h, w = im.size[0:2] size = str(round(w/h, 1)) # 计算并保留一位小数 mkdir(size) shutil.copy(path + &#039;\\\\&#039; + file, file) # 当操作为移动是此处为shutil.move</code></pre> <h2>测试</h2> <p>关于<code>PIL</code>和<code>Opencv</code>对于图片的处理速度，书樱做了个简单的测试，此为测试图片，来自Pixiv，画师id：<a href=\"https://www.pixiv.net/users/418969\">418969</a>，作品：<a href=\"https://www.pixiv.net/artworks/82910218\">#VOCALOIDCHINA Espejo</a><a href=\"https://www.pixiv.net/artworks/82910218\"><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://ae01.alicdn.com/kf/Hc784f57058ed4c4f8187461c3d5a999aE.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\" decoding=\"async\" data-original=\"https://ae01.alicdn.com/kf/Hc784f57058ed4c4f8187461c3d5a999aE.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" alt=\"\" /></div></a></p> <p>图片放置在内存盘中，所以应该不存在所谓的读取瓶颈，测试十次，每次读取图片100次，求得平均值。</p> <p>下面是<code>Opencv</code>的测试代码</p> <pre><code class=\"language-python\">import time import cv2 import numpy times = 100 data = [] for i in range(0, 10): start = time.time() for j in range(0, times): cv2.imread(&#039;Z:\\\\0.png&#039;) t = times / (time.time() - start) data.append(t) print(f&quot;第{i+1}次测试,时间:{t}&quot;) print(numpy.average(data))</code></pre> <p>输出如下：</p> <pre><code class=\"language-text\">第1次测试,时间:11.179286012576398 第2次测试,时间:11.03766301872993 第3次测试,时间:10.768910462691446 第4次测试,时间:11.260747744295276 第5次测试,时间:11.387417728544236 第6次测试,时间:11.409427301319251 第7次测试,时间:11.391379203206606 第8次测试,时间:11.386520601823856 第9次测试,时间:11.26953684781443 第10次测试,时间:11.196677950982393 11.228756687198382</code></pre> <p>所以对于<code>Opencv</code>来说，每秒读取了11.2张图片，此测试图片像素为2048*1152，所以<code>Opencv</code>，每秒读取了大约26,491,960个像素。</p> <p>再来看看<code>Pillow</code>的测试，以下为<code>Pillow</code>的测试代码</p> <pre><code class=\"language-python\">import time from PIL import Image import numpy times = 100 data = [] for i in range(0, 10): start = time.time() for j in range(0, times): Image.open(&#039;Z:\\\\0.png&#039;) t = times / (time.time() - start) data.append(t) print(f&quot;第{i+1}次测试,时间:{t}&quot;) print(numpy.average(data))</code></pre> <p>输出如下：</p> <pre><code class=\"language-text\">第1次测试,时间:968.2477463439408 第2次测试,时间:1785.6384450660094 第3次测试,时间:1886.9801508035055 第4次测试,时间:1724.1211483442403 第5次测试,时间:1886.7255044848093 第6次测试,时间:1850.8501202479977 第7次测试,时间:1814.4200030281402 第8次测试,时间:1818.2426662158236 第9次测试,时间:1886.8358427840733 第10次测试,时间:1886.8867725058146 1750.8948399824355</code></pre> <p>所以对于<code>Pillow</code>来说，每秒读取了1750张图片，所以<code>Pillow</code>，每秒读取了大约4,130,879,192个像素。</p> <p>结果让人有点出乎意料，看来<code>Pillow</code>完胜<code>Opencv</code>啊，不过这个数据有点太离谱了，数据大约差了一千倍。这部分内容待定，欢迎纠正。</p> <h2>总结</h2> <p>总结一下，简单来说，运行顺序如下：</p> <ul> <li>程序从文件夹里读取出文件名如<code>114514.png</code>，存入<code>file</code>中，并打印出来。</li> <li>切换工作目录至<code>path</code>下，使用<code>cv2.imread()</code>让<code>Opencv</code>读取图片，此时的<code>im</code>是个类。</li> <li>使用<code>im.shape[0:2]</code>将<code>Opencv</code>读取出<code>cv2.shape</code>元组赋值到<code>h</code>，<code>w</code>。</li> <li>计算出图片长宽比（宽度/高度）<code>size</code>，使用<code>round()</code>保留一位小数，并用<code>str()</code>转化为字符串，此时的<code>size</code>是个字符串。</li> <li>调用函数<code>mkdir()</code>创建并切换至<code>size</code>文件夹，将图片复制(移动)到新文件夹。</li> <li>循环以上步骤直到所有文件都被处理完成。</li> </ul> <p>这样一个分类的小程序算是写好了，还算是比较简单的一个Python程序。因为需要进行IO操作，为了能简单一点，所以书樱在这里也没有使用多线程运行，不过以上操作的速度还是很快的，除非是巨量图片，否则多线程的提升应该也不会很大，那时候瓶颈应该是在IO读写上了而不是CPU上了。</p> <div class='collapse-block shadow-sm collapse-block-info collapsed hide-border-left'><div class='collapse-block-title'><span class='collapse-block-title-inner'>提示</span><i class='collapse-icon fa fa-angle-down'></i></div><div class='collapse-block-body' style='display:none;'>代码运行过程中，可能会出现libpng warning: iCCP: known incorrect sRGB profile提示。此提示对于程序没有任何影响，可以忽略。</div></div> <h2>参考资料</h2> <ol> <li><a href=\"https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/5199331\" title=\"图像分类_百度百科\">图像分类_百度百科</a></li> <li><a href=\"https://docs.python.org/zh-cn/3/library/os.html\">os &#8212; 多种操作系统接口 — Python 3.10.2 文档</a></li> <li><a href=\"https://docs.python.org/zh-cn/3/library/shutil.html\">shutil &#8212; 高阶文件操作 — Python 3.10.2 文档</a></li> <li><a href=\"https://zhuanlan.zhihu.com/p/30383580\">0.伏笔：图像读取方式以及效率对比 &#8211; 知乎</a></li> <li><a href=\"https://zhuanlan.zhihu.com/p/91078855\">Python Pillow 和 cv2 图片 resize 速度的比较 &#8211; 知乎</a></li> <li><a href=\"https://zh.wikipedia.org/wiki/%E9%95%B7%E5%AF%AC%E6%AF%94_(%E5%BD%B1%E5%83%8F)\">长宽比 (影像) &#8211; 维基百科，自由的百科全书</a></li> </ol> <p>To be continue -&gt; <a href=\"archives/2021/02/image-hash-algorithm\">【二】imagehash算法解析【Python】</a></p>",
    "publishDate": "2021-01-30T16:00:57.000Z",
    "modifiedDate": "2023-07-25T18:07:08.000Z",
    "author": {
      "id": 1,
      "name": "SakuraPuare",
      "slug": "sakurapuare",
      "description": "",
      "avatar": "https://gravatar.kuibu.net/avatar/d6caea9d0a771e36f1b5947a64f0840e7e1dc7982fd5101aad2440bd6675aeae?s=96&d=robohash&r=pg",
      "url": "https://blog.sakurapuare.com",
      "socialLinks": {
        "website": "https://blog.sakurapuare.com"
      }
    },
    "categories": [
      {
        "id": 6,
        "name": "「论一个随机图片api的养成计划」",
        "slug": "to-make-a-pic-api",
        "parent": 5,
        "count": 2
      },
      {
        "id": 5,
        "name": "项目",
        "slug": "project",
        "count": 3
      }
    ],
    "tags": [],
    "featuredImage": {
      "id": 263,
      "url": "https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-e1706177599106.png",
      "alt": "",
      "title": "resort-pic-with-opencv-and-pillow",
      "description": "<p class=\"attachment\"><a href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-e1706177599106.png'><div class='fancybox-wrapper lazyload-container-unload' data-fancybox='post-images' href='https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-300x187.png'><img class=\"lazyload lazyload-style-1\" src=\"data:image/svg+xml;base64,PCEtLUFyZ29uTG9hZGluZy0tPgo8c3ZnIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgc3Ryb2tlPSIjZmZmZmZmMDAiPjxnPjwvZz4KPC9zdmc+\"  loading=\"lazy\" decoding=\"async\" width=\"300\" height=\"187\" data-original=\"https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-300x187.png\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" class=\"attachment-medium size-medium\" alt=\"\"  sizes=\"auto, (max-width: 300px) 100vw, 300px\" /></div></a></p>\n",
      "sizes": {
        "thumbnail": "https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-150x150.png",
        "medium": "https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-300x187.png",
        "large": "https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-1024x637.png",
        "full": "https://blog.sakurapuare.com/wp-content/uploads/2021/01/resort-pic-with-opencv-and-pillow-e1706177599106.png"
      },
      "width": 778,
      "height": 484,
      "mimeType": "image/png"
    },
    "language": "zh",
    "status": "publish",
    "commentStatus": "open",
    "pingStatus": "open",
    "sticky": false,
    "format": "standard",
    "originalUrl": "https://blog.sakurapuare.com/archives/2021/01/resort-pic-with-opencv-and-pillow/",
    "wordCount": 661,
    "readingTime": 4,
    "seo": {
      "title": "【一】使用OpenCV、Pillow库分类图片【Python】",
      "description": "<p>「论一个随机图片api的养成计划」 前段时间，书樱用Python稍微抓取了 Pixiv 的图片，总共大概有三万 [&hellip;]</p>",
      "keywords": [],
      "canonicalUrl": "https://blog.sakurapuare.com/archives/2021/01/resort-pic-with-opencv-and-pillow/"
    }
  }
]